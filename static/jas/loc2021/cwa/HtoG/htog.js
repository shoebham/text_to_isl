//-------- js/setup-emcc-node.js --------
// Set up console as expected by CoffeeScript code
this.console = console;
var Module = {
'preRun': [
function () {
if (typeof ENV !== 'undefined') {
ENV.PWD = process.cwd();
}
},
function() {
if (typeof FS !== 'undefined' && typeof fs !== 'undefined') {
var rootents = fs.readdirSync("/");
rootents.forEach(
ent => {
var pat = "/"+ent;
if (fs.statSync(pat).isDirectory()) {
// console.warn("Entry: "+pat+" is a directory");
try {
FS.lookupPath(pat);
// console.warn("Skipping "+pat+" as exists already");
} catch (e) {
// console.warn("Mounting "+pat);
FS.mkdir(pat);
FS.mount(NODEFS, { root: pat }, pat);
}
}
});
cwd = process.cwd();
FS.chdir(cwd);
// console.warn("Tried to chdir to "+cwd);
} else {
console.warn("Either FS or fs or both are undefined");
}
}
]
};
//-------- js/CWAEnv.js --------
// Generated by CoffeeScript 2.5.1
(function() {
// CoffeeScript WebGL ARP Environment set up.
var CWAEnv, navigator;
navigator = this.navigator;
CWAEnv = (function() {
//-----------
class CWAEnv {
//-----------
constructor() {
throw "CWAEnv is not instantiatable.";
}
static add(cls, cname) {
var ref;
this._mod[cname] = cls;
if (cname === "Logger") {
this._lggr = cls.get("CWAEnv"); // , "trace", "stderr"
}
return (ref = this._lggr) != null ? typeof ref.trace === "function" ? ref.trace(`CWAEnv add for ${cname}`) : void 0 : void 0;
}
static get(cname) {
var ref, ref1, res;
if ((ref = this._lggr) != null) {
if (typeof ref.trace === "function") {
ref.trace(`CWAEnv get for ${cname}`);
}
}
res = this._mod[cname];
if (res != null) {
return res;
} else {
return (ref1 = this._lggr) != null ? ref1.warn(`No CWAEnv entry for ${cname}`) : void 0;
}
}
static fixRef(aname, bname) {
return this._mod[aname][`set${bname}`](this._mod[bname]);
}
static _setEnvTags() {
var avlc, ref, uaHas, ualc;
//---------
[avlc, ualc, this.platTag] = navigator != null ? [navigator.appVersion.toLowerCase(), navigator.userAgent.toLowerCase(), navigator.platform] : ["node", "node", "node"];
uaHas = function(str) {
return (ualc.indexOf(`${str}/`)) !== -1;
};
// OPR can be with Chrome
// Chrome can be with Safari
// iOS version of Opera has no browser except Mobile
this.browTag = uaHas("opr") ? "Opera" : (uaHas("edge")) || (uaHas("edgios")) ? "Edge" : (uaHas("firefox")) || (uaHas("fxios")) ? "Firefox" : (uaHas("chrome")) || (uaHas("crios")) ? "Chrome" : uaHas("safari") ? "Safari" : uaHas("trident") ? "IE" : uaHas("mobile") ? "Opera" : `Unknown browser \"${ualc}\"`;
// Seems javaEnabled is unreliable on IE and Edge
// Testing mime types works generally but not on IE
// IE and Edge always report javaEnabled so fail safe
if (this.browTag === "IE") {
// Was: @hasJava = do navigator?.javaEnabled
return this.hasJava = navigator != null ? navigator.javaEnabled() : void 0;
} else {
return this.hasJava = (navigator != null ? (ref = navigator.mimeTypes) != null ? ref['application/x-java-applet'] : void 0 : void 0) != null;
}
}
};
// Static
CWAEnv._mod = {};
CWAEnv._lggr = null;
CWAEnv.platTag = null;
CWAEnv.browTag = null;
CWAEnv.hasJava = false;
CWAEnv._setEnvTags();
return CWAEnv;
}).call(this);
// CWASA will report settings from environment
// Export
this.getCWAEnv = function() {
return CWAEnv;
};
// Make methods available in the normal way as well
CWAEnv.add(CWAEnv, "CWAEnv");
// (End CWAEnv.coffee)
}).call(this);
//-------- js/Logger.js --------
// Generated by CoffeeScript 2.5.1
(function() {
var Logger, console, cwaenv;
cwaenv = this.getCWAEnv();
console = this.console;
Logger = (function() {
var base;
class Logger {
// Class Statics
static _nullLogger() {}
static _baseLogger(lev) {
return console[lev].bind(console);
}
static _tagLogger(lev, nom, tag, force) {
var lfn, lgr, tagstr;
lgr = force === "stderr" ? this.OrigWarnLogger : this._defaultLogger[lev].logger;
while (nom.length < 6) {
nom += " ";
}
if (tag !== "") {
while (tag.length < 5) {
tag += " ";
}
nom += " " + tag;
}
tagstr = nom + ": ";
return lfn = (msg, ...args) => {
return lgr(`${((new Date()).toISOString()).substr(11, 12)} ${tagstr}${msg}`, ...args);
};
}
// List names of installed Loggers as string
static list() {
var i, ix, len, lgr, msg, ref;
msg = "";
ref = this._loggers;
for (ix = i = 0, len = ref.length; i < len; ix = ++i) {
lgr = ref[ix];
if (ix > 0) {
msg += ", ";
}
msg += lgr.modName;
}
return msg;
}
// Object Methods
_setLoggers(newMaxLog, force) {
var lgr, lgrObj, newMaxLogLev, ref, ref1, ref2, results;
newMaxLogLev = Logger._defaultLogger[newMaxLog].lev;
if (force === "noforce") {
newMaxLogLev = Math.min(newMaxLogLev, Logger._buildMaxLogLev);
}
this.maxLog = newMaxLog;
this.maxLogLev = newMaxLogLev;
this.force = force;
ref = Logger._defaultLogger;
results = [];
for (lgr in ref) {
lgrObj = ref[lgr];
if (lgrObj.lev > this.maxLogLev) {
if ((ref1 = Logger._modLogger) != null) {
if (typeof ref1.trace === "function") {
ref1.trace(`Ignoring ${lgr} (lev ${lgrObj.lev}) for ${this.modName}`);
}
}
results.push(this[lgr] = null);
} else {
if ((ref2 = Logger._modLogger) != null) {
if (typeof ref2.trace === "function") {
ref2.trace(`Setting ${lgr} (lev ${Logger._defaultLogger[lgr].lev}) for ${this.modName}`);
}
}
if (force === "stderr") {
// Tag all to stderr with class
results.push(this[lgr] = Logger._tagLogger(lgr, this.modName, lgr, force));
} else {
// Tag debug and trace with class
results.push(this[lgr] = Logger._tagLogger(lgr, this.modName, (lgrObj.lev > 500 ? lgr : ""), force));
}
}
}
return results;
}
// Constructor for Logger
constructor(modName = "anon", newMaxLog, force) {
var ref;
this.modName = modName;
this._setLoggers(newMaxLog, force);
// Note: Logger._modLogger will not be defined when this is first called by this module
if ((ref = Logger._modLogger) != null) {
if (typeof ref.trace === "function") {
ref.trace(`${this.modName} created: ${this.maxLog} (${this.maxLogLev}) ${this.force}`);
}
}
Logger._loggers.push(this);
}
// Find or create named Logger
// Uses Logger._defaultMaxLog if maxLog not set
static get(lgr = "anon", maxLog = "default", force = "default") {
var i, len, lg, ref, ref1, ref2, ref3, stat, theLogger;
theLogger = null;
ref = Logger._loggers;
for (i = 0, len = ref.length; i < len; i++) {
lg = ref[i];
if (lg.modName === lgr) {
if (theLogger == null) {
theLogger = lg;
}
}
}
stat = theLogger != null ? "Updated" : "Created";
if (theLogger != null) {
if (maxLog === "default") {
maxLog = theLogger.maxLog;
}
if (force === "default") {
force = theLogger.force;
}
if ((ref1 = Logger._modLogger) != null) {
if (typeof ref1.trace === "function") {
ref1.trace(`get: Updating ${theLogger.modName} Logger. MaxLog ${theLogger.maxLog} -> ${maxLog}`);
}
}
theLogger._setLoggers(maxLog, force);
} else {
if (maxLog === "default") {
maxLog = Logger._defaultMaxLog;
}
if (force === "default") {
force = "noforce";
}
if ((ref2 = Logger._modLogger) != null) {
if (typeof ref2.trace === "function") {
ref2.trace(`get: Create ${lgr} logger`);
}
}
theLogger = new Logger(lgr, maxLog, force);
}
if ((ref3 = Logger._modLogger) != null) {
if (typeof ref3.debug === "function") {
ref3.debug(`${theLogger.modName} ${stat}: ${theLogger.maxLog} (${theLogger.maxLogLev}) ${theLogger.force}`);
}
}
return theLogger;
}
static _listHooks() {
var base, base1, hk, i, j, len, len1, ref, rep, results, ty, typs;
typs = Object.keys(this._hooks);
if (typeof (base = this._hookLog).trace === "function") {
base.trace(`Listing hooks. Types ${typs}`);
}
results = [];
for (i = 0, len = typs.length; i < len; i++) {
ty = typs[i];
rep = `Hooks for ${ty} (${this._hooks[ty].length}):`;
ref = this._hooks[ty];
for (j = 0, len1 = ref.length; j < len1; j++) {
hk = ref[j];
rep += ` ${hk.typ}/${hk.av}`;
}
results.push(typeof (base1 = this._hookLog).trace === "function" ? base1.trace(rep) : void 0);
}
return results;
}
static addHook(typ, fun, av = "*") {
var base, base1, hook;
if ((base = Logger._hooks)[typ] == null) {
base[typ] = [];
}
hook = {
typ: typ,
fun: fun,
av: av
};
if (typeof (base1 = Logger._hookLog).trace === "function") {
base1.trace(`Adding ${hook.typ} hook [${hook.av}]`);
}
Logger._hooks[typ].push(hook);
return Logger._listHooks();
}
static callHook(typ, msg, av = "*") {
var base, base1, base2, doCall, evt, hk, i, len, ref, results;
if ((base = Logger._hooks)[typ] == null) {
base[typ] = [];
}
evt = {
typ: typ,
msg: msg,
av: av
};
if (typeof (base1 = Logger._hookLog).trace === "function") {
base1.trace(`Calling ${typ} hook for ${av} [${msg}] (${Logger._hooks[typ].length} hooks)`);
}
ref = Logger._hooks[typ];
results = [];
for (i = 0, len = ref.length; i < len; i++) {
hk = ref[i];
doCall = av === "*" || hk.av === "*" || av === hk.av;
if (typeof (base2 = Logger._hookLog).trace === "function") {
base2.trace(`Try ${hk.typ} hook for ${hk.av}: ${doCall ? '' : 'No '}Match`);
}
if (doCall) {
results.push(hk.fun(evt));
} else {
results.push(void 0);
}
}
return results;
}
};
Logger.OrigErrorLogger = Logger._baseLogger("error");
Logger.OrigWarnLogger = Logger._baseLogger("warn");
Logger.OrigLogLogger = Logger._baseLogger("log");
Logger.OrigInfoLogger = Logger._baseLogger("info");
Logger._defaultLogger = {
error: {
lev: 200,
logger: Logger.OrigErrorLogger
},
warn: {
lev: 300,
logger: Logger.OrigWarnLogger
},
log: {
lev: 400,
logger: Logger.OrigLogLogger
},
info: {
lev: 500,
logger: Logger.OrigInfoLogger
},
debug: {
lev: 600,
logger: Logger.OrigInfoLogger
},
trace: {
lev: 700,
logger: Logger.OrigInfoLogger
}
};
// Absolute maximum and default set according to (last character of) version
Logger._buildVersion = "loc2021";
// Treat an unmapped parameter as a production release
[Logger._buildMaxLog, Logger._defaultMaxLog] = (function() {
switch (Logger._buildVersion.slice(-1)) {
case "t":
case "u":
case "v":
return ["trace", "debug"];
case "w":
case "x":
case "y":
return ["trace", "info"];
case "z":
return ["info", "info"];
default:
return ["log", "log"];
}
}).call(this);
Logger._buildMaxLogLev = Logger._defaultLogger[Logger._buildMaxLog].lev;
Logger._loggers = [];
// console.log "Logger testing with multiple arguments. First. %s. %s.", "Second", "Third"
// Override console logs to trap any remaining uses
console.error = function(msg, ...args) {
return Logger.OrigErrorLogger((((new Date()).toISOString()).substr(11, 12)) + " Error: " + msg, ...args);
};
console.warn = function(msg, ...args) {
return Logger.OrigWarnLogger((((new Date()).toISOString()).substr(11, 12)) + " Warn: " + msg, ...args);
};
console.log = function(msg, ...args) {
return Logger.OrigLogLogger((((new Date()).toISOString()).substr(11, 12)) + " Log: " + msg, ...args);
};
console.info = function(msg, ...args) {
return Logger.OrigInfoLogger((((new Date()).toISOString()).substr(11, 12)) + " Info: " + msg, ...args);
};
// Logger for the Logger module
Logger._modLogger = Logger.get("Logger"); // , "debug" # , "stderr"
// Hooks for status reporting
Logger._hookLog = Logger.get("Hooks");
Logger._hooks = {};
if (typeof (base = Logger._modLogger).info === "function") {
base.info(`Build Version ${Logger._buildVersion}. Build MaxLog ${Logger._buildMaxLog}. Build MaxLogLev ${Logger._buildMaxLogLev}. Default MaxLog ${Logger._defaultMaxLog}`);
}
return Logger;
}).call(this);
// Object Methods
// Export
cwaenv.add(Logger, "Logger");
// (End Logger.coffee)
}).call(this);
//-------- js/pretty-data-fix.js --------
/**
* pretty-data - nodejs plugin to pretty-print or minify data in XML, JSON and CSS formats.
*  
* Version - 0.40.0
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/pretty-data/
* 
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*
*	pd.xml(data ) - pretty print XML;
*	pd.json(data) - pretty print JSON;
*	pd.css(data ) - pretty print CSS;
*	pd.sql(data)  - pretty print SQL;
*
*	pd.xmlmin(data [, preserveComments] ) - minify XML; 
*	pd.jsonmin(data)                      - minify JSON; 
*	pd.cssmin(data [, preserveComments] ) - minify CSS; 
*	pd.sqlmin(data)                       - minify SQL; 
*
* PARAMETERS:
*
*	@data  			- String; XML, JSON, CSS or SQL text to beautify;
* 	@preserveComments	- Bool (optional, used in minxml and mincss only); 
*				  Set this flag to true to prevent removing comments from @text; 
*	@Return 		- String;
*	
* USAGE:
*	
*	var pd  = require('pretty-data').pd;
*
*	var xml_pp   = pd.xml(xml_text);
*	var xml_min  = pd.xmlmin(xml_text [,true]);
*	var json_pp  = pd.json(json_text);
*	var json_min = pd.jsonmin(json_text);
*	var css_pp   = pd.css(css_text);
*	var css_min  = pd.cssmin(css_text [, true]);
*	var sql_pp   = pd.sql(sql_text);
*	var sql_min  = pd.sqlmin(sql_text);
*
* TEST:
*	comp-name:pretty-data$ node ./test/test_xml
*	comp-name:pretty-data$ node ./test/test_json
*	comp-name:pretty-data$ node ./test/test_css
*	comp-name:pretty-data$ node ./test/test_sql
*/
function pp() {
this.shift = ['\n']; // array of shifts
this.step = '  '; // 2 spaces
var maxdeep = 100, // nesting level
ix = 0;
// initialize array with shifts //
for(ix=0;ix<maxdeep;ix++){
this.shift.push(this.shift[ix]+this.step); 
}
};	
// ----------------------- XML section ----------------------------------------------------
pp.prototype.xml = function(text, preserveComments) {
var strg = preserveComments ? text
: text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"");
var ar = strg.replace(/>\s{0,}</g,"><")
.replace(/</g,"~::~<")
.replace(/xmlns\:/g,"~::~xmlns:")
.replace(/xmlns\=/g,"~::~xmlns=")
.split('~::~'),
len = ar.length,
inComment = false,
deep = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
// start comment or <![CDATA[...]]> or <!DOCTYPE //
if(ar[ix].search(/<!/) > -1) { 
str += this.shift[deep]+ar[ix];
inComment = true; 
// end comment  or <![CDATA[...]]> //
if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) { 
inComment = false; 
}
} else 
// end comment  or <![CDATA[...]]> //    find --> or ]>
if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) { 
str += ar[ix];
inComment = false; 
} else 
// <elm></elm> //    find prev <tag and this <\tag    but now not prev \>
if( ar[ix-1] != null && ar[ix-1].search(/\/>/) == -1 && /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
/^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) { 
// Omits indentation
// str += ar[ix];
// No longer omits indentation: For compatibility with Java PP routine
str = !inComment ? str += this.shift[--deep]+ar[ix] : str += ar[ix];
// if(!inComment) deep--;
} else
// <elm> //
//    find <tag but not </ or />
if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
str = !inComment ? str += this.shift[deep++]+ar[ix] : str += ar[ix];
} else 
// <elm>...</elm> //    find <tag and </    not sure how both can be on one line
if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
str = !inComment ? str += this.shift[deep]+ar[ix] : str += ar[ix];
} else 
// </elm> //    find </
if(ar[ix].search(/<\//) > -1) { 
str = !inComment ? str += this.shift[--deep]+ar[ix] : str += ar[ix];
} else 
// <elm/> //    find />
if(ar[ix].search(/\/>/) > -1 ) { 
str = !inComment ? str += this.shift[deep]+ar[ix] : str += ar[ix];
} else 
// <? xml ... ?> //
if(ar[ix].search(/<\?/) > -1) { 
str += this.shift[deep]+ar[ix];
} else 
// xmlns //
if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) { 
str += this.shift[deep]+ar[ix];
} 
else {
str += ar[ix];
}
}
return  (str[0] == '\n') ? str.slice(1) : str;
}
// ----------------------- JSON section ----------------------------------------------------
pp.prototype.json = function(text) {
if ( typeof text === "string" ) {
return JSON.stringify(JSON.parse(text), null, this.step);
}
if ( typeof text === "object" ) {
return JSON.stringify(text, null, this.step);
}
return null;
}
// ----------------------- CSS section ----------------------------------------------------
pp.prototype.css = function(text) {
var ar = text.replace(/\s{1,}/g,' ')
.replace(/\{/g,"{~::~")
.replace(/\}/g,"~::~}~::~")
.replace(/\;/g,";~::~")
.replace(/\/\*/g,"~::~/*")
.replace(/\*\//g,"*/~::~")
.replace(/~::~\s{0,}~::~/g,"~::~")
.split('~::~'),
len = ar.length,
deep = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
if( /\{/.exec(ar[ix]))  { 
str += this.shift[deep++]+ar[ix];
} else 
if( /\}/.exec(ar[ix]))  { 
str += this.shift[--deep]+ar[ix];
} else
if( /\*\\/.exec(ar[ix]))  { 
str += this.shift[deep]+ar[ix];
}
else {
str += this.shift[deep]+ar[ix];
}
}
return str.replace(/^\n{1,}/,'');
}
// ----------------------- SQL section ----------------------------------------------------
function isSubquery(str, parenthesisLevel) {
return  parenthesisLevel - (str.replace(/\(/g,'').length - str.replace(/\)/g,'').length )
}
function split_sql(str, tab) {
return str.replace(/\s{1,}/g," ")
.replace(/ AND /ig,"~::~"+tab+tab+"AND ")
.replace(/ BETWEEN /ig,"~::~"+tab+"BETWEEN ")
.replace(/ CASE /ig,"~::~"+tab+"CASE ")
.replace(/ ELSE /ig,"~::~"+tab+"ELSE ")
.replace(/ END /ig,"~::~"+tab+"END ")
.replace(/ FROM /ig,"~::~FROM ")
.replace(/ GROUP\s{1,}BY/ig,"~::~GROUP BY ")
.replace(/ HAVING /ig,"~::~HAVING ")
//.replace(/ IN /ig,"~::~"+tab+"IN ")
.replace(/ IN /ig," IN ")
.replace(/ JOIN /ig,"~::~JOIN ")
.replace(/ CROSS~::~{1,}JOIN /ig,"~::~CROSS JOIN ")
.replace(/ INNER~::~{1,}JOIN /ig,"~::~INNER JOIN ")
.replace(/ LEFT~::~{1,}JOIN /ig,"~::~LEFT JOIN ")
.replace(/ RIGHT~::~{1,}JOIN /ig,"~::~RIGHT JOIN ")
.replace(/ ON /ig,"~::~"+tab+"ON ")
.replace(/ OR /ig,"~::~"+tab+tab+"OR ")
.replace(/ ORDER\s{1,}BY/ig,"~::~ORDER BY ")
.replace(/ OVER /ig,"~::~"+tab+"OVER ")
.replace(/\(\s{0,}SELECT /ig,"~::~(SELECT ")
.replace(/\)\s{0,}SELECT /ig,")~::~SELECT ")
.replace(/ THEN /ig," THEN~::~"+tab+"")
.replace(/ UNION /ig,"~::~UNION~::~")
.replace(/ USING /ig,"~::~USING ")
.replace(/ WHEN /ig,"~::~"+tab+"WHEN ")
.replace(/ WHERE /ig,"~::~WHERE ")
.replace(/ WITH /ig,"~::~WITH ")
//.replace(/\,\s{0,}\(/ig,",~::~( ")
//.replace(/\,/ig,",~::~"+tab+tab+"")
.replace(/ ALL /ig," ALL ")
.replace(/ AS /ig," AS ")
.replace(/ ASC /ig," ASC ") 
.replace(/ DESC /ig," DESC ") 
.replace(/ DISTINCT /ig," DISTINCT ")
.replace(/ EXISTS /ig," EXISTS ")
.replace(/ NOT /ig," NOT ")
.replace(/ NULL /ig," NULL ")
.replace(/ LIKE /ig," LIKE ")
.replace(/\s{0,}SELECT /ig,"SELECT ")
.replace(/~::~{1,}/g,"~::~")
.split('~::~');
}
pp.prototype.sql = function(text) {
var ar_by_quote = text.replace(/\s{1,}/g," ")
.replace(/\'/ig,"~::~\'")
.split('~::~'),
len = ar_by_quote.length,
ar = [],
deep = 0,
tab = this.step,//+this.step,
inComment = true,
inQuote = false,
parenthesisLevel = 0,
str = '',
ix = 0;
for(ix=0;ix<len;ix++) {
if(ix%2) {
ar = ar.concat(ar_by_quote[ix]);
} else {
ar = ar.concat(split_sql(ar_by_quote[ix], tab) );
}
}
len = ar.length;
for(ix=0;ix<len;ix++) {
parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);
if( /\s{0,}\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
ar[ix] = ar[ix].replace(/\,/g,",\n"+tab+tab+"")
} 
if( /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(ar[ix]))  { 
deep++;
str += this.shift[deep]+ar[ix];
} else 
if( /\'/.exec(ar[ix]) )  { 
if(parenthesisLevel<1 && deep) {
deep--;
}
str += ar[ix];
}
else  { 
str += this.shift[deep]+ar[ix];
if(parenthesisLevel<1 && deep) {
deep--;
}
} 
}
str = str.replace(/^\n{1,}/,'').replace(/\n{1,}/g,"\n");
return str;
}
// ----------------------- min section ----------------------------------------------------
pp.prototype.xmlmin = function(text, preserveComments) {
var str = preserveComments ? text
: text.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g,"");
return  str.replace(/>\s{0,}</g,"><"); 
}
pp.prototype.jsonmin = function(text) {
return  text.replace(/\s{0,}\{\s{0,}/g,"{")
.replace(/\s{0,}\[$/g,"[")
.replace(/\[\s{0,}/g,"[")
.replace(/:\s{0,}\[/g,':[')
.replace(/\s{0,}\}\s{0,}/g,"}")
.replace(/\s{0,}\]\s{0,}/g,"]")
.replace(/\"\s{0,}\,/g,'",')
.replace(/\,\s{0,}\"/g,',"')
.replace(/\"\s{0,}:/g,'":')
.replace(/:\s{0,}\"/g,':"')
.replace(/:\s{0,}\[/g,':[')
.replace(/\,\s{0,}\[/g,',[')
.replace(/\,\s{2,}/g,', ')
.replace(/\]\s{0,},\s{0,}\[/g,'],[');   
}
pp.prototype.cssmin = function(text, preserveComments) {
var str = preserveComments ? text
: text.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\//g,"") ;
return str.replace(/\s{1,}/g,' ')
.replace(/\{\s{1,}/g,"{")
.replace(/\}\s{1,}/g,"}")
.replace(/\;\s{1,}/g,";")
.replace(/\/\*\s{1,}/g,"/*")
.replace(/\*\/\s{1,}/g,"*/");
}	
pp.prototype.sqlmin = function(text) {
return text.replace(/\s{1,}/g," ").replace(/\s{1,}\(/,"(").replace(/\s{1,}\)/,")");
}
// --------------------------------------------------------------------------------------------
// this.Pretty = new pp;	
this.getCWAEnv().add(new pp, "Pretty");
//-------- js/Access.Node.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   Access.Node.coffee
// Data transfers using node.js fs and xmldom modules
var Access, FS, Logger, Node, XMLSerialize, cwaenv, lggr, xmlDOM;
cwaenv = this.getCWAEnv();
Logger = cwaenv.get("Logger");
lggr = Logger.get("Data");
FS = require("fs");
xmlDOM = require("xmldom");
XMLSerialize = new xmlDOM.XMLSerializer();
Node = {
ELEMENT_NODE: 1,
TEXT_NODE: 3,
PROCESSING_INSTRUCTION_NODE: 7,
COMMENT_NODE: 8,
DOCUMENT_NODE: 9,
DOCUMENT_TYPE_NODE: 10
};
Access = (function() {
class Access {
// Static
static _DOMerr(level, msg) {
if (Access._DOMerrCB) {
return Access._DOMerrCB(level, msg);
} else {
return lggr.warn(`Access.Node: DOM Error (${level}) ${msg}`);
}
}
// Convert XML text to DOM
static toDOM(theXML, errCB = null) {
// Handles DOCTYPE badly
Access._DOMerrCB = errCB;
return Access._DOMParse.parseFromString(theXML, "text/xml");
}
// Get a file or return null. Errors reported via callback.
static fetchURI(theURI, theCB, form = null) {
var doData;
if (typeof lggr.trace === "function") {
lggr.trace(`Access.Node fetchURI: Fetching ${theURI}`);
}
doData = (err, data) => {
var errMsg;
if (err) {
if (err.code === "ENOENT") {
errMsg = `fetchURI: ${theURI} does not exist`;
} else {
errMsg = `fetchURI: Error ${err.code} for ${theURI}`;
}
if (typeof lggr.trace === "function") {
lggr.trace(`Access.Node fetchURI: ${errMsg}`);
}
// Probably return null partial data
return theCB(null, 1, errMsg, data);
} else {
// Deal with potential newline issue but probably should only be for text files
data = (data.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
if (typeof lggr.trace === "function") {
lggr.trace(`Access.Node fetchURI: Fetched ${theURI}`);
}
return theCB(data, 0, null, data);
}
};
// Read the URI
return FS.readFile(theURI, "utf-8", doData);
}
};
Access._DOMParse = new xmlDOM.DOMParser({
locator: {},
errorHandler: Access._DOMerr
});
return Access;
}).call(this);
// Export
cwaenv.add(Access, "Access");
cwaenv.add(XMLSerialize, "XMLSerialize");
cwaenv.add(Node, "Node");
// Provide console as expected by Coffee code
// @console = console # Now in setup-emcc-node.js JRWG
// (End Access.Node.coffee)
}).call(this);
//-------- js/Data.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//	Data.coffee
// Common data access and manipulation routines building on Access class
var Access, Data, Logger, Pretty, XMLSerialize, cwaenv, lggr;
cwaenv = this.getCWAEnv();
Access = cwaenv.get("Access");
Pretty = cwaenv.get("Pretty");
XMLSerialize = cwaenv.get("XMLSerialize");
Logger = cwaenv.get("Logger");
lggr = Logger.get("Data");
Data = (function() {
class Data {
// Construct return value
static result(val, errCount, errText, partVal) {
return {
value: val,
errCount: errCount,
errText: errText,
partVal: partVal
};
}
// Parse to JSON safely
static parseJSON(jstr) {
if (typeof lggr.trace === "function") {
lggr.trace(`JSON.parse for \"${jstr}\"`);
}
if ((jstr != null) && jstr.length > 0) {
return JSON.parse(jstr);
} else {
lggr.warn(`JSON.parse failed for \"${jstr}\"`);
return null;
}
}
// Chain callbacks
static tee(cbA, cbB) {
return () => {
cbA();
return cbB();
};
}
// ---------- Pretty Print routines -------------- #
// Pretty Print JSON object or text
static ppJSON(theJSON) {
return Pretty.json(theJSON);
}
// Minimal JSON object or text
static mnJSON(theJSON) {
if (typeof theJSON === "object") {
theJSON = JSON.stringify(theJSON);
}
return Pretty.jsonmin(theJSON);
}
// Pretty Print XML text
static ppXML(theXML, pres = true) {
return Pretty.xml(theXML, pres);
}
// Minimal XML from XML text
static mnXML(theXML, pres = false) {
return Pretty.xmlmin(theXML, pres);
}
// Pretty Print XML from DOM
static ppDOM(theDOM, pres = true) {
return Pretty.xml(XMLSerialize.serializeToString(theDOM), pres);
}
// Minimal XML from DOM
static mnDOM(theDOM, pres = false) {
return Pretty.xmlmin(XMLSerialize.serializeToString(theDOM), pres);
}
// ---------- URI normalisation routines --------- #
// Splits a URI into components
static splitURI(uri) {
var matches, pattern;
// lggr.trace? "Splitting #{uri}"
pattern = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
matches = uri.match(pattern);
return {
scheme: matches[2],
authority: matches[4],
path: matches[5],
query: matches[7],
fragment: matches[9]
};
}
// Rebuild absolute URI string from components.
// Assumes absolute URI. Ignores fragment element so may need enhancing.
// Omit scheme and authority if not given
static stringURI(uriobj) {
var res;
res = uriobj.path;
if (uriobj != null ? uriobj.authority : void 0) {
res = "//" + uriobj.authority + res;
}
if (uriobj != null ? uriobj.scheme : void 0) {
res = uriobj.scheme + ":" + res;
}
if (uriobj.query != null) {
res += "?" + uriobj.query;
}
return res;
}
// Rebuild URI path string from components.
// Assumes absolute URI. Ignores fragment element so may need enhancing.
static stringURIPath(uriobj) {
var res;
res = uriobj.path;
if (uriobj.query != null) {
res += "?" + uriobj.query;
}
return res;
}
static absoluteSplitURI(uri, base) {
var basedir, baseobj, ref, uriobj;
uriobj = Data.splitURI(uri);
baseobj = Data.splitURI(base);
basedir = baseobj.path.substr(0, (baseobj.path.lastIndexOf("/")) + 1);
return {
scheme: uriobj.scheme || baseobj.scheme,
authority: uriobj.authority || baseobj.authority,
path: ((ref = uriobj.path) != null ? ref.charAt(0) : void 0) === "/" ? uriobj.path : basedir + uriobj.path,
query: uriobj.query || baseobj.query,
fragment: uriobj.fragment || baseobj.fragment
};
}
static absoluteURI(uri, base) {
if (typeof lggr.trace === "function") {
lggr.trace(`uri = ${uri} = ${JSON.stringify(Data.splitURI(uri))}`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`base = ${base} = ${JSON.stringify(Data.splitURI(base))}`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`res = ${Data.stringURI(Data.absoluteSplitURI(uri, base))} ${JSON.stringify(Data.absoluteSplitURI(uri, base))}`);
}
return Data.stringURI(Data.absoluteSplitURI(uri, base));
}
static asDir(uri) {
if (uri.endsWith("/")) {
return uri;
} else {
return uri + "/";
}
}
// Tests whether the given URL is a "data:" URL
static isDataURL(url) {
if (url) {
return (url.substring(0, 5)) === "data:";
} else {
return false;
}
}
// Get a URI as text
static fetchText(theURI, theCB, form) {
var textCB;
textCB = (val, errC, errT, part) => {
if (errC === 0) {
val = (val.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
}
return theCB(val, errC, errT, part);
};
return Data.fetchURI(theURI, textCB, form);
}
// Get a URI as JSON
static fetchJSON(theURI, theCB, form) {
var JSONCB;
JSONCB = (val, errC, errT, part) => {
var err, newJSON;
if (errC > 0 || val.length === 0) {
return theCB(val, errC, errT, part);
} else if (val.length === 0) {
return theCB(null, 1, "No JSON data found", val);
} else {
try {
newJSON = Data.parseJSON(val);
return theCB(newJSON, 0, null, newJSON);
} catch (error) {
err = error;
return theCB(null, 1, err, val);
}
}
};
return Data.fetchURI(theURI, JSONCB, form);
}
// Return a Promise for a fetched URI
//   Currently Builds on Data.fetchURI
//   Later add JSON extensions
//   Currently eager but later could be lazy
//   Currently uncached
static promiseURI(theURI, form) {
return new Promise((resolve, reject) => {
var theCB;
theCB = (val, errC, errT, part) => {
if (errC > 0) {
if (typeof lggr.trace === "function") {
lggr.trace(`promiseURI ${theURI} rejecting ${errT}`);
}
return reject(new Error(JSON.stringify([errC, errT, part])));
} else {
if (typeof lggr.trace === "function") {
lggr.trace(`promiseURI ${theURI} resolving`);
}
return resolve(val);
}
};
return Data.fetchURI(theURI, theCB, form);
});
}
// Return a Promise for a fetched URI as Text
//   Later combine in cache to keep Text Promise
static promiseURIText(theURI, form) {
return (Data.promiseURI(theURI, form)).then(function(res) {
return (res.replace(/\r\n/g, "\n")).replace(/\r/g, "\n");
});
}
// Identify function for use in then for Promises
static id(arg) {
return arg;
}
};
//---------
// Might need a constructor for some configuration uses
// "Static" members.
// ---------- Utility routines ------------------- #
// Linked to Access for now
Data.toDOM = Access.toDOM;
// ---------- Data fetching routines ------------- #
// Get raw data from URI
Data.fetchURI = Access.fetchURI;
return Data;
}).call(this);
// Export
cwaenv.add(Data, "Data");
// cwaenv.add Sync, "Sync"
// (End Data.coffee)
}).call(this);
//-------- js/HNSDefs.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   Definitions fo H-SiGML and G-SiGML files
var HNSDefs, Logger, cwaenv, lggr;
cwaenv = this.getCWAEnv();
Logger = cwaenv.get("Logger");
lggr = Logger.get("SiGML");
HNSDefs = (function() {
class HNSDefs {};
// Statics
HNSDefs.tokenNameMap = [
"", // 00   0
"", // 01   1
"", // 02   2
"", // 03   3
"", // 04   4
"", // 05   5
"", // 06   6
"", // 07   7
"", // 08   8
"hamtab", // 09   9
"hamlinefeed", // 0a  10
"", // 0b  11
"hampagebreak", // 0c  12
"hamreturn", // 0d  13
"", // 0e  14
"", // 0f  15
"", // 10  16
"", // 11  17
"", // 12  18
"", // 13  19
"hamversion40", // 14  20
"", // 15  21
"", // 16  22
"", // 17  23
"", // 18  24
"", // 19  25
"", // 1a  26
"", // 1b  27
"", // 1c  28
"", // 1d  29
"", // 1e  30
"", // 1f  31
"hamspace", // 20  32
"hamexclaim", // 21  33
"hamquery", // 22  34
"hamfullstop", // 23  35
"hamcomma", // 24  36
"hamplus", // 25  37
"hammetaalt", // 26  38
"hamclocku", // 27  39
"hamclockul", // 28  40
"hamclockl", // 29  41
"hamclockdl", // 2a  42
"hamclockd", // 2b  43
"hamclockdr", // 2c  44
"hamclockr", // 2d  45
"hamclockur", // 2e  46
"hamclockfull", // 2f  47
"hamsymmpar", // 30  48
"hamsymmlr", // 31  49
"hamfist", // 32  50
"hamflathand", // 33  51
"hamfinger2", // 34  52
"hamfinger23", // 35  53
"hamfinger23spread", // 36  54
"hamfinger2345", // 37  55
"hamthumboutmod", // 38  56
"hamthumbacrossmod", // 39  57
"hampinch12", // 3a  58
"hampinchall", // 3b  59
"hampinch12open", // 3c  60
"hamcee12", // 3d  61
"hamceeall", // 3e  62
"hamcee12open hamceeopen", // 3f  63
"hamthumbopenmod", // 40  64
"hamfingerstraightmod", // 41  65
"hamfingerbendmod", // 42  66
"hamfingerhookedmod hamfingerhookmod", // 43  67
"hamnondominant", // 44  68
"hamdoublebent", // 45  69
"hamdoublehooked", // 46  70
"", // 47  71
"hamextfingeru", // 48  72
"hamextfingerur", // 49  73
"hamextfingerr", // 4a  74
"hamextfingerdr", // 4b  75
"hamextfingerd", // 4c  76
"hamextfingerdl", // 4d  77
"hamextfingerl", // 4e  78
"hamextfingerul", // 4f  79
"hamextfingerol", // 50  80
"hamextfingero", // 51  81
"hamextfingeror", // 52  82
"hamextfingeril", // 53  83
"hamextfingeri", // 54  84
"hamextfingerir", // 55  85
"hamextfingerui", // 56  86
"hamextfingerdi", // 57  87
"hamextfingerdo", // 58  88
"hamextfingeruo", // 59  89
"", // 5a  90
"", // 5b  91
"", // 5c  92
"hamearlobe", // 5d  93
"hamnostrils", // 5e  94
"hamshouldertop", // 5f  95
"hampalmu", // 60  96
"hampalmur", // 61  97
"hampalmr", // 62  98
"hampalmdr", // 63  99
"hampalmd", // 64 100
"hampalmdl", // 65 101
"hampalml", // 66 102
"hampalmul", // 67 103
"hamreplace", // 68 104
"hamarmextended", // 69 105
"hambehind", // 6a 106
"hametc", // 6b 107
"hamorirelative", // 6c 108
"hamtongue", // 6d 109
"hamteeth", // 6e 110
"hamstomach", // 6f 111
"hamneutralspace", // 70 112
"hamhead", // 71 113
"hamheadtop", // 72 114
"hamforehead", // 73 115
"hameyebrows", // 74 116
"hameyes", // 75 117
"hamnose", // 76 118
"hamear", // 77 119
"hamcheek", // 78 120
"hamlips", // 79 121
"hamchin", // 7a 122
"hamunderchin", // 7b 123
"hamneck", // 7c 124
"hamshoulders", // 7d 125
"hamchest", // 7e 126
"hamstomach", // 7f 127
"hambelowstomach", // 80 128
"hamlrbeside", // 129
"hamlrat", // 130
"hamUpperarm", // 131
"hamelbow", // 132
"hamelbowinside", // 133
"hamlowerarm", // 134
"hamwristback", // 135
"hamwristpulse", // 136
"hamthumbball", // 137
"hampalm", // 138
"hamhandback", // 139
"hamthumb", // 140
"hamindexfinger", // 141
"hammiddlefinger", // 142
"hamringfinger", // 143
"hampinky", // 144
"hamthumbside", // 145
"hampinkyside", // 146
"hambetween", // 147
"hamfingertip", // 148
"hamfingernail", // 149
"hamfingerpad", // 150
"hamfingermidjoint", // 151
"hamfingerbase", // 152
"hamfingerside", // 153
"hamwristtopulse", // 154
"hamwristtoback", // 155
"hamwristtothumb", // 156
"hamwristtopinky", // 157
"hamcoreftag", // 158
"hamcorefref", // 159
"hamnomotion", // 160
"hammoveu", // 161
"hammoveur", // 162
"hammover", // 163
"hammovedr", // 164
"hammoved", // 165
"hammovedl", // 166
"hammovel", // 167
"hammoveul", // 168
"hammoveol", // 169
"hammoveo", // 170
"hammoveor", // 171
"hammoveil", // 172
"hammovei", // 173
"hammoveir", // 174
"hammoveui", // 175
"hammovedi", // 176
"hammovedo", // 177
"hammoveuo", // 178
"hammovecross", // 179
"hammovex", // 180
"hamsmallmod", // 181
"hamlargemod", // 182
"hamarcl", // 183
"hamarcu", // 184
"hamarcr", // 185
"hamarcd", // 186
"hamwavy", // 187
"hamzigzag", // 188
"hamfingerplay", // 189
"hamparbegin", // 190
"hamparend", // 191
"hamcircleo", // 192
"hamcirclei", // 193
"hamcircled", // 194
"hamcircleu", // 195
"hamcirclel", // 196
"hamcircler", // 197
"hamincreasing", // 198
"hamdecreasing", // 199
"hamclose", // 200
"hamtouch", // 201
"haminterlock", // 202
"hamcross", // 203
"hamfast", // 204
"hamslow", // 205
"hamtense", // 206
"hamrest", // 207
"hamhalt", // 208
"hamrepeatfromstart", // 209
"hamrepeatfromstartseveral", // 210
"hamrepeatcontinue", // 211
"hamrepeatcontinueseveral", // 212
"hamseqbegin", // 213
"hamseqend", // 214
"hamalternatingmotion", // 215
"hamrepeatreverse", // 216
"hambrushing", // 217
"hamnonipsi", // 218
"", // 219
"hamellipseh", // 220
"hamellipseur", // 221
"hamellipsev", // 222
"hamellipseul", // 223
"hammime", // 224
"hamaltbegin", // 225
"hamaltend", // 226
"hamnodding", // 227
"hamswinging", // 228
"hamtwisting", // 229
"hamstircw", // 230
"hamstirccw", // 231
"", // 232
"", // 233
"", // 234
"", // 235
"hamfusionbegin", // 236
"hamfusionend", // 237
"", // 238
"", // 239
"hamcircleul", // 240
"hamcircledr", // 241
"hamcircleur", // 242
"hamcircledl", // 243
"hamcircleol", // 244
"hamcircleir", // 245
"hamcircleor", // 246
"hamcircleil", // 247
"hamcircledo", // 248
"hamcircleui", // 249
"hamcircledi", // 250
"hamcircleuo", // 251
"", // 252
"", // 253
"hamnbs", // 254
"" // 255
];
HNSDefs.hamMap = (function() {
var i, ix, j, len, len1, ref, ref1, str, strs, theMap;
theMap = {};
if (typeof lggr.debug === "function") {
lggr.debug(`Building hamMap ${HNSDefs.tokenNameMap.length}`);
}
ref = HNSDefs.tokenNameMap;
for (ix = i = 0, len = ref.length; i < len; ix = ++i) {
strs = ref[ix];
if (typeof lggr.trace === "function") {
lggr.trace(`HNSDefs: ${strs} at ${ix}`);
}
ref1 = strs.split(" ");
for (j = 0, len1 = ref1.length; j < len1; j++) {
str = ref1[j];
theMap[str] = String.fromCharCode(ix);
}
}
return theMap;
})();
HNSDefs.MOUTH_PICTURE_LETTER = "m";
HNSDefs.EYES_LETTER = "e";
HNSDefs.MOUTH_GESTURE_LETTERS = "djlct";
HNSDefs.NON_MOUTH_RELATED_LETTERS = "sbh" + HNSDefs.EYES_LETTER + "n";
HNSDefs.EYES_TAG_LISTS = [
// Eyes - Gaze:
"AD FR HD HI HC UP DN LE RI NO RO LU LD RU RD",
// Eyes - Brows:
"RB RR RL FU",
// Eyes - Lids:
"WB WR WL SB SR SL CB CR CL TB TR TL BB"
];
HNSDefs.HNS_SHOULDER_TAG = "hnm_shoulder";
HNSDefs.HNS_BODY_TAG = "hnm_body";
HNSDefs.HNS_HEAD_TAG = "hnm_head";
HNSDefs.HNS_NOSE_TAG = "hnm_nose";
HNSDefs.NON_MOUTH_RELATED_HML_TAGS = [HNSDefs.HNS_SHOULDER_TAG, HNSDefs.HNS_BODY_TAG, HNSDefs.HNS_HEAD_TAG, null, HNSDefs.HNS_NOSE_TAG];
HNSDefs.HNS_EYEGAZE_TAG = "hnm_eyegaze";
HNSDefs.HNS_EYEBROWS_TAG = "hnm_eyebrows";
HNSDefs.HNS_EYELIDS_TAG = "hnm_eyelids";
HNSDefs.EYE_RELATED_HML_TAGS = [HNSDefs.HNS_EYEGAZE_TAG, HNSDefs.HNS_EYEBROWS_TAG, HNSDefs.HNS_EYELIDS_TAG];
HNSDefs.HNS_MOUTHGESTURE_TAG = "hnm_mouthgesture";
HNSDefs.HNS_MOUTHPICTURE_TAG = "hnm_mouthpicture";
HNSDefs.HNS_EXTRA_TAG = "hnm_extra";
HNSDefs.HNS_NONMAN_TAG = "hamnosys_nonmanual";
HNSDefs.PICTURE_ATTR = "picture";
HNSDefs.TAG_ATTR = "tag";
HNSDefs.xmlSpecials = "<>&\'\"";
HNSDefs.xmlEscapes = ["&lt;", "&gt;", "&amp;", "&apos;", "&quot;"];
return HNSDefs;
}).call(this);
// Export
cwaenv.add(HNSDefs, "HNSDefs");
// (End HNSDefs.coffee)
}).call(this);
//-------- js/antlr3-all-fix.js --------
/*
Copyright (c) 2003-2008 Terence Parr. All rights reserved.
Code licensed under the BSD License:
http://www.antlr.org/license.html
Some parts of the ANTLR class:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
*/
/*
Some portions:
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.5.1
*/
// create org.antlr module
if (typeof org == "undefined" || !org) {
var org = {};
}
if (typeof org.antlr == "undefined" || !org.antlr) {
/**
* The org.antlr global namespace object.  If antlr is already defined, the
* existing antlr object will not be overwritten so that defined
* namespaces are preserved.
* @namespace org.antlr
*/
org.antlr = {};
}
// JRWG: Also org.antlr.runtime seems needed
if (typeof org.antlr.runtime == "undefined" || !org.antlr.runtime) {
org.antlr.runtime = {};
}
// JRWG: Also org.antlr.runtime.tree seems needed
if (typeof org.antlr.runtime.tree == "undefined" || !org.antlr.runtime.tree) {
org.antlr.runtime.tree = {};
}
// JRWG: End
/**
* The global JavaScript object.
*/
org.antlr.global = (function() {
return this;
}).call(null);
/**
* Returns the namespace specified and creates it if it doesn't exist.
*
* Be careful when naming packages. Reserved words may work in some browsers
* and not others. For instance, the following will fail in Safari:
* <pre>
* org.antlr.namespace("really.long.nested.namespace");
* </pre>
* This fails because "long" is a future reserved word in ECMAScript
*
* @static
* @param  {String*} arguments 1-n namespaces to create 
* @return {Object}  A reference to the last namespace object created
* @example
* org.antlr.namespace("org.antlr.property.package");
*/
org.antlr.namespace = function() {
var a=arguments, o=null, i, j, d;
for (i=0; i<a.length; i=i+1) {
d=a[i].split(".");
o=org.antlr.global;
// ANTLR is implied, so it is ignored if it is included
for (j=0; j<d.length; j=j+1) {
o[d[j]]=o[d[j]] || {};
o=o[d[j]];
}
}
return o;
};
/**
* org.antlr.env is used to keep track of what is known about the library and
* the browsing environment
* @namespace org.antlr.env
*/
org.antlr.env = org.antlr.env || {};
/**
* Do not fork for a browser if it can be avoided.  Use feature detection when
* you can.  Use the user agent as a last resort.  org.antlr.env.ua stores a
* version number for the browser engine, 0 otherwise.  This value may or may
* not map to the version number of the browser using the engine.  The value is 
* presented as a float so that it can easily be used for boolean evaluation 
* as well as for looking for a particular range of versions.  Because of this, 
* some of the granularity of the version info may be lost (e.g., Gecko 1.8.0.9 
* reports 1.8).
* @namespace org.antlr.env.ua
*/
org.antlr.env.ua = function() {
var o= /** @lends org.antlr.env.ua */ {
/**
* Internet Explorer version number or 0.  Example: 6
* @property ie
* @type float
*/
ie:0,
/**
* Opera version number or 0.  Example: 9.2
* @property opera
* @type float
*/
opera:0,
/**
* Gecko engine revision number.  Will evaluate to 1 if Gecko 
* is detected but the revision could not be found. Other browsers
* will be 0.  Example: 1.8
* <pre>
* Firefox 1.0.0.4: 1.7.8   <-- Reports 1.7
* Firefox 1.5.0.9: 1.8.0.9 <-- Reports 1.8
* Firefox 2.0.0.3: 1.8.1.3 <-- Reports 1.8
* Firefox 3 alpha: 1.9a4   <-- Reports 1.9
* </pre>
* @property gecko
* @type float
*/
gecko:0,
/**
* AppleWebKit version.  KHTML browsers that are not WebKit browsers 
* will evaluate to 1, other browsers 0.  Example: 418.9.1
* <pre>
* Safari 1.3.2 (312.6): 312.8.1 <-- Reports 312.8 -- currently the 
*                                   latest available for Mac OSX 10.3.
* Safari 2.0.2:         416     <-- hasOwnProperty introduced
* Safari 2.0.4:         418     <-- preventDefault fixed
* Safari 2.0.4 (419.3): 418.9.1 <-- One version of Safari may run
*                                   different versions of webkit
* Safari 2.0.4 (419.3): 419     <-- Tiger installations that have been
*                                   updated, but not updated
*                                   to the latest patch.
* Webkit 212 nightly:   522+    <-- Safari 3.0 precursor (with native SVG
*                                   and many major issues fixed).  
* 3.x yahoo.com, flickr:422     <-- Safari 3.x hacks the user agent
*                                   string when hitting yahoo.com and 
*                                   flickr.com.
* Safari 3.0.4 (523.12):523.12  <-- First Tiger release - automatic update
*                                   from 2.x via the 10.4.11 OS patch
* Webkit nightly 1/2008:525+    <-- Supports DOMContentLoaded event.
*                                   yahoo.com user agent hack removed.
*                                   
* </pre>
* http://developer.apple.com/internet/safari/uamatrix.html
* @property webkit
* @type float
*/
webkit: 0,
/**
* The mobile property will be set to a string containing any relevant
* user agent information when a modern mobile browser is detected.
* Currently limited to Safari on the iPhone/iPod Touch, Nokia N-series
* devices with the WebKit-based browser, and Opera Mini.  
* @property mobile 
* @type string
*/
mobile: null,
/**
* Adobe AIR version number or 0.  Only populated if webkit is detected.
* Example: 1.0
* @property air
* @type float
*/
air: 0,
/**
* Is this the Rhino interpreter?
* @property rhino
* @type Boolean
*/
rhino: false
};
var ua, m;
try {
ua = navigator.userAgent;
// Modern KHTML browsers should qualify as Safari X-Grade
if ((/KHTML/).test(ua)) {
o.webkit=1;
}
// Modern WebKit browsers are at least X-Grade
m=ua.match(/AppleWebKit\/([^\s]*)/);
if (m&&m[1]) {
o.webkit=parseFloat(m[1]);
// Mobile browser check
if (/ Mobile\//.test(ua)) {
o.mobile = "Apple"; // iPhone or iPod Touch
} else {
m=ua.match(/NokiaN[^\/]*/);
if (m) {
o.mobile = m[0]; // Nokia N-series, ex: NokiaN95
}
}
m=ua.match(/AdobeAIR\/([^\s]*)/);
if (m) {
o.air = m[0]; // Adobe AIR 1.0 or better
}
}
if (!o.webkit) { // not webkit
// @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
m=ua.match(/Opera[\s\/]([^\s]*)/);
if (m&&m[1]) {
o.opera=parseFloat(m[1]);
m=ua.match(/Opera Mini[^;]*/);
if (m) {
o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
}
} else { // not opera or webkit
m=ua.match(/MSIE\s([^;]*)/);
if (m&&m[1]) {
o.ie=parseFloat(m[1]);
} else { // not opera, webkit, or ie
m=ua.match(/Gecko\/([^\s]*)/);
if (m) {
o.gecko=1; // Gecko detected, look for revision
m=ua.match(/rv:([^\s\)]*)/);
if (m&&m[1]) {
o.gecko=parseFloat(m[1]);
}
}
}
}
}
} catch(e) {
// ignore this if we're not in a browser
}
try {
if (typeof window=="undefined" && loadClass) {
o.rhino = true;
}
} catch(e) {}
return o;
}();
/**
* JavaScript runtime library code.
* @name org.antlr.runtime
* @namespace
*/
/**
* JavaScript runtime library tree parser code.
* @name org.antlr.runtime.tree
* @namespace
*/
org.antlr.namespace("org.antlr.runtime.tree");
/**
* Provides the language utilites and extensions used by the library
* @namespace org.antlr.lang
*/
org.antlr.lang = org.antlr.lang || /** @lends org.antlr.lang */ {
/**
* Determines whether or not the provided object is an array.
* Testing typeof/instanceof/constructor of arrays across frame 
* boundaries isn't possible in Safari unless you have a reference
* to the other frame to test against its Array prototype.  To
* handle this case, we test well-known array properties instead.
* properties.
* @param {any} o The object being testing
* @return {boolean} the result
*/
isArray: function(o) { 
if (o) {
var l = org.antlr.lang;
return l.isNumber(o.length) && l.isFunction(o.splice);
}
return false;
},
/**
* Determines whether or not the provided object is a boolean
* @param {any} o The object being testing
* @return {boolean} the result
*/
isBoolean: function(o) {
return typeof o === 'boolean';
},
/**
* Determines whether or not the provided object is a function
* @param {any} o The object being testing
* @return {boolean} the result
*/
isFunction: function(o) {
return typeof o === 'function';
},
/**
* Determines whether or not the provided object is null
* @param {any} o The object being testing
* @return {boolean} the result
*/
isNull: function(o) {
return o === null;
},
/**
* Determines whether or not the provided object is a legal number
* @param {any} o The object being testing
* @return {boolean} the result
*/
isNumber: function(o) {
return typeof o === 'number' && isFinite(o);
},
/**
* Determines whether or not the provided object is of type object
* or function
* @param {any} o The object being testing
* @return {boolean} the result
*/  
isObject: function(o) {
return (o && (typeof o === 'object' || org.antlr.lang.isFunction(o))) || false;
},
/**
* Determines whether or not the provided object is a string
* @param {any} o The object being testing
* @return {boolean} the result
*/
isString: function(o) {
return typeof o === 'string';
},
/**
* Determines whether or not the provided object is undefined
* @param {any} o The object being testing
* @return {boolean} the result
*/
isUndefined: function(o) {
return typeof o === 'undefined';
},
/**
* IE will not enumerate native functions in a derived object even if the
* function was overridden.  This is a workaround for specific functions 
* we care about on the Object prototype. 
* @param {Function} r  the object to receive the augmentation
* @param {Function} s  the object that supplies the properties to augment
* @private
*/
_IEEnumFix: function(r, s) {
if (org.antlr.env.ua.ie) {
var add=["toString", "valueOf"], i;
for (i=0;i<add.length;i=i+1) {
var fname=add[i],f=s[fname];
if (org.antlr.lang.isFunction(f) && f!=Object.prototype[fname]) {
r[fname]=f;
}
}
}
},
/**
* Utility to set up the prototype, constructor and superclass properties to
* support an inheritance strategy that can chain constructors and methods.
* Static members will not be inherited.
*
* @method extend
* @static
* @param {Function} subc   the object to modify
* @param {Function} superc the object to inherit
* @param {Object} [overrides]  additional properties/methods to add to the
*                              subclass prototype.  These will override the
*                              matching items obtained from the superclass 
*                              if present.
*/
extend: function(subc, superc, overrides) {
if (!superc||!subc) {
throw new Error("org.antlr.lang.extend failed, please check that " +
"all dependencies are included.");
}
var F = function() {};
F.prototype=superc.prototype;
subc.prototype=new F();
subc.prototype.constructor=subc;
subc.superclass=superc.prototype;
if (superc.prototype.constructor == Object.prototype.constructor) {
superc.prototype.constructor=superc;
}
if (overrides) {
for (var i in overrides) {
subc.prototype[i]=overrides[i];
}
org.antlr.lang._IEEnumFix(subc.prototype, overrides);
}
},
/**
* Applies all properties in the supplier to the receiver if the
* receiver does not have these properties yet.  Optionally, one or 
* more methods/properties can be specified (as additional 
* parameters).  This option will overwrite the property if receiver 
* has it already.  If true is passed as the third parameter, all 
* properties will be applied and _will_ overwrite properties in 
* the receiver.
*
* @param {Function} r  the object to receive the augmentation
* @param {Function} s  the object that supplies the properties to augment
* @param {String*|boolean}  [arguments] zero or more properties methods 
*        to augment the receiver with.  If none specified, everything
*        in the supplier will be used unless it would
*        overwrite an existing property in the receiver. If true
*        is specified as the third parameter, all properties will
*        be applied and will overwrite an existing property in
*        the receiver
*/
augmentObject: function(r, s) {
if (!s||!r) {
throw new Error("Absorb failed, verify dependencies.");
}
var a=arguments, i, p, override=a[2];
if (override && override!==true) { // only absorb the specified properties
for (i=2; i<a.length; i=i+1) {
r[a[i]] = s[a[i]];
}
} else { // take everything, overwriting only if the third parameter is true
for (p in s) { 
if (override || !r[p]) {
r[p] = s[p];
}
}
org.antlr.lang._IEEnumFix(r, s);
}
},
/**
* Same as org.antlr.lang.augmentObject, except it only applies prototype properties
* @see org.antlr.lang.augmentObject
* @param {Function} r  the object to receive the augmentation
* @param {Function} s  the object that supplies the properties to augment
* @param {String*|boolean}  [arguments] zero or more properties methods 
*        to augment the receiver with.  If none specified, everything 
*        in the supplier will be used unless it would overwrite an existing 
*        property in the receiver.  if true is specified as the third 
*        parameter, all properties will be applied and will overwrite an 
*        existing property in the receiver
*/
augmentProto: function(r, s) {
if (!s||!r) {
throw new Error("Augment failed, verify dependencies.");
}
//var a=[].concat(arguments);
var a=[r.prototype,s.prototype];
for (var i=2;i<arguments.length;i=i+1) {
a.push(arguments[i]);
}
org.antlr.lang.augmentObject.apply(this, a);
},
/**
* Returns a new object containing all of the properties of
* all the supplied objects.  The properties from later objects
* will overwrite those in earlier objects.
* @param arguments {Object*} the objects to merge
* @return the new merged object
*/
merge: function() {
var o={}, a=arguments;
for (var i=0, l=a.length; i<l; i=i+1) {
org.antlr.lang.augmentObject(o, a[i], true);
}
return o;
},
/**
* A convenience method for detecting a legitimate non-null value.
* Returns false for null/undefined/NaN, true for other values, 
* including 0/false/''
* @param o {any} the item to test
* @return {boolean} true if it is not null/undefined/NaN || false
*/
isValue: function(o) {
var l = org.antlr.lang;
return (l.isObject(o) || l.isString(o) || l.isNumber(o) || l.isBoolean(o));
},
/** @namespace org.antlr.lang.array Array convenience methods. */
array: /** @lends org.antlr.lang.array */ {
/**
* Retrieve the last element of an array. Throws an error if a is not
* an array or empty.
* @param a {Array} the array stack to peek in
* @return the last element of the array
*/
peek: function(a) {
if (!org.antlr.lang.isArray(a)) {
throw new Error("org.antlr.lang.array.peek: a is not an array.");
}
var l = a.length;
if (l<=0) {
throw new Error("org.antlr.lang.array.peek: a is empty.");
}
return a[l-1];
}
}
};
/** The set of fields needed by an abstract recognizer to recognize input
*  and recover from errors etc...  As a separate state object, it can be
*  shared among multiple grammars; e.g., when one grammar imports another.
*
*  These fields are publically visible but the actual state pointer per
*  parser is protected.
*/
org.antlr.runtime.RecognizerSharedState = function() {
/** Track the set of token types that can follow any rule invocation.
*  Stack grows upwards.  When it hits the max, it grows 2x in size
*  and keeps going.
*/
this.following = [];
this._fsp = -1;
/** This is true when we see an error and before having successfully
*  matched a token.  Prevents generation of more than one error message
*  per error.
*/
this.errorRecovery = false;
/** The index into the input stream where the last error occurred.
*  This is used to prevent infinite loops where an error is found
*  but no token is consumed during recovery...another error is found,
*  ad naseum.  This is a failsafe mechanism to guarantee that at least
*  one token/tree node is consumed for two errors.
*/
this.lastErrorIndex = -1;
/** In lieu of a return value, this indicates that a rule or token
*  has failed to match.  Reset to false upon valid token match.
*/
this.failed = false;
/** Did the recognizer encounter a syntax error?  Track how many. */
this.syntaxErrors = 0;
/** If 0, no backtracking is going on.  Safe to exec actions etc...
*  If >0 then it's the level of backtracking.
*/
this.backtracking = 0;
/** An array[size num rules] of Map<Integer,Integer> that tracks
*  the stop token index for each rule.  ruleMemo[ruleIndex] is
*  the memoization table for ruleIndex.  For key ruleStartIndex, you
*  get back the stop token for associated rule or MEMO_RULE_FAILED.
*
*  This is only used if rule memoization is on (which it is by default).
*/
this.ruleMemo = null;
// LEXER FIELDS (must be in same state object to avoid casting
//               constantly in generated code and Lexer object) :(
/** The goal of all lexer rules/methods is to create a token object.
*  This is an instance variable as multiple rules may collaborate to
*  create a single token.  nextToken will return this object after
*  matching lexer rule(s).  If you subclass to allow multiple token
*  emissions, then set this to the last token to be matched or
*  something nonnull so that the auto token emit mechanism will not
*  emit another token.
*/
this.token = null;
/** What character index in the stream did the current token start at?
*  Needed, for example, to get the text for current token.  Set at
*  the start of nextToken.
*/
this.tokenStartCharIndex = -1;
/** The line on which the first character of the token resides */
// this.tokenStartLine;
/** The character position of first character within the line */
// this.tokenStartCharPositionInLine;
/** The channel number for the current token */
// this.channel;
/** The token type for the current token */
// this.type;
/** You can set the text for the current token to override what is in
*  the input char buffer.  Use setText() or can set this instance var.
*/
this.text = null;
};
org.antlr.runtime.IndexOutOfBoundsException = function(m) {
org.antlr.runtime.IndexOutOfBoundsException.superclass.constructor.call(this, m);
};
org.antlr.lang.extend(org.antlr.runtime.IndexOutOfBoundsException, Error, {
name: "org.antlr.runtime.IndexOutOfBoundsException"
});
/** The root of the ANTLR exception hierarchy.
*
*  <p>To avoid English-only error messages and to generally make things
*  as flexible as possible, these exceptions are not created with strings,
*  but rather the information necessary to generate an error.  Then
*  the various reporting methods in Parser and Lexer can be overridden
*  to generate a localized error message.  For example, MismatchedToken
*  exceptions are built with the expected token type.
*  So, don't expect getMessage() to return anything.</p>
*
*  <p>ANTLR generates code that throws exceptions upon recognition error and
*  also generates code to catch these exceptions in each rule.  If you
*  want to quit upon first error, you can turn off the automatic error
*  handling mechanism using rulecatch action, but you still need to
*  override methods mismatch and recoverFromMismatchSet.</p>
*
*  <p>In general, the recognition exceptions can track where in a grammar a
*  problem occurred and/or what was the expected input.  While the parser
*  knows its state (such as current input symbol and line info) that
*  state can change before the exception is reported so current token index
*  is computed and stored at exception time.  From this info, you can
*  perhaps print an entire line of input not just a single token, for example.
*  Better to just say the recognizer had a problem and then let the parser
*  figure out a fancy report.</p>
*
*  @class
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*  @extends Error
*
*/
org.antlr.runtime.RecognitionException = function(input) {
org.antlr.runtime.RecognitionException.superclass.constructor.call(this);
this.input = input;
this.index = input.index();
if ( input instanceof org.antlr.runtime.CommonTokenStream ) {
this.token = input.LT(1);
this.line = this.token.getLine();
this.charPositionInLine = this.token.getCharPositionInLine();
}
if ( input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
this.extractInformationFromTreeNodeStream(input);
}
else if ( input instanceof org.antlr.runtime.ANTLRStringStream ) {
// Note: removed CharStream from hierarchy in JS port so checking for
// StringStream instead
this.c = input.LA(1);
this.line = input.getLine();
this.charPositionInLine = input.getCharPositionInLine();
}
else {
this.c = input.LA(1);
}
this.message = this.toString();
};
org.antlr.lang.extend(org.antlr.runtime.RecognitionException, Error,
/** @lends org.antlr.runtime.RecognitionException.prototype */
{
/**
* What input stream did the error occur in?
*/
input: null,
/** What is index of token/char were we looking at when the error occurred?
*  @type Number
*/
index: null,
/** The current Token when an error occurred.  Since not all streams
*  can retrieve the ith Token, we have to track the Token object.
*  For parsers.  Even when it's a tree parser, token might be set.
*  @type org.antlr.runtime.CommonToken
*/
token: null,
/** If this is a tree parser exception, node is set to the node with
*  the problem.
*  @type Object
*/
node: null,
/** The current char when an error occurred. For lexers.
*  @type Number
*/
c: null,
/** Track the line at which the error occurred in case this is
*  generated from a lexer.  We need to track this since the
*  unexpected char doesn't carry the line info.
*  @type Number
*/
line: null,
/** The exception's class name.
*  @type String
*/
name: "org.antlr.runtime.RecognitionException",
/** Position in the line where exception occurred.
*  @type Number
*/
charPositionInLine: null,
/** If you are parsing a tree node stream, you will encounter som
*  imaginary nodes w/o line/col info.  We now search backwards looking
*  for most recent token with line/col info, but notify getErrorHeader()
*  that info is approximate.
*  @type Boolean
*/
approximateLineInfo: null,
/** Gather exception information from input stream.
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*/
extractInformationFromTreeNodeStream: function(input) {
var nodes = input,
priorNode,
priorPayLoad,
type,
text,
i;
this.node = nodes.LT(1);
var adaptor = nodes.getTreeAdaptor(),
payload = adaptor.getToken(this.node);
if ( payload ) {
this.token = payload;
if ( payload.getLine()<= 0 ) {
// imaginary node; no line/pos info; scan backwards
i = -1;
priorNode = nodes.LT(i);
while ( priorNode ) {
priorPayload = adaptor.getToken(priorNode);
if ( priorPayload && priorPayload.getLine()>0 ) {
// we found the most recent real line / pos info
this.line = priorPayload.getLine();
this.charPositionInLine = priorPayload.getCharPositionInLine();
this.approximateLineInfo = true;
break;
}
--i;
priorNode = nodes.LT(i);
}
}
else { // node created from real token
this.line = payload.getLine();
this.charPositionInLine = payload.getCharPositionInLine();
}
}
else if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
this.line = this.node.getLine();
this.charPositionInLine = this.node.getCharPositionInLine();
if ( this.node instanceof org.antlr.runtime.tree.CommonTree) {
this.token = this.node.token;
}
}
else {
type = adaptor.getType(this.node);
text = adaptor.getText(this.node);
this.token = new org.antlr.runtime.CommonToken(type, text);
}
},
/** Return the token type or char of the unexpected input element
*  @return {Number} type of the unexpected input element.
*/
getUnexpectedType: function() {
if ( this.input instanceof org.antlr.runtime.CommonTokenStream ) {
return this.token.getType();
}
else if ( this.input instanceof org.antlr.runtime.tree.TreeNodeStream ) {
var nodes = this.input;
var adaptor = nodes.getTreeAdaptor();
return adaptor.getType(this.node);
}
else {
return this.c;
}
}
});
org.antlr.runtime.MismatchedTokenException = function(expecting, input) {
if (arguments.length===0) {
this.expecting = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
} else {
org.antlr.runtime.MismatchedTokenException.superclass.constructor.call(
this, input);
this.expecting = expecting;
}
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedTokenException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedTokenException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedTokenException"
});
/** An extra token while parsing a TokenStream */
org.antlr.runtime.UnwantedTokenException = function(expecting, input) {
if (arguments.length>0) {
org.antlr.runtime.UnwantedTokenException.superclass.constructor.call(
this, expecting, input);
}
};
org.antlr.lang.extend(
org.antlr.runtime.UnwantedTokenException,
org.antlr.runtime.MismatchedTokenException, {
getUnexpectedToken: function() {
return this.token;
},
toString: function() {
var exp = ", expected "+this.expecting;
if ( this.expecting===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
exp = "";
}
if ( !org.antlr.lang.isValue(this.token) ) {
return "UnwantedTokenException(found="+exp+")";
}
return "UnwantedTokenException(found="+this.token.getText()+exp+")";
},
name: "org.antlr.runtime.UnwantedTokenException"
});
org.antlr.runtime.MissingTokenException = function(expecting, input, inserted) {
if (arguments.length>0) {
org.antlr.runtime.MissingTokenException.superclass.constructor.call(
this, expecting, input);
this.inserted = inserted;
}
};
org.antlr.lang.extend(
org.antlr.runtime.MissingTokenException,
org.antlr.runtime.MismatchedTokenException, {
getMissingType: function() {
return this.expecting;
},
toString: function() {
if (org.antlr.lang.isValue(this.inserted) &&
org.antlr.lang.isValue(this.token))
{
return "MissingTokenException(inserted "+this.inserted+" at "+this.token.getText()+")";
}
if ( org.antlr.lang.isValue(this.token) ) {
return "MissingTokenException(at "+this.token.getText()+")";
}
return "MissingTokenException";
},
name: "org.antlr.runtime.MissingTokenException"
});
org.antlr.runtime.NoViableAltException = function(grammarDecisionDescription,
decisionNumber,
stateNumber,
input)
{
org.antlr.runtime.NoViableAltException.superclass.constructor.call(this, input);
this.grammarDecisionDescription = grammarDecisionDescription;
this.decisionNumber = decisionNumber;
this.stateNumber = stateNumber;
};
org.antlr.lang.extend(
org.antlr.runtime.NoViableAltException,
org.antlr.runtime.RecognitionException, {
toString: function() {
if ( this.input instanceof org.antlr.runtime.ANTLRStringStream ) {
return "NoViableAltException('"+this.getUnexpectedType()+"'@["+this.grammarDecisionDescription+"])";
}
else {
return "NoViableAltException("+this.getUnexpectedType()+"@["+this.grammarDecisionDescription+"])";
}
},
name: "org.antlr.runtime.NoViableAltException"
});
/** The recognizer did not match anything for a ()+ loop.
*
*  @class
*  @param {Number} decisionNumber
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*  @extends org.antlr.runtime.RecognitionException
*/
org.antlr.runtime.EarlyExitException = function(decisionNumber, input) {
org.antlr.runtime.EarlyExitException.superclass.constructor.call(
this, input);
this.decisionNumber = decisionNumber;
};
org.antlr.lang.extend(
org.antlr.runtime.EarlyExitException,
org.antlr.runtime.RecognitionException,
/** @lends org.antlr.runtime.EarlyExitException.prototype */
{
/** Name of this class.
*  @type String
*/
name: "org.antlr.runtime.EarlyExitException"
});
org.antlr.runtime.MismatchedSetException = function(expecting, input) {
org.antlr.runtime.MismatchedSetException.superclass.constructor.call(
this, input);
this.expecting = expecting;
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedSetException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedSetException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedSetException"
});
org.antlr.runtime.MismatchedNotSetException = function(expecting, input) {
org.antlr.runtime.MismatchedNotSetException.superclass.constructor.call(this, expecting, input);
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedNotSetException,
org.antlr.runtime.MismatchedSetException, {
toString: function() {
return "MismatchedNotSetException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedNotSetException"
});
org.antlr.runtime.MismatchedRangeException = function(a, b, input) {
if (arguments.length===0) {
return this;
}
org.antlr.runtime.MismatchedRangeException.superclass.constructor.call(
this, input);
this.a = a;
this.b = b;
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedRangeException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedRangeException(" +
this.getUnexpectedType()+" not in ["+this.a+","+this.b+"])";
},
name: "org.antlr.runtime.MismatchedRangeException"
});
/** A semantic predicate failed during validation.  Validation of predicates
*  occurs when normally parsing the alternative just like matching a token.
*  Disambiguating predicate evaluation occurs when we hoist a predicate into
*  a prediction decision.
*
*  @class
*  @param {org.antlr.runtime.CommonTokenStream|org.antlr.runtime.tree.TreeNodeStream|org.antlr.runtime.ANTLRStringStream} input input stream that has an exception.
*  @param {String} ruleName name of the rule in which the exception occurred.
*  @param {String} predicateText the predicate that failed.
*  @extends org.antlr.runtime.RecognitionException
*/
org.antlr.runtime.FailedPredicateException = function(input, ruleName, predicateText){
org.antlr.runtime.FailedPredicateException.superclass.constructor.call(this, input);
this.ruleName = ruleName;
this.predicateText = predicateText;
};
org.antlr.lang.extend(
org.antlr.runtime.FailedPredicateException,
org.antlr.runtime.RecognitionException,
/** @lends org.antlr.runtime.FailedPredicateException.prototype */
{
/** Create a string representation of this exception.
*  @returns {String}
*/ 
toString: function() {
return "FailedPredicateException("+this.ruleName+",{"+this.predicateText+"}?)";
},
/** Name of this class.
*  @type String
*/
name: "org.antlr.runtime.FailedPredicateException"
});
/**
* A BitSet similar to java.util.BitSet.
*
* <p>JavaScript Note: There is no good way to implement something like this in 
* JavaScript.  JS has no true int type, arrays are usually implemented as
* hashes, etc.  This class should probably be nixed for something that is
* similarly (in)efficient, but more clear.</p>
*
* @class
* @param {Number|Array} [bits] a 32 bit number or array of 32 bit numbers
*                              representing the bitset.  These are typically
*                              generated by the ANTLR Tool.
*/
org.antlr.runtime.BitSet = function(bits) {
if (!bits) {
bits = org.antlr.runtime.BitSet.BITS;
}
if (org.antlr.lang.isArray(bits)) {
/**
* An array of Numbers representing the BitSet.
* @type Array
*/
this.bits = bits;
} else if(org.antlr.lang.isNumber(bits)) {
this.bits = [];
}
};
org.antlr.lang.augmentObject(org.antlr.runtime.BitSet, {
/**
* Number of bits in each number.
* @constant
* @memberOf org.antlr.runtime.BitSet
*/
BITS: 32,
/**
* Log (base 2) of the number of bits in each number.
* @constant
* @memberOf org.antlr.runtime.BitSet
*/
LOG_BITS: 5,  // 2^5 == 32 
/**
* We will often need to do a mod operator (i mod nbits).  Its
* turns out that, for powers of two, this mod operation is
* same as (i & (nbits-1)).  Since mod is slow, we use a
* precomputed mod mask to do the mod instead.
* @constant
* @memberOf org.antlr.runtime.BitSet
*/
MOD_MASK: 31, // BITS - 1
/**
* Create mask for bit modded to fit in a single word.
* @example
* bitmask(35) => 00000000000000000000000000000100
* bitmask(3)  => 00000000000000000000000000000100
* @param {Number} bitNumber the bit to create a mask for.
* @returns {Number} the bitmask.
* @memberOf org.antlr.runtime.BitSet
* @private
*/
bitMask: function(bitNumber) {
var bitPosition = bitNumber & org.antlr.runtime.BitSet.MOD_MASK;
return 1 << bitPosition;
},
/**
* Calculate the minimum number of bits needed to represent el.
* @param {Number} el a number to be included in the BitSet.
* @returns {Number} the number of bits need to create a BitSet with member
*                   el.
* @memberOf org.antlr.runtime.BitSet
* @private
*/
numWordsToHold: function(el) {
return (el >> org.antlr.runtime.BitSet.LOG_BITS) + 1;
},
/**
* @param {Number} bit a number to be included in the BitSet
* @returns {Number} the index of the word in the field bits that would
*                   hold bit.
* @memberOf org.antlr.runtime.BitSet
* @private
*/
wordNumber: function(bit) {
return bit >> org.antlr.runtime.BitSet.LOG_BITS; // bit / BITS
},
/**
* BitSet factory method.
* 
* <p>Operates in a number of modes:
* <ul>
* <li>If el is a number create the BitSet containing that number.</li>
* <li>If el is an array create the BitSet containing each number in the
* array.</li>
* <li>If el is a BitSet return el.</li>
* <li>If el is an Object create the BitSet containing each numeric value
* in el.</li>
* <li>If el is a number and el2 is a number return a BitSet containing
* the numbers between el and el2 (inclusive).</li>
* </ul>
* </p>
* @param {Number|Array|org.antlr.runtime.BitSet|Object} el
* @param {Number} el2
* @returns {org.antlr.runtime.BitSet}
* @memberOf org.antlr.runtime.BitSet
*/
of: function(el, el2) {
var i, n, s, keys;
if (org.antlr.lang.isNumber(el)) {
if (org.antlr.lang.isNumber(el2)) {
s = new org.antlr.runtime.BitSet(el2 + 1);
for (i = el; i <= el2; i++) {
n = org.antlr.runtime.BitSet.wordNumber(i);
s.bits[n] |= org.antlr.runtime.BitSet.bitMask(i);
}
return s;
} else {
s = new org.antlr.runtime.BitSet(el + 1);
s.add(el);
return s;
}
} else if(org.antlr.lang.isArray(el)) {
s = new org.antlr.runtime.BitSet();
for (i=el.length-1; i>=0; i--) {
s.add(el[i]);
}
return s;
} else if (el instanceof org.antlr.runtime.BitSet) {
if (!el) {
return null;
}
return el;
} else if (el instanceof org.antlr.runtime.IntervalSet) {
if (!el) {
return null;
}
s = new org.antlr.runtime.BitSet();
s.addAll(el);
return s;
} else if (org.antlr.lang.isObject(el)) {
keys = [];
for (i in el) {
if (org.antlr.lang.isNumber(i)) {
keys.push(i);
}
}
return org.antlr.runtime.BitSet.of(keys);
}
}
});
org.antlr.runtime.BitSet.prototype = {
/**
* Add el into this set.
* @param {Number} el the number to add to the set.
*/
add: function(el) {
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) {
this.growToInclude(el);
}
this.bits[n] |= org.antlr.runtime.BitSet.bitMask(el);
},
/**
* Add multiple elements into this set.
* @param {Array|org.antlr.runtime.BitSet} elements the elements to be added to
*                                           this set.
*/
addAll: function(elements) {
var other,
i,
e;
if ( elements instanceof org.antlr.runtime.BitSet ) {
this.orInPlace(elements);
}
else if ( elements instanceof org.antlr.runtime.IntervalSet ) {
other = elements;
// walk set and add each interval
/* @todo after implementing intervalset
for (Iterator iter = other.intervals.iterator(); iter.hasNext();) {
Interval I = (Interval) iter.next();
this.orInPlace(BitSet.range(I.a,I.b));
}*/
} else if (org.antlr.lang.isArray(elements)) {
for (i = 0; i < elements.length; i++) {
e = elements[i];
this.add(e);
}
} else {
return;
}
},
/**
* Clone this BitSet and then {@link #andInPlace} with a.
* @param {org.antlr.runtime.BitSet} a a bit set.
* @returns {org.antlr.runtime.BitSet}
*/
and: function(a) {
var s = this.clone();
s.andInPlace(a);
return s;
},
/**
* Perform a logical AND of this target BitSet with the argument BitSet.
*
* This bit set is modified so that each bit in it has the value true if 
* and only if it both initially had the value true and the corresponding 
* bit in the bit set argument also had the value true. 
* @param {org.antlr.runtime.BitSet} a a bit set.
* @returns {org.antlr.runtime.BitSet}
*/
andInPlace: function(a) {
var min = Math.min(this.bits.length, a.bits.length),
i;
for (i = min - 1; i >= 0; i--) {
this.bits[i] &= a.bits[i];
}
// clear all bits in this not present in a (if this bigger than a).
for (i = min; i < this.bits.length; i++) {
this.bits[i] = 0;
}
},
/**
* Clear all bits or a specific bit.
*
* If no arguments given, sets all of the bits in this BitSet to false.
* If one argument given, sets the bit specified by the index to false.
* @param {Number} [el] the index of the bit to be cleared.
*/
clear: function(el) {
if (arguments.length===0) {
var i;
for (i = this.bits.length - 1; i >= 0; i--) {
this.bits[i] = 0;
}
return;
}
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) {	// grow as necessary to accommodate
this.growToInclude(el);
}
this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
},
/**
* Cloning this BitSet produces a new BitSet  that is equal to it. 
*
* The clone of the bit set is another bit set that has exactly the same
* bit set to true as this bit set. 
* @returns {org.antlr.runtime.BitSet} a clone of this BitSet.
*/
clone: function() {
var i, len, b=[];
for (i=0, len=this.bits.length; i<len; i++) {
b[i] = this.bits[i];
}
return new org.antlr.runtime.BitSet(b);
},
/**
* Returns the number of bits of space actually in use by this BitSet to 
* represent bit values.
*
* The maximum element in the set is the size - 1st element. 
* @returns {Number} the number of bits currently in this bit set.
*/
size: function() {
var deg = 0, i, word, bit;
for (i = this.bits.length - 1; i >= 0; i--) {
word = this.bits[i];
if (word !== 0) {
for (bit = org.antlr.runtime.BitSet.BITS - 1; bit >= 0; bit--) {
if ((word & (1 << bit)) !== 0) {
deg++;
}
}
}
}
return deg;
},
/**
* Compares this object against the specified object.
*
* The result is true if and only if the argument is not null and is a
* BitSet object that has exactly the same set of bits set to true as
* this bit set. That is, for every nonnegative int index k,
* <pre><code>
* ((BitSet)obj).get(k) == this.get(k)
* </code></pre>
* must be true. The current sizes of the two bit sets are not compared.
* @param {Object} other the object to compare with.
* @returns {Boolean} if the objects are the same; false otherwise.
*/
equals: function(other) {
if ( !other || !(other instanceof org.antlr.runtime.BitSet) ) {
return false;
}
var otherSet = other,
i,
n = Math.min(this.bits.length, otherSet.bits.length);
// for any bits in common, compare
for (i=0; i<n; i++) {
if (this.bits[i] != otherSet.bits[i]) {
return false;
}
}
// make sure any extra bits are off
if (this.bits.length > n) {
for (i = n+1; i<this.bits.length; i++) {
if (this.bits[i] !== 0) {
return false;
}
}
}
else if (otherSet.bits.length > n) {
for (i = n+1; i<otherSet.bits.length; i++) {
if (otherSet.bits[i] !== 0) {
return false;
}
}
}
return true;
},
/**
* Grows the set to a larger number of bits.
* @param {Number} bit element that must fit in set
* @private
*/
growToInclude: function(bit) {
var newSize = Math.max(this.bits.length << 1, org.antlr.runtime.BitSet.numWordsToHold(bit)),
newbits = [], //new Array(newSize),
i;
for (i=0, len=this.bits.length; i<len; i++) {
newbits[i] = this.bits[i];
}
this.bits = newbits;
},
/**
* Returns the value of the bit with the specified index.
*
* The value is true if the bit with the index el is currently set 
* in this BitSet; otherwise, the result is false.
* @param {Number} el the bit index.
* @returns {Boolean} the value of the bit with the specified index.
*/
member: function(el) {
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) { return false; }
return (this.bits[n] & org.antlr.runtime.BitSet.bitMask(el)) !== 0;
},
/**
* Returns the index of the first bit that is set to true.
* If no such bit exists then -1 is returned.
* @returns {Number} the index of the next set bit.
*/
getSingleElement: function() {
var i;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
return i;
}
}
return -1; //Label.INVALID;
},
/**
* Returns true if this BitSet contains no bits that are set to true.
* @returns {Boolean} boolean indicating whether this BitSet is empty.
*/
isNil: function() {
var i;
for (i = this.bits.length - 1; i >= 0; i--) {
if (this.bits[i] !== 0) {
return false;
}
}
return true;
},
/**
* If a bit set argument is passed performs a {@link #subtract} of this bit
* set with the argument bit set.  If no argument is passed, clone this bit
* set and {@link #notInPlace}.
* @param {org.antlr.runtime.BitSet} [set]
* @returns {org.antlr.runtime.BitSet}
*/
complement: function(set) {
if (set) {
return set.subtract(this);
} else {
var s = this.clone();
s.notInPlace();
return s;
}
},
/**
* If no arguments are passed sets all bits to the complement of their
* current values.  If one argument is passed sets each bit from the
* beginning of the bit set to index1 (inclusive) to the complement of its
* current value.  If two arguments are passed sets each bit from the
* specified index1 (inclusive) to the sepcified index2 (inclusive) to the
* complement of its current value.
* @param {Number} index1
* @param {Number} index2
*/
notInPlace: function() {
var minBit, maxBit, i, n;
if (arguments.length===0) {
for (i = this.bits.length - 1; i >= 0; i--) {
this.bits[i] = ~this.bits[i];
}
} else {
if (arguments.length===1) {
minBit = 0;
maxBit = arguments[0];
} else {
minBit = arguments[0];
maxBit = arguments[1];
}
// make sure that we have room for maxBit
this.growToInclude(maxBit);
for (i = minBit; i <= maxBit; i++) {
n = org.antlr.runtime.BitSet.wordNumber(i);
this.bits[n] ^= org.antlr.runtime.BitSet.bitMask(i);
}
}
},
/**
* Performs a logical OR of this bit set with the bit set argument.
* If no argument is passed, return this bit set.  Otherwise a clone of
* this bit set is modified so that a bit in it has the value true if and
* only if it either already had the value true or the corresponding bit
* in the bit set argument has the value true.
* @param {org.antlr.runtime.BitSet} [a] a bit set.
* @returns {org.antlr.runtime.BitSet}
*/
or: function(a) {
if ( !a ) {
return this;
}
var s = this.clone();
s.orInPlace(a);
return s;
},
/**
* Performs a logical {@link #or} in place.
* @param {org.antlr.runtime.BitSet} [a]
* @returns {org.antlr.runtime.BitSet}
*/
orInPlace: function(a) {
if ( !a ) {
return;
}
// If this is smaller than a, grow this first
if (a.bits.length > this.bits.length) {
this.setSize(a.bits.length);
}
var min = Math.min(this.bits.length, a.bits.length),
i;
for (i = min - 1; i >= 0; i--) {
this.bits[i] |= a.bits[i];
}
},
/**
* Sets the bit specified by the index to false.
* @param {Number} bitIndex the index of the bit to be cleared.
*/
remove: function(el) {
var n = org.antlr.runtime.BitSet.wordNumber(el);
if (n >= this.bits.length) {
this.growToInclude(el);
}
this.bits[n] &= ~org.antlr.runtime.BitSet.bitMask(el);
},
/**
* Grows the internal bits array to include at least nwords numbers.
* @private
* @param {Number} nwords how many words the new set should be
* @private
*/
setSize: function(nwords) {
var n = nwords - this.bits.length;
while (n>=0) {
this.bits.push(0);
n--;
}
},
/**
* Returns the number of bits capable of being represented by this bit set
* given its current size.
* @returns {Number} the maximum number of bits that can be represented at
*                   the moment.
* @private
*/
numBits: function() {
return this.bits.length << org.antlr.runtime.BitSet.LOG_BITS; // num words * bits per word
},
/**
* Return how much space is being used by the bits array not
* how many actually have member bits on.
* @returns {Number} the length of the internal bits array.
* @private
*/
lengthInLongWords: function() {
return this.bits.length;
},
/**
* Is this bit set contained within a?
* @param {org.antlr.runtime.BitSet} a bit set
* @returns {Boolean} true if and only if a is a subset of this bit set.
*/
subset: function(a) {
if (!a) { return false; }
return this.and(a).equals(this);
},
/**
* Subtract the elements of the argument bit set from this bit set in place.
* That is, for each set bit in the argument bit set, set the corresponding
* bit in this bit set to false.
* @param {org.antlr.runtime.BitSet} a bit set.
*/
subtractInPlace: function(a) {
if (!a) { return; }
// for all words of 'a', turn off corresponding bits of 'this'
var i;
for (i = 0; i < this.bits.length && i < a.bits.length; i++) {
this.bits[i] &= ~a.bits[i];
}
},
/**
* Perform a {@link #subtractInPlace} on a clone of this bit set.
* @param {org.antlr.runtime.BitSet} a bit set.
* @returns {org.antlr.runtime.BitSet} the new bit set.
*/
subtract: function(a) {
if (!a || !(a instanceof org.antlr.runtime.BitSet)) { return null; }
var s = this.clone();
s.subtractInPlace(a);
return s;
},
/* antlr-java needs this to make its class hierarchy happy . . .
toList: function() {
throw new Error("BitSet.toList() unimplemented");
},
*/
/**
* Creates an array of the indexes of each bit set in this bit set.
* @returns {Array}
*/
toArray: function() {
var elems = [], //new Array(this.size()),
i,
en = 0;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
elems[en++] = i;
}
}
return elems;
},
/**
* Returns the internal representation of this bit set.
* This representation is an array of numbers, each representing 32 bits.
* @returns {Array}
*/
toPackedArray: function() {
return this.bits;
},
/**
* Returns a string representation of this bit set.
* <p>For every index for which this BitSet contains a bit in the set state,
* the decimal representation of that index is included in the result.
* Such indices are listed in order from lowest to highest, separated by
* ", " (a comma and a space) and surrounded by braces, resulting in the
* usual mathematical notation for a set of integers.</p>
* 
* <p>If a grammar g is passed, print g.getTokenDisplayName(i) for each set
* index instead of the numerical index.</p>
*
* <>If two arguments are passed, the first will be used as a custom
* separator string.  The second argument is an array whose i-th element
* will be added if the corresponding bit is set.</p>
*
* @param {Object|String} [arg1] an Object with function property
*      getTokenDispalyName or a String that will be used as a list
*      separator.
* @param {Array} [vocabulary] array from which the i-th value will be
*      drawn if the corresponding bit is set.  Must pass a string as the
*      first argument if using this option.
* @return A commma-separated list of values
*/
toString: function() {
if (arguments.length===0) {
return this.toString1(null);
} else {
if (org.antlr.lang.isString(arguments[0])) {
if (!org.antlr.lang.isValue(arguments[1])) {
return this.toString1(null);
} else {
return this.toString2(arguments[0], arguments[1]);
}
} else {
return this.toString1(arguments[0]);
}
}
},
/**
* Transform a bit set into a string by formatting each element as an
* integer separator The string to put in between elements
* @private
* @return A commma-separated list of values
*/
toString1: function(g) {
var buf = "{",
separator = ",",
i,
havePrintedAnElement = false;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
if (i > 0 && havePrintedAnElement ) {
buf += separator;
}
if ( g ) {
buf += g.getTokenDisplayName(i);
}
else {
buf += i.toString();
}
havePrintedAnElement = true;
}
}
return buf + "}";
},
/**
* Create a string representation where instead of integer elements, the
* ith element of vocabulary is displayed instead.  Vocabulary is a Vector
* of Strings.
* separator The string to put in between elements
* @private
* @return A commma-separated list of character constants.
*/
toString2: function(separator, vocabulary) {
var str = "",
i;
for (i = 0; i < (this.bits.length << org.antlr.runtime.BitSet.LOG_BITS); i++) {
if (this.member(i)) {
if (str.length > 0) {
str += separator;
}
if (i >= vocabulary.size()) {
str += "'" + i + "'";
}
else if (!org.antlr.lang.isValue(vocabulary.get(i))) {
str += "'" + i + "'";
}
else {
str += vocabulary.get(i);
}
}
}
return str;
}
/*
* Dump a comma-separated list of the words making up the bit set.
* Split each 32 bit number into two more manageable 16 bit numbers.
* @returns {String} comma separated list view of the this.bits property.
*
toStringOfHalfWords: function() {
var s = "",
tmp,
i;
for (i = 0; i < this.bits.length; i++) {
if (i !== 0) {
s+=", ";
}
tmp = this.bits[i];
tmp &= 0xFFFF;
s += tmp + "UL, ";
tmp = this.bits[i] >> 16;
tmp &= 0xFFFF;
s += tmp+"UL";
}
return s;
},
*/
/*
* Dump a comma-separated list of the words making up the bit set.
* This generates a comma-separated list of Java-like long int constants.
*
toStringOfWords: function() {
var s="",
i;
for (i = 0; i < this.bits.length; i++) {
if (i !== 0) {
s+=", ";
}
s += this.bits[i]+"L";
}
return s;
},
toStringWithRanges: function() {
return this.toString();
}
*/
};
/*
*
*
org.antlr.runtime.IntervalSet = function() {
throw new Error("not implemented");
};
*/
org.antlr.runtime.CharStream = {
EOF: -1
};
org.antlr.runtime.CommonToken = function() {
var oldToken;
this.charPositionInLine = -1; // set to invalid position
this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
this.index = -1;
if (arguments.length == 1) {
if (org.antlr.lang.isNumber(arguments[0])) {
this.type = arguments[0];
} else {
oldToken = arguments[0];
this.text = oldToken.getText();
this.type = oldToken.getType();
this.line = oldToken.getLine();
this.index = oldToken.getTokenIndex();
this.charPositionInLine = oldToken.getCharPositionInLine();
this.channel = oldToken.getChannel();
if ( oldToken instanceof org.antlr.runtime.CommonToken ) {
this.start = oldToken.start;
this.stop = oldToken.stop;
}
}
} else if (arguments.length == 2) {
this.type = arguments[0];
this.text = arguments[1];
this.channel = 0; // org.antlr.runtime.CommonToken.DEFAULT_CHANNEL
} else if (arguments.length == 5) {
this.input = arguments[0];
this.type = arguments[1];
this.channel = arguments[2];
this.start = arguments[3];
this.stop = arguments[4];
}
};
org.antlr.runtime.CommonToken.prototype = {
getType: function() {
return this.type;
},
setLine: function(line) {
this.line = line;
},
getText: function() {
if ( org.antlr.lang.isString(this.text) ) {
return this.text;
}
if ( !this.input ) {
return null;
}
this.text = this.input.substring(this.start,this.stop);
return this.text;
},
/** Override the text for this token.  getText() will return this text
*  rather than pulling from the buffer.  Note that this does not mean
*  that start/stop indexes are not valid.  It means that that input
*  was converted to a new string in the token object.
*/
setText: function(text) {
this.text = text;
},
getLine: function() {
return this.line;
},
getCharPositionInLine: function() {
return this.charPositionInLine;
},
setCharPositionInLine: function(charPositionInLine) {
this.charPositionInLine = charPositionInLine;
},
getChannel: function() {
return this.channel;
},
setChannel: function(channel) {
this.channel = channel;
},
setType: function(type) {
this.type = type;
},
getStartIndex: function() {
return this.start;
},
setStartIndex: function(start) {
this.start = start;
},
getStopIndex: function() {
return this.stop;
},
setStopIndex: function(stop) {
this.stop = stop;
},
getTokenIndex: function() {
return this.index;
},
setTokenIndex: function(index) {
this.index = index;
},
getInputStream: function() {
return this.input;
},
setInputStream: function(input) {
this.input = input;
},
toString: function() {
var channelStr = "";
if ( this.channel>0 ) {
channelStr=",channel="+this.channel;
}
var txt = this.getText();
if ( !org.antlr.lang.isNull(txt) ) {
txt = txt.replace(/\n/g,"\\\\n");
txt = txt.replace(/\r/g,"\\\\r");
txt = txt.replace(/\t/g,"\\\\t");
}
else {
txt = "<no text>";
}
return "[@"+this.getTokenIndex()+","+this.start+":"+this.stop+"='"+txt+"',<"+this.type+">"+channelStr+","+this.line+":"+this.getCharPositionInLine()+"]";
}
};
// NB: Because Token has static members of type CommonToken, the Token dummy
// constructor is defined in CommonToken.  All methods and vars of Token are
// defined here.  Token is an interface, not a subclass in the Java runtime.
/**
* @class Abstract base class of all token types.
* @name Token
* @memberOf org.antlr.runtime
*/
org.antlr.runtime.Token = function() {};
org.antlr.lang.augmentObject(org.antlr.runtime.Token, /** @lends Token */ {
EOR_TOKEN_TYPE: 1,
/** imaginary tree navigation type; traverse "get child" link */
DOWN: 2,
/** imaginary tree navigation type; finish with a child list */
UP: 3,
MIN_TOKEN_TYPE: 4, // UP+1,
EOF: org.antlr.runtime.CharStream.EOF,
EOF_TOKEN: new org.antlr.runtime.CommonToken(org.antlr.runtime.CharStream.EOF),
INVALID_TOKEN_TYPE: 0,
INVALID_TOKEN: new org.antlr.runtime.CommonToken(0),
/** In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
*  will avoid creating a token for this symbol and try to fetch another.
*/
SKIP_TOKEN: new org.antlr.runtime.CommonToken(0),
/** All tokens go to the parser (unless skip() is called in that rule)
*  on a particular "channel".  The parser tunes to a particular channel
*  so that whitespace etc... can go to the parser on a "hidden" channel.
*/
DEFAULT_CHANNEL: 0,
/** Anything on different channel than DEFAULT_CHANNEL is not parsed
*  by parser.
*/
HIDDEN_CHANNEL: 99
});
org.antlr.lang.augmentObject(org.antlr.runtime.CommonToken, org.antlr.runtime.Token);
org.antlr.runtime.tree.RewriteCardinalityException = function(elementDescription) {
this.elementDescription = elementDescription;
};
/** Base class for all exceptions thrown during AST rewrite construction.
*  This signifies a case where the cardinality of two or more elements
*  in a subrule are different: (ID INT)+ where |ID|!=|INT|
*/
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteCardinalityException, Error, {
getMessage: function() {
if ( org.antlr.lang.isString(this.elementDescription) ) {
return this.elementDescription;
}
return null;
},
name: function() {
return "org.antlr.runtime.tree.RewriteCardinalityException";
}
});
/** Ref to ID or expr but no tokens in ID stream or subtrees in expr stream */
org.antlr.runtime.tree.RewriteEmptyStreamException = function(elementDescription) {
var sup = org.antlr.runtime.tree.RewriteEmptyStreamException.superclass; 
sup.constructor.call(this, elementDescription);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEmptyStreamException,
org.antlr.runtime.tree.RewriteCardinalityException, {
name: function() {
return "org.antlr.runtime.tree.RewriteEmptyStreamException";
}
});
/** No elements within a (...)+ in a rewrite rule */
org.antlr.runtime.tree.RewriteEarlyExitException = function(elementDescription) {
var sup = org.antlr.runtime.tree.RewriteEarlyExitException.superclass;
if (org.antlr.lang.isUndefined(elementDescription)) {
elementDescription = null;
}
sup.constructor.call(this, elementDescription);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteEarlyExitException,
org.antlr.runtime.tree.RewriteCardinalityException, {
name: function() {
return "org.antlr.runtime.tree.RewriteEarlyExitException";
}    
});
org.antlr.runtime.MismatchedTreeNodeException = function(expecting, input) {
if (expecting && input) {
org.antlr.runtime.MismatchedTreeNodeException.superclass.constructor.call(
this, input);
this.expecting = expecting;
}
};
org.antlr.lang.extend(
org.antlr.runtime.MismatchedTreeNodeException,
org.antlr.runtime.RecognitionException, {
toString: function() {
return "MismatchedTreeNodeException(" +
this.getUnexpectedType() + "!=" + this.expecting + ")";
},
name: "org.antlr.runtime.MismatchedTreeNodeException"
});
/** A generic tree implementation with no payload.  You must subclass to
*  actually have any user data.  ANTLR v3 uses a list of children approach
*  instead of the child-sibling approach in v2.  A flat tree (a list) is
*  an empty node whose children represent the list.  An empty, but
*  non-null node is called "nil".
*/
org.antlr.runtime.tree.BaseTree = function() {};
org.antlr.runtime.tree.BaseTree.prototype = {
getChild: function(i) {
if ( !this.children || i>=this.children.length ) {
return null;
}
return this.children[i];
},
/** Get the children internal List; note that if you directly mess with
*  the list, do so at your own risk.
*/
getChildren: function() {
return this.children;
},
getFirstChildWithType: function(type) {
var i, t;
for (i = 0; this.children && i < this.children.length; i++) {
t = this.children[i];
if ( t.getType()===type ) {
return t;
}
}    
return null;
},
getChildCount: function() {
if ( !this.children ) {
return 0;
}
return this.children.length;
},
/** Add t as child of this node.
*
*  Warning: if t has no children, but child does
*  and child isNil then this routine moves children to t via
*  t.children = child.children; i.e., without copying the array.
*/
addChild: function(t) {
if ( !org.antlr.lang.isValue(t) ) {
return; // do nothing upon addChild(null)
}
var childTree = t, n, i, c;
if ( childTree.isNil() ) { // t is an empty node possibly with children
if ( this.children && this.children == childTree.children ) {
throw new Error("attempt to add child list to itself");
}
// just add all of childTree's children to this
if ( childTree.children ) {
if ( this.children ) { // must copy, this has children already
n = childTree.children.length;
for (i = 0; i < n; i++) {
c = childTree.children[i];
this.children.push(c);
// handle double-link stuff for each child of nil root
c.setParent(this);
c.setChildIndex(this.children.length-1);
}
}
else {
// no children for this but t has children; just set pointer
// call general freshener routine
this.children = childTree.children;
this.freshenParentAndChildIndexes();
}
}
}
else { // child is not nil (don't care about children)
if ( !this.children ) {
this.children = this.createChildrenList(); // create children list on demand
}
this.children.push(t);
childTree.setParent(this);
childTree.setChildIndex(this.children.length-1);
}
},
/** Add all elements of kids list as children of this node */
addChildren: function(kids) {
var i, t;
for (i = 0; i < kids.length; i++) {
t = kids[i];
this.addChild(t);
}
},
setChild: function(i, t) {
if ( !t ) {
return;
}
if ( t.isNil() ) {
throw new Error("Can't set single child to a list");
}
if ( !this.children ) {
this.children = this.createChildrenList();
}
this.children[i] = t;
t.setParent(this);
t.setChildIndex(i);
},
deleteChild: function(i) {
if ( !this.children ) {
return null;
}
if (i<0 || i>=this.children.length) {
throw new Error("Index out of bounds.");
}
var killed = this.children.splice(i, 1)[0];
// walk rest and decrement their child indexes
this.freshenParentAndChildIndexes(i);
return killed;
},
/** Delete children from start to stop and replace with t even if t is
*  a list (nil-root tree).  num of children can increase or decrease.
*  For huge child lists, inserting children can force walking rest of
*  children to set their childindex; could be slow.
*/
replaceChildren: function(startChildIndex, stopChildIndex, t) {
if ( !this.children ) {
throw new Error("indexes invalid; no children in list");
}
var replacingHowMany = stopChildIndex - startChildIndex + 1;
var replacingWithHowMany;
var newTree = t;
var newChildren = null;
// normalize to a list of children to add: newChildren
if ( newTree.isNil() ) {
newChildren = newTree.children;
}
else {
newChildren = [];
newChildren.push(newTree);
}
replacingWithHowMany = newChildren.length;
var numNewChildren = newChildren.length;
var delta = replacingHowMany - replacingWithHowMany;
var j, i, child, indexToDelete, c, killed, numToInsert;
// if same number of nodes, do direct replace
if ( delta === 0 ) {
j = 0; // index into new children
for (i=startChildIndex; i<=stopChildIndex; i++) {
child = newChildren[j];
this.children[i] = child;
child.setParent(this);
child.setChildIndex(i);
j++;
}
}
else if ( delta > 0 ) { // fewer new nodes than there were
// set children and then delete extra
for (j=0; j<numNewChildren; j++) {
this.children[startChildIndex+j] = newChildren[j];
}
indexToDelete = startChildIndex+numNewChildren;
for (c=indexToDelete; c<=stopChildIndex; c++) {
// delete same index, shifting everybody down each time
killed = this.children.splice(indexToDelete, 1)[0];
}
this.freshenParentAndChildIndexes(startChildIndex);
}
else { // more new nodes than were there before
// fill in as many children as we can (replacingHowMany) w/o moving data
for (j=0; j<replacingHowMany; j++) {
this.children[startChildIndex+j] = newChildren[j];
}
numToInsert = replacingWithHowMany-replacingHowMany;
for (j=replacingHowMany; j<replacingWithHowMany; j++) {
this.children.splice(startChildIndex+j, 0, newChildren[j]);
}
this.freshenParentAndChildIndexes(startChildIndex);
}
},
/** Override in a subclass to change the impl of children list */
createChildrenList: function() {
return [];
},
isNil: function() {
return false;
},
freshenParentAndChildIndexes: function(offset) {
if (!org.antlr.lang.isNumber(offset)) {
offset = 0;
}
var n = this.getChildCount(),
c,
child;
for (c = offset; c < n; c++) {
child = this.getChild(c);
child.setChildIndex(c);
child.setParent(this);
}
},
sanityCheckParentAndChildIndexes: function(parent, i) {
if (arguments.length===0) {
parent = null;
i = -1;
}
if ( parent!==this.getParent() ) {
throw new Error("parents don't match; expected "+parent+" found "+this.getParent());
}
if ( i!==this.getChildIndex() ) {
throw new Error("child indexes don't match; expected "+i+" found "+this.getChildIndex());
}
var n = this.getChildCount(),
c,
child;
for (c = 0; c < n; c++) {
child = this.getChild(c);
child.sanityCheckParentAndChildIndexes(this, c);
}
},
/** BaseTree doesn't track child indexes. */
getChildIndex: function() {
return 0;
},
setChildIndex: function(index) {
},
/** BaseTree doesn't track parent pointers. */
getParent: function() {
return null;
},
setParent: function(t) {
},
getTree: function() {
return this;
},
/** Print out a whole tree not just a node */
toStringTree: function() {
if ( !this.children || this.children.length===0 ) {
return this.toString();
}
var buf = "",
i,
t;
if ( !this.isNil() ) {
buf += "(";
buf += this.toString();
buf += ' ';
}
for (i = 0; this.children && i < this.children.length; i++) {
t = this.children[i];
if ( i>0 ) {
buf += ' ';
}
buf += t.toStringTree();
}
if ( !this.isNil() ) {
buf += ")";
}
return buf;
},
getLine: function() {
return 0;
},
getCharPositionInLine: function() {
return 0;
}
};
/** A tree node that is wrapper for a Token object.  After 3.0 release
*  while building tree rewrite stuff, it became clear that computing
*  parent and child index is very difficult and cumbersome.  Better to
*  spend the space in every tree node.  If you don't want these extra
*  fields, it's easy to cut them out in your own BaseTree subclass.
*/
org.antlr.runtime.tree.CommonTree = function(node) {
/** What token indexes bracket all tokens associated with this node
*  and below?
*/
this.startIndex = -1;
this.stopIndex = -1;
/** What index is this node in the child list? Range: 0..n-1 */
this.childIndex = -1;
/** Who is the parent node of this node; if null, implies node is root */
this.parent = null;
/** A single token is the payload */
this.token = null;
if (node instanceof org.antlr.runtime.tree.CommonTree) {
org.antlr.runtime.tree.CommonTree.superclass.constructor.call(this, node);
this.token = node.token;
this.startIndex = node.startIndex;
this.stopIndex = node.stopIndex;
} else if (node instanceof org.antlr.runtime.CommonToken) {
this.token = node;
}
};
/** A tree node that is wrapper for a Token object. */
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTree, org.antlr.runtime.tree.BaseTree, {
getToken: function() {
return this.token;
},
dupNode: function() {
return new org.antlr.runtime.tree.CommonTree(this);
},
isNil: function() {
return !this.token;
},
getType: function() {
if ( !this.token ) {
return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
}
return this.token.getType();
},
getText: function() {
if ( !this.token ) {
return null;
}
return this.token.getText();
},
getLine: function() {
if ( !this.token || this.token.getLine()===0 ) {
if ( this.getChildCount()>0 ) {
return this.getChild(0).getLine();
}
return 0;
}
return this.token.getLine();
},
getCharPositionInLine: function() {
if ( !this.token || this.token.getCharPositionInLine()===-1 ) {
if ( this.getChildCount()>0 ) {
return this.getChild(0).getCharPositionInLine();
}
return 0;
}
return this.token.getCharPositionInLine();
},
getTokenStartIndex: function() {
if ( this.token ) {
return this.token.getTokenIndex();
}
return this.startIndex;
},
setTokenStartIndex: function(index) {
this.startIndex = index;
},
getTokenStopIndex: function() {
if ( this.token ) {
return this.token.getTokenIndex();
}
return this.stopIndex;
},
setTokenStopIndex: function(index) {
this.stopIndex = index;
},
getChildIndex: function() {
return this.childIndex;
},
getParent: function() {
return this.parent;
},
setParent: function(t) {
this.parent = t;
},
setChildIndex: function(index) {
this.childIndex = index;
},
toString: function() {
if ( this.isNil() ) {
return "nil";
}
if ( this.getType()===org.antlr.runtime.Token.INVALID_TOKEN_TYPE ) {
return "<errornode>";
}
if ( !this.token ) {
return null;
}
return this.token.getText();
}
});
/** What does a tree look like?  ANTLR has a number of support classes
*  such as CommonTreeNodeStream that work on these kinds of trees.  You
*  don't have to make your trees implement this interface, but if you do,
*  you'll be able to use more support code.
*
*  NOTE: When constructing trees, ANTLR can build any kind of tree; it can
*  even use Token objects as trees if you add a child list to your tokens.
*
*  This is a tree node without any payload; just navigation and factory stuff.
*/
org.antlr.runtime.tree.Tree = {
INVALID_NODE: new org.antlr.runtime.tree.CommonTree(org.antlr.runtime.Token.INVALID_TOKEN)
};
org.antlr.runtime.tree.CommonErrorNode = function(input, start, stop, e) {
if ( !stop ||
(stop.getTokenIndex() < start.getTokenIndex() &&
stop.getType()!=org.antlr.runtime.Token.EOF) )
{
// sometimes resync does not consume a token (when LT(1) is
// in follow set.  So, stop will be 1 to left to start. adjust.
// Also handle case where start is the first token and no token
// is consumed during recovery; LT(-1) will return null.
stop = start;
}
this.input = input;
this.start = start;
this.stop = stop;
this.trappedException = e;
};
org.antlr.lang.extend(org.antlr.runtime.tree.CommonErrorNode, org.antlr.runtime.tree.CommonTree, {
isNil: function() {
return false;
},
getType: function() {
return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
},
getText: function() {
var badText = null;
if ( this.start instanceof org.antlr.runtime.CommonToken ) {
var i = this.start.getTokenIndex();
var j = this.stop.getTokenIndex();
if ( this.stop.getType() === org.antlr.runtime.Token.EOF ) {
j = this.input.size();
}
badText = this.input.toString(i, j);
}
else if ( this.start instanceof org.antlr.runtime.tree.CommonTree ) {
badText = this.input.toString(this.start, this.stop);
}
else {
// people should subclass if they alter the tree type so this
// next one is for sure correct.
badText = "<unknown>";
}
return badText;
},
toString: function() {
if ( this.trappedException instanceof org.antlr.runtime.MissingTokenException ) {
return "<missing type: "+
this.trappedException.getMissingType()+
">";
}
else if ( this.trappedException instanceof org.antlr.runtime.UnwantedTokenException ) {
return "<extraneous: "+
this.trappedException.getUnexpectedToken()+
", resync="+this.getText()+">";
}
else if ( this.trappedException instanceof org.antlr.runtime.MismatchedTokenException ) {
return "<mismatched token: "+this.trappedException.token+", resync="+this.getText()+">";
}
else if ( this.trappedException instanceof org.antlr.runtime.NoViableAltException ) {
return "<unexpected: "+this.trappedException.token+
", resync="+this.getText()+">";
}
return "<error: "+this.getText()+">";
}
});
/** A TreeAdaptor that works with any Tree implementation. */
org.antlr.runtime.tree.BaseTreeAdaptor = function() {
this.uniqueNodeID = 1;
};
org.antlr.runtime.tree.BaseTreeAdaptor.prototype = {
nil: function() {
return this.create(null);
},
/** create tree node that holds the start and stop tokens associated
*  with an error.
*
*  If you specify your own kind of tree nodes, you will likely have to
*  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
*  if no token payload but you might have to set token type for diff
*  node type.
*/
errorNode: function(input, start, stop, e) {
var t = new org.antlr.runtime.tree.CommonErrorNode(input, start, stop, e);
return t;
},
isNil: function(tree) {
return tree.isNil();
},
/** This is generic in the sense that it will work with any kind of
*  tree (not just Tree interface).  It invokes the adaptor routines
*  not the tree node routines to do the construction.  
*/
dupTree: function(t, parent) {
if (arguments.length===1) {
parent = null;
}
if ( !t ) {
return null;
}
var newTree = this.dupNode(t);
// ensure new subtree root has parent/child index set
this.setChildIndex(newTree, this.getChildIndex(t)); // same index in new tree
this.setParent(newTree, parent);
var n = this.getChildCount(t),
i, child, newSubTree;
for (i = 0; i < n; i++) {
child = this.getChild(t, i);
newSubTree = this.dupTree(child, t);
this.addChild(newTree, newSubTree);
}
return newTree;
},
/** Add a child to the tree t.  If child is a flat tree (a list), make all
*  in list children of t.  Warning: if t has no children, but child does
*  and child isNil then you can decide it is ok to move children to t via
*  t.children = child.children; i.e., without copying the array.  Just
*  make sure that this is consistent with have the user will build
*  ASTs.
*/
addChild: function(t, child) {
if ( t && org.antlr.lang.isValue(child) ) {
t.addChild(child);
}
},
/** If oldRoot is a nil root, just copy or move the children to newRoot.
*  If not a nil root, make oldRoot a child of newRoot.
*
*    old=^(nil a b c), new=r yields ^(r a b c)
*    old=^(a b c), new=r yields ^(r ^(a b c))
*
*  If newRoot is a nil-rooted single child tree, use the single
*  child as the new root node.
*
*    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
*    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
*
*  If oldRoot was null, it's ok, just return newRoot (even if isNil).
*
*    old=null, new=r yields r
*    old=null, new=^(nil r) yields ^(nil r)
*
*  Return newRoot.  Throw an exception if newRoot is not a
*  simple node or nil root with a single child node--it must be a root
*  node.  If newRoot is ^(nil x) return x as newRoot.
*
*  Be advised that it's ok for newRoot to point at oldRoot's
*  children; i.e., you don't have to copy the list.  We are
*  constructing these nodes so we should have this control for
*  efficiency.
*/
becomeRoot: function(newRoot, oldRoot) {
if (newRoot instanceof org.antlr.runtime.CommonToken || !newRoot) {
newRoot = this.create(newRoot);
}
var newRootTree = newRoot,
oldRootTree = oldRoot;
if ( !oldRoot ) {
return newRoot;
}
// handle ^(nil real-node)
if ( newRootTree.isNil() ) {
if ( newRootTree.getChildCount()>1 ) {
// TODO: make tree run time exceptions hierarchy
throw new Error("more than one node as root (TODO: make exception hierarchy)");
}
newRootTree = newRootTree.getChild(0);
}
// add oldRoot to newRoot; addChild takes care of case where oldRoot
// is a flat list (i.e., nil-rooted tree).  All children of oldRoot
// are added to newRoot.
newRootTree.addChild(oldRootTree);
return newRootTree;
},
/** Transform ^(nil x) to x */
rulePostProcessing: function(root) {
var r = root;
if ( r && r.isNil() ) {
if ( r.getChildCount()===0 ) {
r = null;
}
else if ( r.getChildCount()===1 ) {
r = r.getChild(0);
// whoever invokes rule will set parent and child index
r.setParent(null);
r.setChildIndex(-1);
}
}
return r;
},
create: function(tokenType, fromToken) {
var text, t;
if (arguments.length===2) {
if (org.antlr.lang.isString(arguments[1])) {
text = arguments[1];
fromToken = this.createToken(tokenType, text);
t = this.create(fromToken);
return t;
} else {
fromToken = this.createToken(fromToken);
fromToken.setType(tokenType);
t = this.create(fromToken);
return t;
}
} else if (arguments.length===3) {
text = arguments[2];
fromToken = this.createToken(fromToken);
fromToken.setType(tokenType);
fromToken.setText(text);
t = this.create(fromToken);
return t;
}
},
getType: function(t) {
t.getType();
return 0;
},
setType: function(t, type) {
throw new Error("don't know enough about Tree node");
},
getText: function(t) {
return t.getText();
},
setText: function(t, text) {
throw new Error("don't know enough about Tree node");
},
getChild: function(t, i) {
return t.getChild(i);
},
setChild: function(t, i, child) {
t.setChild(i, child);
},
deleteChild: function(t, i) {
return t.deleteChild(i);
},
getChildCount: function(t) {
return t.getChildCount();
},
getUniqueID: function(node) {
if ( !this.treeToUniqueIDMap ) {
this.treeToUniqueIDMap = {};
}
var prevID = this.treeToUniqueIDMap[node];
if ( org.antlr.lang.isValue(prevID) ) {
return prevID;
}
var ID = this.uniqueNodeID;
this.treeToUniqueIDMap[node] = ID;
this.uniqueNodeID++;
return ID;
// GC makes these nonunique:
// return System.identityHashCode(node);
}
};
/** A TreeAdaptor that works with any Tree implementation.  It provides
*  really just factory methods; all the work is done by BaseTreeAdaptor.
*  If you would like to have different tokens created than ClassicToken
*  objects, you need to override this and then set the parser tree adaptor to
*  use your subclass.
*
*  To get your parser to build nodes of a different type, override
*  create(Token).
*/
org.antlr.runtime.tree.CommonTreeAdaptor = function() {};
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeAdaptor,
org.antlr.runtime.tree.BaseTreeAdaptor, {
/** Duplicate a node.  This is part of the factory;
*    override if you want another kind of node to be built.
*
*  I could use reflection to prevent having to override this
*  but reflection is slow.
*/
dupNode: function(t) {
if ( !org.antlr.lang.isValue(t) ) {
return null;
}
return t.dupNode();
},
create: function(payload) {
if (arguments.length>1) {
return org.antlr.runtime.tree.CommonTreeAdaptor.superclass.create.apply(this, arguments);
}
return new org.antlr.runtime.tree.CommonTree(payload);
},
/** Tell me how to create a token for use with imaginary token nodes.
*  For example, there is probably no input symbol associated with imaginary
*  token DECL, but you need to create it as a payload or whatever for
*  the DECL node as in ^(DECL type ID).
*
*  If you care what the token payload objects' type is, you should
*  override this method and any other createToken variant.
*
* Tell me how to create a token for use with imaginary token nodes.
*  For example, there is probably no input symbol associated with imaginary
*  token DECL, but you need to create it as a payload or whatever for
*  the DECL node as in ^(DECL type ID).
*
*  This is a variant of createToken where the new token is derived from
*  an actual real input token.  Typically this is for converting '{'
*  tokens to BLOCK etc...  You'll see
*
*    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
*
*  If you care what the token payload objects' type is, you should
*  override this method and any other createToken variant.
*/
createToken: function(fromToken) {
if (arguments.length===2) {
return new org.antlr.runtime.CommonToken(arguments[0], arguments[1]);
} else {
return new org.antlr.runtime.CommonToken(arguments[0]);
}
},
/** Track start/stop token for subtree root created for a rule.
*  Only works with Tree nodes.  For rules that match nothing,
*  seems like this will yield start=i and stop=i-1 in a nil node.
*  Might be useful info so I'll not force to be i..i.
*/
setTokenBoundaries: function(t, startToken, stopToken) {
if ( !org.antlr.lang.isValue(t) ) {
return;
}
var start = 0,
stop = 0;
if ( org.antlr.lang.isValue(startToken) ) {
if (startToken.getTokenIndex) {
start = startToken.getTokenIndex();
} else if (startToken.getStartIndex) {
start = startToken.getStartIndex();
} else {
start = startToken.getTokenStartIndex();
}
}
if ( org.antlr.lang.isValue(stopToken) ) {
if (stop.getTokenIndex) {
stop = stopToken.getTokenIndex();
} else if (stopToken.getStopIndex) {
stop = stopToken.getStopIndex();
} else {
stop = stopToken.getTokenStopIndex();
}
}
t.setTokenStartIndex(start);
t.setTokenStopIndex(stop);
},
getTokenStartIndex: function(t) {
if (!t) {
return -1;
}
return t.getTokenStartIndex();
},
getTokenStopIndex: function(t) {
if (!t) {
return -1;
}
return t.getTokenStopIndex();
},
getText: function(t) {
if (!t) {
return null;
}
return t.getText();
},
getType: function(t) {
if (!t) {
return org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
}
return t.getType();
},
/** What is the Token associated with this node?  If
*  you are not using CommonTree, then you must
*  override this in your own adaptor.
*/
getToken: function(t) {
if ( t instanceof org.antlr.runtime.tree.CommonTree ) {
return t.getToken();
}
return null; // no idea what to do
},
getChild: function(t, i) {
if (!t) {
return null;
}
return t.getChild(i);
},
getChildCount: function(t) {
if (!t) {
return 0;
}
return t.getChildCount();
},
getParent: function(t) {
return t.getParent();
},
setParent: function(t, parent) {
t.setParent(parent);
},
getChildIndex: function(t) {
return t.getChildIndex();
},
setChildIndex: function(t, index) {
t.setChildIndex(index);
},
replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
if ( parent ) {
parent.replaceChildren(startChildIndex, stopChildIndex, t);
}
}
});
/**
* A stream of characters created from a JavaScript string that in turn gets
* fed to a lexer.
* @class
* @param {String} data the string from which this stream will be created.
*/
org.antlr.runtime.ANTLRStringStream = function(data) {
/**
* Location in the stream.
* Ranges from 0 to (stream length - 1).
* @private
* @type Number
*/
this.p = 0;
/**
* The current line in the input.
* Ranges from 1 to (number of lines).
* @private
* @type Number
*/
this.line = 1;
/**
* The index of the character relative to the beginning of the line.
* Ranges from 0 to (length of line - 1).
* @private
* @type Number
*/
this.charPositionInLine = 0;
/**
* Tracks how deep mark() calls are nested
* @private
* @type Number
*/
this.markDepth = 0;
/**
* An Array of objects that tracks the stream state
* values line, charPositionInLine, and p that can change as you
* move through the input stream.  Indexed from 1..markDepth.
* A null is kept at index 0.  Created upon first call to mark().
* @private
* @type Array
*/
this.markers = null;
/**
* Track the last mark() call result value for use in rewind().
* @private
* @type Number
*/
this.lastMarker = null;
/**
* The data being scanned.
* @private
* @type String
*/
this.data = data;
/**
* The number of characters in the stream.
* @private
* @type Number
*/
this.n = data.length;
};
org.antlr.runtime.ANTLRStringStream.prototype = {
/**
* Reset the stream so that it's in the same state it was
* when the object was created *except* the data array is not
* touched.
*/
reset: function() {
this.p = 0;
this.line = 1;
this.charPositionInLine = 0;
this.markDepth = 0;
},
/**
* Consume the next character of data in the stream.
*/
consume: function() {
if ( this.p < this.n ) {
this.charPositionInLine++;
if ( this.data.charAt(this.p)==="\n" ) {
this.line++;
this.charPositionInLine=0;
}
this.p++;
}
},
/**
* Get character at current input pointer + i ahead where i=1 is next int.
* Negative indexes are allowed.  LA(-1) is previous token (token
* just matched).  LA(-i) where i is before first token should
* yield -1, invalid char / EOF.
* @param {Number} i non-zero amount of lookahead or lookback
* @returns {String|Number} The charcter at the specified position or -1 if
*      you fell off either end of the stream.
*/
LA: function(i) {
if ( i<0 ) {
i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
}
var new_pos = this.p+i-1;
if (new_pos>=this.n || new_pos<0) {
return org.antlr.runtime.CharStream.EOF;
}
return this.data.charAt(new_pos);
},
/**
* Return the current input symbol index 0..n where n indicates the
* last symbol has been read.  The index is the index of char to
* be returned from LA(1) (i.e. the one about to be consumed).
* @returns {Number} the index of the current input symbol
*/
index: function() {
return this.p;
},
/**
* The length of this stream.
* @returns {Number} the length of this stream.
*/
size: function() {
return this.n;
},
/**
* Tell the stream to start buffering if it hasn't already.  Return
* current input position, index(), or some other marker so that
* when passed to rewind() you get back to the same spot.
* rewind(mark()) should not affect the input cursor.  The Lexer
* tracks line/col info as well as input index so its markers are
* not pure input indexes.  Same for tree node streams.
*
* <p>Marking is a mechanism for storing the current position of a stream
* in a stack.  This corresponds with the predictive look-ahead mechanism
* used in Lexers.</p>
* @returns {Number} the current size of the mark stack.
*/
mark: function() {
if ( !this.markers ) {
this.markers = [];
this.markers.push(null); // depth 0 means no backtracking, leave blank
}
this.markDepth++;
var state = null;
if ( this.markDepth>=this.markers.length ) {
state = {};
this.markers.push(state);
}
else {
state = this.markers[this.markDepth];
}
state.p = this.p;
state.line = this.line;
state.charPositionInLine = this.charPositionInLine;
this.lastMarker = this.markDepth;
return this.markDepth;
},
/**
* Rewind to the input position of the last marker.
* Used currently only after a cyclic DFA and just
* before starting a sem/syn predicate to get the
* input position back to the start of the decision.
* Do not "pop" the marker off the state.  mark(i)
* and rewind(i) should balance still. It is
* like invoking rewind(last marker) but it should not "pop"
* the marker off.  It's like seek(last marker's input position).
* @param {Number} [m] the index in the mark stack to load instead of the
*      last.
*/
rewind: function(m) {
if (!org.antlr.lang.isNumber(m)) {
m = this.lastMarker;
}
var state = this.markers[m];
// restore stream state
this.seek(state.p);
this.line = state.line;
this.charPositionInLine = state.charPositionInLine;
this.release(m);
},
/**
* You may want to commit to a backtrack but don't want to force the
* stream to keep bookkeeping objects around for a marker that is
* no longer necessary.  This will have the same behavior as
* rewind() except it releases resources without the backward seek.
* This must throw away resources for all markers back to the marker
* argument.  So if you're nested 5 levels of mark(), and then release(2)
* you have to release resources for depths 2..5.
* @param {Number} marker the mark depth above which all mark states will
*      be released.
*/
release: function(marker) {
// unwind any other markers made after m and release m
this.markDepth = marker;
// release this marker
this.markDepth--;
},
/**
* Set the input cursor to the position indicated by index.  This is
* normally used to seek ahead in the input stream.  No buffering is
* required to do this unless you know your stream will use seek to
* move backwards such as when backtracking.
*
* <p>This is different from rewind in its multi-directional
* requirement and in that its argument is strictly an input cursor
* (index).</p>
*
* <p>For char streams, seeking forward must update the stream state such
* as line number.  For seeking backwards, you will be presumably
* backtracking using the mark/rewind mechanism that restores state and
* so this method does not need to update state when seeking backwards.</p>
*
* <p>Currently, this method is only used for efficient backtracking using
* memoization, but in the future it may be used for incremental
* parsing.</p>
*
* <p>The index is 0..n-1.  A seek to position i means that LA(1) will
* return the ith symbol.  So, seeking to 0 means LA(1) will return the
* first element in the stream.</p>
*
* <p>Esentially this method method moves the input position,
* {@link #consume}-ing data if necessary.</p>
*
* @param {Number} index the position to seek to.
*/
seek: function(index) {
if ( index<=this.p ) {
this.p = index; // just jump; don't update stream state (line, ...)
return;
}
// seek forward, consume until p hits index
while ( this.p<index ) {
this.consume();
}
},
/**
* Retrieve a substring from this stream.
* @param {Number} start the starting index of the substring (inclusive).
* @param {Number} stop the last index of the substring (inclusive).
* @returns {String}
*/
substring: function(start, stop) {
return this.data.substr(start,stop-start+1);
},
/**
* Return the current line position in the stream.
* @returns {Number} the current line position in the stream (1..numlines).
*/
getLine: function() {
return this.line;
},
/**
* Get the index of the character relative to the beginning of the line.
* Ranges from 0 to (length of line - 1).
* @returns {Number}
*/
getCharPositionInLine: function() {
return this.charPositionInLine;
},
/**
* Set the current line in the input stream.
* This is used internally when performing rewinds.
* @param {Number} line
* @private
*/
setLine: function(line) {
this.line = line;
},
/**
* Set the index of the character relative to the beginning of the line.
* Ranges from 0 to (length of line - 1).
* @param {Number} pos
* @private
*/
setCharPositionInLine: function(pos) {
this.charPositionInLine = pos;
},
/** Where are you getting symbols from? Normally, implementations will
*  pass the buck all the way to the lexer who can ask its input stream
*  for the file name or whatever.
*/
getSourceName: function() {
return null;
}
};
/**
* Alias for {@link #LA}.
* @methodOf org.antlr.runtime.ANTLRStringStream.prototype
* @name LT
*/
org.antlr.runtime.ANTLRStringStream.LT = org.antlr.runtime.ANTLRStringStream.LA;
/** The most common stream of tokens is one where every token is buffered up
*  and tokens are prefiltered for a certain channel (the parser will only
*  see these tokens and cannot change the filter channel number during the
*  parse).
*
*  TODO: how to access the full token stream?  How to track all tokens matched per rule?
*/
org.antlr.runtime.CommonTokenStream = function(tokenSource, channel) {
this.p = -1;
this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
this.v_discardOffChannelTokens = false;
this.tokens = [];
if (arguments.length >= 2) {
this.channel = channel;
} else if (arguments.length === 1) {
this.tokenSource = tokenSource;
}
};
org.antlr.runtime.CommonTokenStream.prototype = {
/** Reset this token stream by setting its token source. */
setTokenSource: function(tokenSource) {
this.tokenSource = tokenSource;
this.tokens = [];
this.p = -1;
this.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
},
/** Load all tokens from the token source and put in tokens.
*  This is done upon first LT request because you might want to
*  set some token type / channel overrides before filling buffer.
*/
fillBuffer: function() {
var index = 0,
t = this.tokenSource.nextToken(),
discard,
channelI;
while ( org.antlr.lang.isValue(t) && 
t.getType()!=org.antlr.runtime.CharStream.EOF )
{
discard = false;
// is there a channel override for token type?
if ( this.channelOverrideMap ) {
channelI = this.channelOverrideMap[t.getType()];
if ( org.antlr.lang.isValue(channelI) ) {
t.setChannel(channelI);
}
}
if ( this.discardSet && this.discardSet[t.getType()] )
{
discard = true;
}
else if ( this.v_discardOffChannelTokens &&
t.getChannel()!=this.channel )
{
discard = true;
}
if ( !discard )    {
t.setTokenIndex(index);
this.tokens.push(t);
index++;
}
t = this.tokenSource.nextToken();
}
// leave p pointing at first token on channel
this.p = 0;
this.p = this.skipOffTokenChannels(this.p);
},
/** Move the input pointer to the next incoming token.  The stream
*  must become active with LT(1) available.  consume() simply
*  moves the input pointer so that LT(1) points at the next
*  input symbol. Consume at least one token.
*
*  Walk past any token not on the channel the parser is listening to.
*/
consume: function() {
if ( this.p<this.tokens.length ) {
this.p++;
this.p = this.skipOffTokenChannels(this.p); // leave p on valid token
}
},
/** Given a starting index, return the index of the first on-channel
*  token.
*/
skipOffTokenChannels: function(i) {
var n = this.tokens.length;
while ( i<n && (this.tokens[i]).getChannel()!=this.channel ) {
i++;
}
return i;
},
skipOffTokenChannelsReverse: function(i) {
while ( i>=0 && (this.tokens[i]).getChannel()!=this.channel ) {
i--;
}
return i;
},
/** A simple filter mechanism whereby you can tell this token stream
*  to force all tokens of type ttype to be on channel.  For example,
*  when interpreting, we cannot exec actions so we need to tell
*  the stream to force all WS and NEWLINE to be a different, ignored
*  channel.
*/
setTokenTypeChannel: function(ttype, channel) {
if ( !this.channelOverrideMap ) {
this.channelOverrideMap = {};
}
this.channelOverrideMap[ttype] = channel;
},
discardTokenType: function(ttype) {
if ( !this.discardSet ) {
this.discardSet = {};
}
this.discardSet[ttype] = true;
},
discardOffChannelTokens: function(b) {
this.v_discardOffChannelTokens = b;
},
/** Given a start and stop index, return a List of all tokens in
*  the token type BitSet.  Return null if no tokens were found.  This
*  method looks at both on and off channel tokens.
*/
getTokens: function(start, stop, types) {
if ( this.p === -1 ) {
this.fillBuffer();
}
if (arguments.length===0) {
return this.tokens;
}
if (org.antlr.lang.isArray(types)) {
types = new org.antlr.runtime.BitSet(types);
} else if (org.antlr.lang.isNumber(types)) {
types = org.antlr.runtime.BitSet.of(types);
}
if ( stop>=this.tokens.length ) {
stop=this.tokens.length-1;
}
if ( start<0 ) {
start=0;
}
if ( start>stop ) {
return null;
}
// list = tokens[start:stop]:{Token t, t.getType() in types}
var filteredTokens = [],
i,
t;
for (i=start; i<=stop; i++) {
t = this.tokens[i];
if ( !this.types || types.member(t.getType()) ) {
filteredTokens.push(t);
}
}
if ( filteredTokens.length===0 ) {
filteredTokens = null;
}
return filteredTokens;
},
/** Get the ith token from the current position 1..n where k=1 is the
*  first symbol of lookahead.
*/
LT: function(k) {
if ( this.p === -1 ) {
this.fillBuffer();
}
if ( k===0 ) {
return null;
}
if ( k<0 ) {
return this.LB(-1*k);
}
if ( (this.p+k-1) >= this.tokens.length ) {
return org.antlr.runtime.Token.EOF_TOKEN;
}
var i = this.p,
n = 1;
// find k good tokens
while ( n<k ) {
// skip off-channel tokens
i = this.skipOffTokenChannels(i+1); // leave p on valid token
n++;
}
if ( i>=this.tokens.length ) {
return org.antlr.runtime.Token.EOF_TOKEN;
}
return this.tokens[i];
},
/** Look backwards k tokens on-channel tokens */
LB: function(k) {
if ( this.p === -1 ) {
this.fillBuffer();
}
if ( k===0 ) {
return null;
}
if ( (this.p-k)<0 ) {
return null;
}
var i = this.p,
n = 1;
// find k good tokens looking backwards
while ( n<=k ) {
// skip off-channel tokens
i = this.skipOffTokenChannelsReverse(i-1); // leave p on valid token
n++;
}
if ( i<0 ) {
return null;
}
return this.tokens[i];
},
/** Return absolute token i; ignore which channel the tokens are on;
*  that is, count all tokens not just on-channel tokens.
*/
get: function(i) {
return this.tokens[i];
},
LA: function(i) {
return this.LT(i).getType();
},
mark: function() {
if ( this.p === -1 ) {
this.fillBuffer();
}
this.lastMarker = this.index();
return this.lastMarker;
},
release: function(marker) {
// no resources to release
},
size: function() {
return this.tokens.length;
},
index: function() {
return this.p;
},
rewind: function(marker) {
if (!org.antlr.lang.isNumber(marker)) {
marker = this.lastMarker;
}
this.seek(marker);
},
reset: function() {
this.p = -1;
this.lastMarker = 0;
},
seek: function(index) {
this.p = index;
},
getTokenSource: function() {
return this.tokenSource;
},
getSourceName: function() {
return this.getTokenSource().getSourceName();
},
toString: function(start, stop) {
if (arguments.length===0) {
if ( this.p === -1 ) {
this.fillBuffer();
}
start = 0;
stop = this.tokens.length-1;
}
if (!org.antlr.lang.isNumber(start) && !org.antlr.lang.isNumber(stop)) {
if ( org.antlr.lang.isValue(start) && org.antlr.lang.isValue(stop) ) {
start = start.getTokenIndex();
stop = stop.getTokenIndex();
} else {
return null;
}
}
var buf = "",
i;
if ( start<0 || stop<0 ) {
return null;
}
if ( this.p == -1 ) {
this.fillBuffer();
}
if ( stop>=this.tokens.length ) {
stop = this.tokens.length-1;
}
for (i = start; i <= stop; i++) {
t = this.tokens[i];
buf = buf + this.tokens[i].getText();
}
return buf;
}
};
/* Useful for dumping out the input stream after doing some
*  augmentation or other manipulations.
*
*  You can insert stuff, replace, and delete chunks.  Note that the
*  operations are done lazily--only if you convert the buffer to a
*  String.  This is very efficient because you are not moving data around
*  all the time.  As the buffer of tokens is converted to strings, the
*  toString() method(s) check to see if there is an operation at the
*  current index.  If so, the operation is done and then normal String
*  rendering continues on the buffer.  This is like having multiple Turing
*  machine instruction streams (programs) operating on a single input tape. :)
*
*  Since the operations are done lazily at toString-time, operations do not
*  screw up the token index values.  That is, an insert operation at token
*  index i does not change the index values for tokens i+1..n-1.
*
*  Because operations never actually alter the buffer, you may always get
*  the original token stream back without undoing anything.  Since
*  the instructions are queued up, you can easily simulate transactions and
*  roll back any changes if there is an error just by removing instructions.
*  For example,
*
*   CharStream input = new ANTLRFileStream("input");
*   TLexer lex = new TLexer(input);
*   TokenRewriteStream tokens = new TokenRewriteStream(lex);
*   T parser = new T(tokens);
*   parser.startRule();
*
*      Then in the rules, you can execute
*      Token t,u;
*      ...
*      input.insertAfter(t, "text to put after t");}
*         input.insertAfter(u, "text after u");}
*         System.out.println(tokens.toString());
*
*  Actually, you have to cast the 'input' to a TokenRewriteStream. :(
*
*  You can also have multiple "instruction streams" and get multiple
*  rewrites from a single pass over the input.  Just name the instruction
*  streams and use that name again when printing the buffer.  This could be
*  useful for generating a C file and also its header file--all from the
*  same buffer:
*
*      tokens.insertAfter("pass1", t, "text to put after t");}
*         tokens.insertAfter("pass2", u, "text after u");}
*         System.out.println(tokens.toString("pass1"));
*         System.out.println(tokens.toString("pass2"));
*
*  If you don't use named rewrite streams, a "default" stream is used as
*  the first example shows.
*/
org.antlr.runtime.TokenRewriteStream = function() {
var sup = org.antlr.runtime.TokenRewriteStream.superclass;
/** You may have multiple, named streams of rewrite operations.
*  I'm calling these things "programs."
*  Maps String (name) -> rewrite (List)
*/
this.programs = null;
/** Map String (program name) -> Integer index */
this.lastRewriteTokenIndexes = null;
if (arguments.length===0) {
this.init();
} else {
sup.constructor.apply(this, arguments);
this.init();
}
};
(function(){
var trs = org.antlr.runtime.TokenRewriteStream;
org.antlr.lang.augmentObject(trs, {
DEFAULT_PROGRAM_NAME: "default",
PROGRAM_INIT_SIZE: 100,
MIN_TOKEN_INDEX: 0
});
//
// Define the rewrite operation hierarchy
//
trs.RewriteOperation = function(index, text) {
this.index = index;
this.text = text;
};
/** Execute the rewrite operation by possibly adding to the buffer.
*  Return the index of the next token to operate on.
*/
trs.RewriteOperation.prototype = {
execute: function(buf) {
return this.index;
},
toString: function() {
/*String opName = getClass().getName();
int $index = opName.indexOf('$');
opName = opName.substring($index+1, opName.length());
return opName+"@"+index+'"'+text+'"';*/
return this.text;
}
};
trs.InsertBeforeOp = function(index, text) {
trs.InsertBeforeOp.superclass.constructor.call(this, index, text);
};
org.antlr.lang.extend(trs.InsertBeforeOp, trs.RewriteOperation, {
execute: function(buf) {
buf.push(this.text);
return this.index;
}
});
/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
*  instructions.
*/
trs.ReplaceOp = function(from, to, text) {
trs.ReplaceOp.superclass.constructor.call(this, from, text); 
this.lastIndex = to;
};
org.antlr.lang.extend(trs.ReplaceOp, trs.RewriteOperation, {
execute: function(buf) {
if (org.antlr.lang.isValue(this.text)) {
buf.push(this.text);
}
return this.lastIndex+1;
}
});
trs.DeleteOp = function(from, to) {
trs.DeleteOp.superclass.constructor.call(this, from, to); 
};
org.antlr.lang.extend(trs.DeleteOp, trs.ReplaceOp);
org.antlr.lang.extend(trs, org.antlr.runtime.CommonTokenStream, {
init: function() {
this.programs = {};
this.programs[trs.DEFAULT_PROGRAM_NAME] = [];
this.lastRewriteTokenIndexes = {};
},
/** Rollback the instruction stream for a program so that
*  the indicated instruction (via instructionIndex) is no
*  longer in the stream.  UNTESTED!
*/
rollback: function() {
var programName,
instructionIndex;
if (arguments.length===1) {
programName = trs.DEFAULT_PROGRAM_NAME;
instructionIndex = arguments[0];
} else if (arguments.length===2) {
programName = arguments[0];
instructionIndex = arguments[1];
}
var is = this.programs[programName];
if (is) {
programs[programName] = is.slice(trs.MIN_TOKEN_INDEX, this.instructionIndex);
}
},
/** Reset the program so that no instructions exist */
deleteProgram: function(programName) {
programName = programName || trs.DEFAULT_PROGRAM_NAME;
this.rollback(programName, trs.MIN_TOKEN_INDEX);
},
/** Add an instruction to the rewrite instruction list ordered by
*  the instruction number (use a binary search for efficiency).
*  The list is ordered so that toString() can be done efficiently.
*
*  When there are multiple instructions at the same index, the instructions
*  must be ordered to ensure proper behavior.  For example, a delete at
*  index i must kill any replace operation at i.  Insert-before operations
*  must come before any replace / delete instructions.  If there are
*  multiple insert instructions for a single index, they are done in
*  reverse insertion order so that "insert foo" then "insert bar" yields
*  "foobar" in front rather than "barfoo".  This is convenient because
*  I can insert new InsertOp instructions at the index returned by
*  the binary search.  A ReplaceOp kills any previous replace op.  Since
*  delete is the same as replace with null text, i can check for
*  ReplaceOp and cover DeleteOp at same time. :)
*/
addToSortedRewriteList: function() {
var programName,
op;
if (arguments.length===1) {
programName = trs.DEFAULT_PROGRAM_NAME;
op = arguments[0];
} else if (arguments.length===2) {
programName = arguments[0];
op = arguments[1];
}
var rewrites = this.getProgram(programName);
var len, pos, searchOp, replaced, prevOp, i;
for (pos=0, len=rewrites.length; pos<len; pos++) {
searchOp = rewrites[pos];
if (searchOp.index===op.index) {
// now pos is the index in rewrites of first op with op.index
// an instruction operating already on that index was found;
// make this one happen after all the others
if (op instanceof trs.ReplaceOp) {
replaced = false;
// look for an existing replace
for (i=pos; i<rewrites.length; i++) {
prevOp = rewrites[pos];
if (prevOp.index!==op.index) {
break;
}
if (prevOp instanceof trs.ReplaceOp) {
rewrites[pos] = op; // replace old with new
replaced=true;
break;
}
// keep going; must be an insert
}
if ( !replaced ) {
// add replace op to the end of all the inserts
rewrites.splice(i, 0, op);
}
} else {
// inserts are added in front of existing inserts
rewrites.splice(pos, 0, op);
}
break;
} else if (searchOp.index > op.index) {
rewrites.splice(pos, 0, op);
break;
}
}
if (pos===len) {
rewrites.push(op);
}
},
insertAfter: function() {
var index, programName, text;
if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
index = arguments[0];
text = arguments[1];
} else if (arguments.length===3) {
programName = arguments[0];
index = arguments[1];
text = arguments[2];
}
if (index instanceof org.antlr.runtime.CommonToken) {
// index is a Token, grab it's stream index
index = index.index; // that's ugly
}
// insert after is the same as insert before the next index
this.insertBefore(programName, index+1, text);
},
insertBefore: function() {
var index, programName, text;
if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
index = arguments[0];
text = arguments[1];
} else if (arguments.length===3) {
programName = arguments[0];
index = arguments[1];
text = arguments[2];
}
if (index instanceof org.antlr.runtime.CommonToken) {
// index is a Token, grab it's stream index
index = index.index; // that's ugly
}
this.addToSortedRewriteList(
programName,
new trs.InsertBeforeOp(index,text)
);
},
replace: function() {
var programName, first, last, text;
if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
first = arguments[0];
last = arguments[0];
text = arguments[1];
} else if (arguments.length===3) {
programName = trs.DEFAULT_PROGRAM_NAME;
first = arguments[0];
last = arguments[1];
text = arguments[2];
} if (arguments.length===4) {
programName = arguments[0];
first = arguments[1];
last = arguments[2];
text = arguments[3];
} 
if (first instanceof org.antlr.runtime.CommonToken) {
first = first.index;
}
if (last instanceof org.antlr.runtime.CommonToken) {
last = last.index; // that's ugly
}
if ( first > last || last<0 || first<0 ) {
return;
}
this.addToSortedRewriteList(
programName,
new trs.ReplaceOp(first, last, text));
},
// !!! API Break: delete is a JS keyword, so using remove instead.
remove: function() {
// convert arguments to a real array
var args=[], i=arguments.length-1;
while (i>=0) {
args[i] = arguments[i];
i--;
}
args.push("");
this.replace.apply(this, args);
},
getLastRewriteTokenIndex: function(programName) {
programName = programName || trs.DEFAULT_PROGRAM_NAME;
return this.lastRewriteTokenIndexes[programName] || -1;
},
setLastRewriteTokenIndex: function(programName, i) {
this.lastRewriteTokenIndexes[programName] = i;
},
getProgram: function(name) {
var is = this.programs[name];
if ( !is ) {
is = this.initializeProgram(name);
}
return is;
},
initializeProgram: function(name) {
var is = [];
this.programs[name] = is;
return is;
},
toOriginalString: function(start, end) {
if (!org.antlr.lang.isNumber(start)) {
start = trs.MIN_TOKEN_INDEX;
}
if (!org.antlr.lang.isNumber(end)) {
end = this.size()-1;
}
var buf = [], i;
for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
buf.push(this.get(i).getText());
}
return buf.join("");
},
toString: function() {
var programName, start, end;
if (arguments.length===0) {
programName = trs.DEFAULT_PROGRAM_NAME;
start = trs.MIN_TOKEN_INDEX;
end = this.size() - 1;
} else if (arguments.length===1) {
programName = arguments[0];
start = trs.MIN_TOKEN_INDEX;
end = this.size() - 1;
} else if (arguments.length===2) {
programName = trs.DEFAULT_PROGRAM_NAME;
start = arguments[0];
end = arguments[1];
}
var rewrites = this.programs[programName];
if ( !rewrites || rewrites.length===0 ) {
return this.toOriginalString(start,end);
}
/// Index of first rewrite we have not done
var rewriteOpIndex = 0,
tokenCursor=start,
buf = [],
op;
while ( tokenCursor>=trs.MIN_TOKEN_INDEX &&
tokenCursor<=end &&
tokenCursor<this.tokens.length )
{
// execute instructions associated with this token index
if ( rewriteOpIndex<rewrites.length ) {
op = rewrites[rewriteOpIndex];
// skip all ops at lower index
while (op.index<tokenCursor && rewriteOpIndex<rewrites.length) {
rewriteOpIndex++;
if ( rewriteOpIndex<rewrites.length ) {
op = rewrites[rewriteOpIndex];
}
}
// while we have ops for this token index, exec them
while (tokenCursor===op.index && rewriteOpIndex<rewrites.length) {
//System.out.println("execute "+op+" at instruction "+rewriteOpIndex);
tokenCursor = op.execute(buf);
//System.out.println("after execute tokenCursor = "+tokenCursor);
rewriteOpIndex++;
if ( rewriteOpIndex<rewrites.length ) {
op = rewrites[rewriteOpIndex];
}
}
}
// dump the token at this index
if ( tokenCursor<=end ) {
buf.push(this.get(tokenCursor).getText());
tokenCursor++;
}
}
// now see if there are operations (append) beyond last token index
var opi;
for (opi=rewriteOpIndex; opi<rewrites.length; opi++) {
op = rewrites[opi];
if ( op.index>=this.size() ) {
op.execute(buf); // must be insertions if after last token
}
}
return buf.join("");
},
toDebugString: function(start, end) {
if (!org.antlr.lang.isNumber(start)) {
start = trs.MIN_TOKEN_INDEX;
}
if (!org.antlr.lang.isNumber(end)) {
end = this.size()-1;
}
var buf = [],
i;
for (i=start; i>=trs.MIN_TOKEN_INDEX && i<=end && i<this.tokens.length; i++) {
buf.push(this.get(i));
}
return buf.join("");
}
});
})();
/** A stream of tree nodes, accessing nodes from a tree of some kind */
org.antlr.runtime.tree.TreeNodeStream = function() {};
/** A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.
*
*  This node stream sucks all nodes out of the tree specified in
*  the constructor during construction and makes pointers into
*  the tree using an array of Object pointers. The stream necessarily
*  includes pointers to DOWN and UP and EOF nodes.
*
*  This stream knows how to mark/release for backtracking.
*
*  This stream is most suitable for tree interpreters that need to
*  jump around a lot or for tree parsers requiring speed (at cost of memory).
*  There is some duplicated functionality here with UnBufferedTreeNodeStream
*  but just in bookkeeping, not tree walking etc...
*
*  @see UnBufferedTreeNodeStream
*/
org.antlr.runtime.tree.CommonTreeNodeStream = function(adaptor,
tree,
initialBufferSize)
{
if (arguments.length===1) {
tree = adaptor;
adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
}
if (arguments.length <= 2) {
initialBufferSize =
org.antlr.runtime.tree.CommonTreeNodeStream.DEFAULT_INITIAL_BUFFER_SIZE;
}
/** Reuse same DOWN, UP navigation nodes unless this is true */
this.uniqueNavigationNodes = false;
/** The index into the nodes list of the current node (next node
*  to consume).  If -1, nodes array not filled yet.
*/
this.p = -1;
var Token = org.antlr.runtime.Token;
this.root = tree;
this.adaptor = adaptor;
this.nodes = []; //new ArrayList(initialBufferSize);
this.down = this.adaptor.create(Token.DOWN, "DOWN");
this.up = this.adaptor.create(Token.UP, "UP");
this.eof = this.adaptor.create(Token.EOF, "EOF");
};
org.antlr.lang.augmentObject(org.antlr.runtime.tree.CommonTreeNodeStream, {
DEFAULT_INITIAL_BUFFER_SIZE: 100,
INITIAL_CALL_STACK_SIZE: 10
});
org.antlr.lang.extend(org.antlr.runtime.tree.CommonTreeNodeStream,
org.antlr.runtime.tree.TreeNodeStream, 
{
StreamIterator: function() {
var i = 0,
nodes = this.nodes,
eof = this.eof;
return {
hasNext: function() {
return i<nodes.length;
},
next: function() {
var current = i;
i++;
if ( current < nodes.length ) {
return nodes[current];
}
return eof;
},
remove: function() {
throw new Error("cannot remove nodes from stream");
}
};
},
/** Walk tree with depth-first-search and fill nodes buffer.
*  Don't do DOWN, UP nodes if its a list (t is isNil).
*/
fillBuffer: function(t) {
var reset_p = false;
if (org.antlr.lang.isUndefined(t)) {
t = this.root;
reset_p = true;
}
var nil = this.adaptor.isNil(t);
if ( !nil ) {
this.nodes.push(t); // add this node
}
// add DOWN node if t has children
var n = this.adaptor.getChildCount(t);
if ( !nil && n>0 ) {
this.addNavigationNode(org.antlr.runtime.Token.DOWN);
}
// and now add all its children
var c, child;
for (c=0; c<n; c++) {
child = this.adaptor.getChild(t,c);
this.fillBuffer(child);
}
// add UP node if t has children
if ( !nil && n>0 ) {
this.addNavigationNode(org.antlr.runtime.Token.UP);
}
if (reset_p) {
this.p = 0; // buffer of nodes intialized now
}
},
getNodeIndex: function(node) {
if ( this.p==-1 ) {
this.fillBuffer();
}
var i, t;
for (i=0; i<this.nodes.length; i++) {
t = this.nodes[i];
if ( t===node ) {
return i;
}
}
return -1;
},
/** As we flatten the tree, we use UP, DOWN nodes to represent
*  the tree structure.  When debugging we need unique nodes
*  so instantiate new ones when uniqueNavigationNodes is true.
*/
addNavigationNode: function(ttype) {
var navNode = null;
if ( ttype===org.antlr.runtime.Token.DOWN ) {
if ( this.hasUniqueNavigationNodes() ) {
navNode = this.adaptor.create(org.antlr.runtime.Token.DOWN, "DOWN");
}
else {
navNode = this.down;
}
}
else {
if ( this.hasUniqueNavigationNodes() ) {
navNode = this.adaptor.create(org.antlr.runtime.Token.UP, "UP");
}
else {
navNode = this.up;
}
}
this.nodes.push(navNode);
},
get: function(i) {
if ( this.p===-1 ) {
this.fillBuffer();
}
return this.nodes[i];
},
LT: function(k) {
if ( this.p===-1 ) {
this.fillBuffer();
}
if ( k===0 ) {
return null;
}
if ( k<0 ) {
return this.LB(-1*k);
}
if ( (this.p+k-1) >= this.nodes.length ) {
return this.eof;
}
return this.nodes[this.p+k-1];
},
getCurrentSymbol: function() { return this.LT(1); },
/** Look backwards k nodes */
LB: function(k) {
if ( k===0 ) {
return null;
}
if ( (this.p-k)<0 ) {
return null;
}
return this.nodes[this.p-k];
},
getTreeSource: function() {
return this.root;
},
getSourceName: function() {
return this.getTokenStream().getSourceName();
},
getTokenStream: function() {
return this.tokens;
},
setTokenStream: function(tokens) {
this.tokens = tokens;
},
getTreeAdaptor: function() {
return this.adaptor;
},
setTreeAdaptor: function(adaptor) {
this.adaptor = adaptor;
},
hasUniqueNavigationNodes: function() {
return this.uniqueNavigationNodes;
},
setUniqueNavigationNodes: function(uniqueNavigationNodes) {
this.uniqueNavigationNodes = uniqueNavigationNodes;
},
consume: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
this.p++;
},
LA: function(i) {
return this.adaptor.getType(this.LT(i));
},
mark: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
this.lastMarker = this.index();
return this.lastMarker;
},
release: function(marker) {
// no resources to release
},
index: function() {
return this.p;
},
rewind: function(marker) {
if (!org.antlr.lang.isNumber(marker)) {
marker = this.lastMarker;
}
this.seek(marker);
},
seek: function(index) {
if ( this.p===-1 ) {
this.fillBuffer();
}
this.p = index;
},
/** Make stream jump to a new location, saving old location.
*  Switch back with pop().
*/
push: function(index) {
if ( !this.calls ) {
this.calls = [];
}
this.calls.push(this.p); // save current index
this.seek(index);
},
/** Seek back to previous index saved during last push() call.
*  Return top of stack (return index).
*/
pop: function() {
var ret = this.calls.pop();
this.seek(ret);
return ret;
},
reset: function() {
this.p = -1;
this.lastMarker = 0;
if (this.calls) {
this.calls = [];
}
},
size: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
return this.nodes.length;
},
iterator: function() {
if ( this.p===-1 ) {
this.fillBuffer();
}
return this.StreamIterator();
},
replaceChildren: function(parent, startChildIndex, stopChildIndex, t) {
if ( parent ) {
this.adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t);
}
},
/** Debugging */
toTokenString: function(start, stop) {
if ( this.p===-1 ) {
this.fillBuffer();
}
var buf='', i, t;
for (i = start; i < this.nodes.length && i <= stop; i++) {
t = this.nodes[i];
buf += " "+this.adaptor.getToken(t);
}
return buf;
},
/** Used for testing, just return the token type stream */
toString: function(start, stop) {
var buf = "",
text,
t,
i;
if (arguments.length===0) {
if ( this.p===-1 ) {
this.fillBuffer();
}
for (i = 0; i < this.nodes.length; i++) {
t = this.nodes[i];
buf += " ";
buf += this.adaptor.getType(t);
}
return buf;
} else {
if ( !org.antlr.lang.isNumber(start) || !org.antlr.lang.isNumber(stop) ) {
return null;
}
if ( this.p===-1 ) {
this.fillBuffer();
}
//System.out.println("stop: "+stop);
if ( start instanceof org.antlr.runtime.tree.CommonTree ) {
//System.out.print("toString: "+((CommonTree)start).getToken()+", ");
} else {
//System.out.println(start);
}
if ( stop instanceof org.antlr.runtime.tree.CommonTree ) {
//System.out.println(((CommonTree)stop).getToken());
} else {
//System.out.println(stop);
}
// if we have the token stream, use that to dump text in order
var beginTokenIndex,
endTokenIndex;
if ( this.tokens ) {
beginTokenIndex = this.adaptor.getTokenStartIndex(start);
endTokenIndex = this.adaptor.getTokenStopIndex(stop);
// if it's a tree, use start/stop index from start node
// else use token range from start/stop nodes
if ( this.adaptor.getType(stop)===org.antlr.runtime.Token.UP ) {
endTokenIndex = this.adaptor.getTokenStopIndex(start);
}
else if ( this.adaptor.getType(stop)==org.antlr.runtime.Token.EOF )
{
endTokenIndex = this.size()-2; // don't use EOF
}
return this.tokens.toString(beginTokenIndex, endTokenIndex);
}
// walk nodes looking for start
t = null;
i = 0;
for (; i < this.nodes.length; i++) {
t = this.nodes[i];
if ( t===start ) {
break;
}
}
// now walk until we see stop, filling string buffer with text
buf = text = "";
t = this.nodes[i];
while ( t!==stop ) {
text = this.adaptor.getText(t);
if ( !org.antlr.lang.isString(text) ) {
text = " "+this.adaptor.getType(t).toString();
}
buf += text;
i++;
t = nodes[i];
}
// include stop node too
text = this.adaptor.getText(stop);
if ( !org.antlr.lang.isString(text) ) {
text = " "+this.adaptor.getType(stop).toString();
}
buf += text;
return buf;
}
}
});
/** A generic list of elements tracked in an alternative to be used in
*  a -> rewrite rule.  We need to subclass to fill in the next() method,
*  which returns either an AST node wrapped around a token payload or
*  an existing subtree.
*
*  Once you start next()ing, do not try to add more elements.  It will
*  break the cursor tracking I believe.
*
*  @see org.antlr.runtime.tree.RewriteRuleSubtreeStream
*  @see org.antlr.runtime.tree.RewriteRuleTokenStream
*
*  TODO: add mechanism to detect/puke on modification after reading from stream
*/
org.antlr.runtime.tree.RewriteRuleElementStream = function(adaptor, elementDescription, el) {
/** Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
*  which bumps it to 1 meaning no more elements.
*/
this.cursor = 0;
/** Once a node / subtree has been used in a stream, it must be dup'd
*  from then on.  Streams are reset after subrules so that the streams
*  can be reused in future subrules.  So, reset must set a dirty bit.
*  If dirty, then next() always returns a dup.
*
*  I wanted to use "naughty bit" here, but couldn't think of a way
*  to use "naughty".
*/
this.dirty = false;
this.elementDescription = elementDescription;
this.adaptor = adaptor;
if (el) {
if (org.antlr.lang.isArray(el)) {
this.singleElement = null;
this.elements = el;
} else {
this.add(el);
}
}
};
org.antlr.runtime.tree.RewriteRuleElementStream.prototype = {
/** Reset the condition of this stream so that it appears we have
*  not consumed any of its elements.  Elements themselves are untouched.
*  Once we reset the stream, any future use will need duplicates.  Set
*  the dirty bit.
*/
reset: function() {
this.cursor = 0;
this.dirty = true;
},
add: function(el) {
if ( !org.antlr.lang.isValue(el) ) {
return;
}
if ( this.elements ) { // if in list, just add
this.elements.push(el);
return;
}
if ( !org.antlr.lang.isValue(this.singleElement) ) { // no elements yet, track w/o list
this.singleElement = el;
return;
}
// adding 2nd element, move to list
this.elements = [];
this.elements.push(this.singleElement);
this.singleElement = null;
this.elements.push(el);
},
/** Return the next element in the stream.  If out of elements, throw
*  an exception unless size()==1.  If size is 1, then return elements[0].
*  Return a duplicate node/subtree if stream is out of elements and
*  size==1.  If we've already used the element, dup (dirty bit set).
*/
nextTree: function() {
var n = this.size(),
el;
if ( this.dirty || (this.cursor>=n && n==1) ) {
// if out of elements and size is 1, dup
el = this._next();
return this.dup(el);
}
// test size above then fetch
el = this._next();
return el;
},
/** do the work of getting the next element, making sure that it's
*  a tree node or subtree.  Deal with the optimization of single-
*  element list versus list of size > 1.  Throw an exception
*  if the stream is empty or we're out of elements and size>1.
*  protected so you can override in a subclass if necessary.
*/
_next: function() {
var n = this.size();
if (n===0) {
throw new org.antlr.runtime.tree.RewriteEmptyStreamException(this.elementDescription);
}
if ( this.cursor>= n) { // out of elements?
if ( n===1 ) {  // if size is 1, it's ok; return and we'll dup
return this.toTree(this.singleElement);
}
// out of elements and size was not 1, so we can't dup
throw new org.antlr.runtime.tree.RewriteCardinalityException(this.elementDescription);
}
// we have elements
if ( org.antlr.lang.isValue(this.singleElement) ) {
this.cursor++; // move cursor even for single element list
return this.toTree(this.singleElement);
}
// must have more than one in list, pull from elements
var o = this.toTree(this.elements[this.cursor]);
this.cursor++;
return o;
},
/** Ensure stream emits trees; tokens must be converted to AST nodes.
*  AST nodes can be passed through unmolested.
*/
toTree: function(el) {
if (el && el.getTree) {
return el.getTree();
}
return el;
},
hasNext: function() {
return (org.antlr.lang.isValue(this.singleElement) && this.cursor < 1) ||
(this.elements && this.cursor < this.elements.length);
},
size: function() {
var n = 0;
if ( org.antlr.lang.isValue(this.singleElement) ) {
n = 1;
}
if ( this.elements ) {
return this.elements.length;
}
return n;
},
getDescription: function() {
return this.elementDescription;
}
};
/** Queues up nodes matched on left side of -> in a tree parser. This is
*  the analog of RewriteRuleTokenStream for normal parsers. 
*/
org.antlr.runtime.tree.RewriteRuleNodeStream = function(adaptor, elementDescription, el) {
org.antlr.runtime.tree.RewriteRuleNodeStream.superclass.constructor.apply(this, arguments);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleNodeStream,
org.antlr.runtime.tree.RewriteRuleElementStream,
{
nextNode: function() {
return this._next();
},
toTree: function(el) {
return this.adaptor.dupNode(el);
},
dup: function() {
// we dup every node, so don't have to worry about calling dup; short-
// circuited next() so it doesn't call.
throw new Error("dup can't be called for a node stream.");
}
});
org.antlr.runtime.tree.RewriteRuleTokenStream = function(adaptor, elementDescription, el) {
var sup = org.antlr.runtime.tree.RewriteRuleTokenStream.superclass;
sup.constructor.apply(this, arguments);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleTokenStream,
org.antlr.runtime.tree.RewriteRuleElementStream, {
/** Get next token from stream and make a node for it */
nextNode: function() {
var t = this._next();
return this.adaptor.create(t);
},
nextToken: function() {
return this._next();
},
/** Don't convert to a tree unless they explicitly call nextTree.
*  This way we can do hetero tree nodes in rewrite.
*/
toTree: function(el) {
return el;
},
dup: function(el) {
throw new Error("dup can't be called for a token stream.");
}
});
org.antlr.runtime.tree.RewriteRuleSubtreeStream = function() {
var sup = org.antlr.runtime.tree.RewriteRuleSubtreeStream.superclass;
sup.constructor.apply(this, arguments);
};
org.antlr.lang.extend(org.antlr.runtime.tree.RewriteRuleSubtreeStream,
org.antlr.runtime.tree.RewriteRuleElementStream, {
/** Treat next element as a single node even if it's a subtree.
*  This is used instead of next() when the result has to be a
*  tree root node.  Also prevents us from duplicating recently-added
*  children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
*  must dup the type node, but ID has been added.
*
*  Referencing a rule result twice is ok; dup entire tree as
*  we can't be adding trees as root; e.g., expr expr.
*
*  Hideous code duplication here with super.next().  Can't think of
*  a proper way to refactor.  This needs to always call dup node
*  and super.next() doesn't know which to call: dup node or dup tree.
*/
nextNode: function() {
var n = this.size(),
el;
if ( this.dirty || (this.cursor>=n && n===1) ) {
// if out of elements and size is 1, dup (at most a single node
// since this is for making root nodes).
el = this._next();
return this.adaptor.dupNode(el);
}
// test size above then fetch
el = this._next();
return el;
},
dup: function(el) {
return this.adaptor.dupTree(el);
}
});/** A generic recognizer that can handle recognizers generated from
*  lexer, parser, and tree grammars.  This is all the parsing
*  support code essentially; most of it is error recovery stuff and
*  backtracking.
*
*  <p>This class should not be instantiated directly.  Instead, use one of its
*  subclasses.</p>
*
*  @class
*  @param {org.antlr.runtime.RecognizerSharedState} [state] optional state object
*      with which to initialize this recognizer.
*/
org.antlr.runtime.BaseRecognizer = function(state) {
/** State of a lexer, parser, or tree parser are collected into a state
*  object so the state can be shared.  This sharing is needed to
*  have one grammar import others and share same error variables
*  and other state variables.  It's a kind of explicit multiple
*  inheritance via delegation of methods and shared state.
*/
this.state = state || new org.antlr.runtime.RecognizerSharedState();
};
/* static vars, methods */
org.antlr.lang.augmentObject(org.antlr.runtime.BaseRecognizer, {
MEMO_RULE_FAILED: -2,
MEMO_RULE_UNKNOWN: -1,
INITIAL_FOLLOW_STACK_SIZE: 100,
MEMO_RULE_FAILED_I: -2,
DEFAULT_TOKEN_CHANNEL: org.antlr.runtime.Token.DEFAULT_CHANNEL,
HIDDEN: org.antlr.runtime.Token.HIDDEN_CHANNEL,
NEXT_TOKEN_RULE_NAME: "nextToken"
});
org.antlr.runtime.BaseRecognizer.prototype = {
/** Reset the parser's state.  Subclasses must rewinds the input stream */
reset: function() {
var i, len;
// wack everything related to error recovery
if (!this.state) {
return; // no shared state work to do
}
this.state._fsp = -1;
this.state.errorRecovery = false;
this.state.lastErrorIndex = -1;
this.state.failed = false;
this.state.syntaxErrors = 0;
// wack everything related to backtracking and memoization
this.state.backtracking = 0;
// wipe cache
if (this.state.ruleMemo) {
for (i=0, len=this.state.ruleMemo.length; i<len; i++) {
this.state.ruleMemo[i] = null;
}
}
},
/** Match current input symbol against ttype.  Attempt
*  single token insertion or deletion error recovery.  If
*  that fails, throw {@link org.antlr.runtime.MismatchedTokenException}.
*
*  <p>To turn off single token insertion or deletion error
*  recovery, override {@link #mismatchRecover} and have it call
*  plain {@link #mismatch}, which does not recover.  Then any error
*  in a rule will cause an exception and immediate exit from
*  rule.  Rule would recover by resynchronizing to the set of
*  symbols that can follow rule ref.</p>
*
*  @param {org.antlr.runtime.IntStream} input input stream to match against.
*  @param {Number} ttype  input type to match.
*  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
*      matched token.
*  @returns {Object} the matched symbol
*/
match: function(input, ttype, follow) {
var matchedSymbol = this.getCurrentInputSymbol(input);
if ( input.LA(1)===ttype ) {
input.consume();
this.state.errorRecovery = false;
this.state.failed = false;
return matchedSymbol;
}
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return matchedSymbol;
}
matchedSymbol = this.recoverFromMismatchedToken(input, ttype, follow);
return matchedSymbol;
},
/**
* Match any token.
* @param {org.antlr.runtime.IntStream} input input stream to match against.
*/
matchAny: function(input) {
this.state.errorRecovery = false;
this.state.failed = false;
input.consume();
},
/**
* Is the following token (LA(2)) the unwanted type (ttype)?
* @param {org.antlr.runtime.IntStream} input input stream to match against.
* @param {Number} ttype the undesired token type.
* @returns {Boolean} true if and only if the following token is the
*      unwanted type.
*/
mismatchIsUnwantedToken: function(input, ttype) {
return input.LA(2)===ttype;
},
/**
* Does the stream appear to be missing a single token?
* @param {org.antlr.runtime.IntStream} input input stream to match against.
* @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
*      matched token.
* @returns {Boolean} true if and only if it appears that the stream is
*      missing a single token.
*/
mismatchIsMissingToken: function(input, follow) {
if ( !follow ) {
// we have no information about the follow; we can only consume
// a single token and hope for the best
return false;
}
// compute what can follow this grammar element reference
if ( follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) ) {
if ( this.state._fsp>=0 ) { // remove EOR if we're not the start symbol
follow.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
}
var viableTokensFollowingThisRule = this.computeContextSensitiveRuleFOLLOW();
follow = follow.or(this.viableTokensFollowingThisRule);
}
// if current token is consistent with what could come after set
// then we know we're missing a token; error recovery is free to
// "insert" the missing token
// BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
// in follow set to indicate that the fall of the start symbol is
// in the set (EOF can follow).
if ( follow.member(input.LA(1)) ||
follow.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
{
return true;
}
return false;
},
/** Factor out what to do upon token mismatch so tree parsers can behave
*  differently.  Override and call {@link #mismatchRecover}
*  to get single token insertion and deletion.
*
*  @param {org.antlr.runtime.IntStream} input input stream to match against.
*  @param {Number} ttype  input type to match.
*  @param {org.antlr.runtime.BitSet} [follow] set of tokens that can follow the
*      matched token.
*/
mismatch: function(input, ttype, follow) {
if ( this.mismatchIsUnwantedToken(input, ttype) ) {
throw new org.antlr.runtime.UnwantedTokenException(ttype, input);
} else if ( this.mismatchIsMissingToken(input, follow) ) {
throw new org.antlr.runtime.MissingTokenException(ttype, input, null);
}
throw new org.antlr.runtime.MismatchedTokenException(ttype, input);
},
/** Report a recognition problem.
*
*  <p>This method sets errorRecovery to indicate the parser is recovering
*  not parsing.  Once in recovery mode, no errors are generated.
*  To get out of recovery mode, the parser must successfully match
*  a token (after a resync).  So it will go:</p>
*  <ol>
*      <li>error occurs</li>
*      <li>enter recovery mode, report error</li>
*      <li>consume until token found in resynch set</li>
*      <li>try to resume parsing</li>
*      <li>next match() will reset errorRecovery mode</li>
*  </ol>
*
*  <p>If you override, make sure to update this.state.syntaxErrors if you
*  care about that.</p>
*  @param {org.antlr.runtime.RecognitionException} e the error to be reported.
*/
reportError: function(e) {
// if we've already reported an error and have not matched a token
// yet successfully, don't report any errors.
if ( this.state.errorRecovery ) {
return;
}
this.state.syntaxErrors++;
this.state.errorRecovery = true;
this.displayRecognitionError(this.getTokenNames(), e);
},
/**
* Assemble recognition error message.
* @param {Array} tokenNames array of token names (strings).
* @param {org.antlr.runtime.RecognitionException} e the error to be reported.
*/
displayRecognitionError: function(tokenNames, e) {
var hdr = this.getErrorHeader(e),
msg = this.getErrorMessage(e, tokenNames);
this.emitErrorMessage(hdr+" "+msg);
},
/**
* Create error header message.  Format is <q>line
* lineNumber:positionInLine</q>.
* @param {org.antlr.runtime.RecognitionException} e the error to be reported.
* @returns {String} The error header.
*/
getErrorHeader: function(e) {
/* handle null input */
if (!org.antlr.lang.isNumber(e.line)) {
e.line = 0;
}
return "line "+e.line+":"+e.charPositionInLine;
},
/**
* Override this method to change where error messages go.
* Defaults to "alert"-ing the error in browsers and "print"-ing the error
* in other environments (e.g. Rhino, SpiderMonkey).
* @param {String} msg the error message to be displayed.
*/
emitErrorMessage: function(msg) {
if (typeof(window) != 'undefined' && window.alert) {
alert(msg);
} else if (console.warn) {
console.warn(msg);
} else {
print(msg);
}
},
/** What error message should be generated for the various
*  exception types?
*
*  <p>Not very object-oriented code, but I like having all error message
*  generation within one method rather than spread among all of the
*  exception classes. This also makes it much easier for the exception
*  handling because the exception classes do not have to have pointers back
*  to this object to access utility routines and so on. Also, changing
*  the message for an exception type would be difficult because you
*  would have to be subclassing exceptions, but then somehow get ANTLR
*  to make those kinds of exception objects instead of the default.</p>
*
*  <p>For grammar debugging, you will want to override this to add
*  more information such as the stack frame and no viable alts.</p>
*
*  <p>Override this to change the message generated for one or more
*  exception types.</p>
*
* @param {Array} tokenNames array of token names (strings).
* @param {org.antlr.runtime.RecognitionException} e the error to be reported.
* @returns {String} the error message to be emitted.
*/
getErrorMessage: function(e, tokenNames) {
var msg = (e && e.getMessage) ? e.getMessage() : null,
mte,
tokenName;
if ( e instanceof org.antlr.runtime.UnwantedTokenException ) {
var ute = e;
tokenName="<unknown>";
if ( ute.expecting== org.antlr.runtime.Token.EOF ) {
tokenName = "EOF";
} else {
tokenName = tokenNames[ute.expecting];
}
msg = "extraneous input "+this.getTokenErrorDisplay(ute.getUnexpectedToken())+
" expecting "+tokenName;
}
else if ( e instanceof org.antlr.runtime.MissingTokenException ) {
mte = e;
tokenName="<unknown>";
if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
tokenName = "EOF";
} else {
tokenName = tokenNames[mte.expecting];
}
msg = "missing "+tokenName+" at "+this.getTokenErrorDisplay(e.token);
}
else if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
mte = e;
tokenName="<unknown>";
if ( mte.expecting== org.antlr.runtime.Token.EOF ) {
tokenName = "EOF";
}
else {
tokenName = tokenNames[mte.expecting];
}
msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
" expecting "+tokenName;
}
else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
msg = "no viable alternative at input "+this.getTokenErrorDisplay(e.token);
}
else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
msg = "required (...)+ loop did not match anything at input "+
this.getTokenErrorDisplay(e.token);
}
else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
msg = "mismatched input "+this.getTokenErrorDisplay(e.token)+
" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.FailedPredicateException ) {
msg = "rule "+e.ruleName+" failed predicate: {"+
e.predicateText+"}?";
}
return msg;
},
/** Get number of recognition errors (lexer, parser, tree parser).  Each
*  recognizer tracks its own number.  So parser and lexer each have
*  separate count.  Does not count the spurious errors found between
*  an error and next valid token match
*
*  See also reportError()
*/
getNumberOfSyntaxErrors: function() {
return this.state.syntaxErrors;
},
/** How should a token be displayed in an error message? The default
*  is to display just the text, but during development you might
*  want to have a lot of information spit out.  Override in that case
*  to use t.toString() (which, for CommonToken, dumps everything about
*  the token). This is better than forcing you to override a method in
*  your token objects because you don't have to go modify your lexer
*  so that it creates a new Java type.
*/
getTokenErrorDisplay: function(t) {
var s = t.toString(); // t.getText();
if ( !org.antlr.lang.isValue(s) ) {
if ( t.getType()==org.antlr.runtime.Token.EOF ) {
s = "<EOF>";
}
else {
s = "<"+t.getType()+">";
}
}
s = s.replace(/\n/g,"\\n");
s = s.replace(/\r/g,"\\r");
s = s.replace(/\t/g,"\\t");
return "'"+s+"'";
},
/** Recover from an error found on the input stream.  This is
*  for NoViableAlt and mismatched symbol exceptions.  If you enable
*  single token insertion and deletion, this will usually not
*  handle mismatched symbol exceptions but there could be a mismatched
*  token that the match() routine could not recover from.
*/
recover: function(input, re) {
if ( this.state.lastErrorIndex==input.index() ) {
// uh oh, another error at same token index; must be a case
// where LT(1) is in the recovery token set so nothing is
// consumed; consume a single token so at least to prevent
// an infinite loop; this is a failsafe.
input.consume();
}
this.state.lastErrorIndex = input.index();
var followSet = this.computeErrorRecoverySet();
this.beginResync();
this.consumeUntil(input, followSet);
this.endResync();
},
/** A hook to listen in on the token consumption during error recovery.
*  The DebugParser subclasses this to fire events to the listenter.
*/
beginResync: function() {
},
endResync: function() {
},
/*  Compute the error recovery set for the current rule.  During
*  rule invocation, the parser pushes the set of tokens that can
*  follow that rule reference on the stack; this amounts to
*  computing FIRST of what follows the rule reference in the
*  enclosing rule. This local follow set only includes tokens
*  from within the rule; i.e., the FIRST computation done by
*  ANTLR stops at the end of a rule.
*
*  EXAMPLE
*
*  When you find a "no viable alt exception", the input is not
*  consistent with any of the alternatives for rule r.  The best
*  thing to do is to consume tokens until you see something that
*  can legally follow a call to r *or* any rule that called r.
*  You don't want the exact set of viable next tokens because the
*  input might just be missing a token--you might consume the
*  rest of the input looking for one of the missing tokens.
*
*  Consider grammar:
*
*  a : '[' b ']'
*    | '(' b ')'
*    ;
*  b : c '^' INT ;
*  c : ID
*    | INT
*    ;
*
*  At each rule invocation, the set of tokens that could follow
*  that rule is pushed on a stack.  Here are the various "local"
*  follow sets:
*
*  FOLLOW(b1_in_a) = FIRST(']') = ']'
*  FOLLOW(b2_in_a) = FIRST(')') = ')'
*  FOLLOW(c_in_b) = FIRST('^') = '^'
*
*  Upon erroneous input "[]", the call chain is
*
*  a -> b -> c
*
*  and, hence, the follow context stack is:
*
*  depth  local follow set     after call to rule
*    0         <EOF>                    a (from main())
*    1          ']'                     b
*    3          '^'                     c
*
*  Notice that ')' is not included, because b would have to have
*  been called from a different context in rule a for ')' to be
*  included.
*
*  For error recovery, we cannot consider FOLLOW(c)
*  (context-sensitive or otherwise).  We need the combined set of
*  all context-sensitive FOLLOW sets--the set of all tokens that
*  could follow any reference in the call chain.  We need to
*  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
*  we resync'd to that token, we'd consume until EOF.  We need to
*  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
*  In this case, for input "[]", LA(1) is in this set so we would
*  not consume anything and after printing an error rule c would
*  return normally.  It would not find the required '^' though.
*  At this point, it gets a mismatched token error and throws an
*  exception (since LA(1) is not in the viable following token
*  set).  The rule exception handler tries to recover, but finds
*  the same recovery set and doesn't consume anything.  Rule b
*  exits normally returning to rule a.  Now it finds the ']' (and
*  with the successful match exits errorRecovery mode).
*
*  So, you cna see that the parser walks up call chain looking
*  for the token that was a member of the recovery set.
*
*  Errors are not generated in errorRecovery mode.
*
*  ANTLR's error recovery mechanism is based upon original ideas:
*
*  "Algorithms + Data Structures = Programs" by Niklaus Wirth
*
*  and
*
*  "A note on error recovery in recursive descent parsers":
*  http://portal.acm.org/citation.cfm?id=947902.947905
*
*  Later, Josef Grosch had some good ideas:
*
*  "Efficient and Comfortable Error Recovery in Recursive Descent
*  Parsers":
*  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
*
*  Like Grosch I implemented local FOLLOW sets that are combined
*  at run-time upon error to avoid overhead during parsing.
*/
computeErrorRecoverySet: function() {
return this.combineFollows(false);
},
/** Compute the context-sensitive FOLLOW set for current rule.
*  This is set of token types that can follow a specific rule
*  reference given a specific call chain.  You get the set of
*  viable tokens that can possibly come next (lookahead depth 1)
*  given the current call chain.  Contrast this with the
*  definition of plain FOLLOW for rule r:
*
*   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
*
*  where x in T* and alpha, beta in V*; T is set of terminals and
*  V is the set of terminals and nonterminals.  In other words,
*  FOLLOW(r) is the set of all tokens that can possibly follow
*  references to r in *any* sentential form (context).  At
*  runtime, however, we know precisely which context applies as
*  we have the call chain.  We may compute the exact (rather
*  than covering superset) set of following tokens.
*
*  For example, consider grammar:
*
*  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
*       | "return" expr '.'
*       ;
*  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
*  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
*       | '(' expr ')'
*       ;
*
*  The FOLLOW sets are all inclusive whereas context-sensitive
*  FOLLOW sets are precisely what could follow a rule reference.
*  For input input "i=(3);", here is the derivation:
*
*  stat => ID '=' expr ';'
*       => ID '=' atom ('+' atom)* ';'
*       => ID '=' '(' expr ')' ('+' atom)* ';'
*       => ID '=' '(' atom ')' ('+' atom)* ';'
*       => ID '=' '(' INT ')' ('+' atom)* ';'
*       => ID '=' '(' INT ')' ';'
*
*  At the "3" token, you'd have a call chain of
*
*    stat -> expr -> atom -> expr -> atom
*
*  What can follow that specific nested ref to atom?  Exactly ')'
*  as you can see by looking at the derivation of this specific
*  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
*
*  You want the exact viable token set when recovering from a
*  token mismatch.  Upon token mismatch, if LA(1) is member of
*  the viable next token set, then you know there is most likely
*  a missing token in the input stream.  "Insert" one by just not
*  throwing an exception.
*/
computeContextSensitiveRuleFOLLOW: function() {
return this.combineFollows(true);
},
combineFollows: function(exact) {
var top = this.state._fsp,
i,
localFollowSet,
followSet = new org.antlr.runtime.BitSet();
for (i=top; i>=0; i--) {
localFollowSet = this.state.following[i];
followSet.orInPlace(localFollowSet);
if ( exact ) {
// can we see end of rule?
if ( localFollowSet.member(org.antlr.runtime.Token.EOR_TOKEN_TYPE) )
{
// Only leave EOR in set if at top (start rule); this lets
// us know if have to include follow(start rule); i.e., EOF
if ( i>0 ) {
followSet.remove(org.antlr.runtime.Token.EOR_TOKEN_TYPE);
}
}
else { // can't see end of rule, quit
break;
}
}
}
return followSet;
},
/** Attempt to recover from a single missing or extra token.
*
*  EXTRA TOKEN
*
*  LA(1) is not what we are looking for.  If LA(2) has the right token,
*  however, then assume LA(1) is some extra spurious token.  Delete it
*  and LA(2) as if we were doing a normal match(), which advances the
*  input.
*
*  MISSING TOKEN
*
*  If current token is consistent with what could come after
*  ttype then it is ok to "insert" the missing token, else throw
*  exception For example, Input "i=(3;" is clearly missing the
*  ')'.  When the parser returns from the nested call to expr, it
*  will have call chain:
*
*    stat -> expr -> atom
*
*  and it will be trying to match the ')' at this point in the
*  derivation:
*
*       => ID '=' '(' INT ')' ('+' atom)* ';'
*                          ^
*  match() will see that ';' doesn't match ')' and report a
*  mismatched token error.  To recover, it sees that LA(1)==';'
*  is in the set of tokens that can follow the ')' token
*  reference in rule atom.  It can assume that you forgot the ')'.
*/
recoverFromMismatchedToken: function(input,
ttype,
follow)
{
var e = null;
// if next token is what we are looking for then "delete" this token
if ( this.mismatchIsUnwantedToken(input, ttype) ) {
e = new org.antlr.runtime.UnwantedTokenException(ttype, input);
this.beginResync();
input.consume(); // simply delete extra token
this.endResync();
this.reportError(e);  // report after consuming so AW sees the token in the exception
// we want to return the token we're actually matching
var matchedSymbol = this.getCurrentInputSymbol(input);
input.consume(); // move past ttype token as if all were ok
return matchedSymbol;
}
// can't recover with single token deletion, try insertion
if ( this.mismatchIsMissingToken(input, follow) ) {
var inserted = this.getMissingSymbol(input, e, ttype, follow);
e = new org.antlr.runtime.MissingTokenException(ttype, input, inserted);
this.reportError(e);  // report after inserting so AW sees the token in the exception
return inserted;
}
// even that didn't work; must throw the exception
e = new org.antlr.runtime.MismatchedTokenException(ttype, input);
throw e;
},
recoverFromMismatchedSet: function(input,
e,
follow)
{
if ( this.mismatchIsMissingToken(input, follow) ) {
// System.out.println("missing token");
this.reportError(e);
// we don't know how to conjure up a token for sets yet
return this.getMissingSymbol(input, e, org.antlr.runtime.Token.INVALID_TOKEN_TYPE, follow);
}
throw e;
},
/** Match needs to return the current input symbol, which gets put
*  into the label for the associated token ref; e.g., x=ID.  Token
*  and tree parsers need to return different objects. Rather than test
*  for input stream type or change the IntStream interface, I use
*  a simple method to ask the recognizer to tell me what the current
*  input symbol is.
* 
*  This is ignored for lexers.
*/
getCurrentInputSymbol: function(input) { return null; },
/** Conjure up a missing token during error recovery.
*
*  The recognizer attempts to recover from single missing
*  symbols. But, actions might refer to that missing symbol.
*  For example, x=ID {f($x);}. The action clearly assumes
*  that there has been an identifier matched previously and that
*  $x points at that token. If that token is missing, but
*  the next token in the stream is what we want we assume that
*  this token is missing and we keep going. Because we
*  have to return some token to replace the missing token,
*  we have to conjure one up. This method gives the user control
*  over the tokens returned for missing tokens. Mostly,
*  you will want to create something special for identifier
*  tokens. For literals such as '{' and ',', the default
*  action in the parser or tree parser works. It simply creates
*  a CommonToken of the appropriate type. The text will be the token.
*  If you change what tokens must be created by the lexer,
*  override this method to create the appropriate tokens.
*/
getMissingSymbol: function(input,
e,
expectedTokenType,
follow)
{
return null;
},
/** Consume tokens until one matches the given token set */
consumeUntil: function(input, set) {
var ttype = input.LA(1);
while (ttype != org.antlr.runtime.Token.EOF && !set.member(ttype) ) {
input.consume();
ttype = input.LA(1);
}
},
/** Push a rule's follow set using our own hardcoded stack */
pushFollow: function(fset) {
if ( (this.state._fsp +1)>=this.state.following.length ) {
var f = [];
var i;
for (i=this.state.following.length-1; i>=0; i--) {
f[i] = this.state.following[i];
}
this.state.following = f;
}
this.state._fsp++;
this.state.following[this.state._fsp] = fset;
},
/** Return List<String> of the rules in your parser instance
*  leading up to a call to this method.  You could override if
*  you want more details such as the file/line info of where
*  in the parser java code a rule is invoked.
*
*  This is very useful for error messages and for context-sensitive
*  error recovery.
*
*  A more general version of getRuleInvocationStack where you can
*  pass in, for example, a RecognitionException to get it's rule
*  stack trace.  This routine is shared with all recognizers, hence,
*  static.
*
*  TODO: move to a utility class or something; weird having lexer call this
*
*  Most JS interpreters can't do real stack reflection.  See this
*  spidermonkey bug, for example:
*  https://bugzilla.mozilla.org/show_bug.cgi?id=332104
*
*  JS is supposed to get real stack traces in v4, at which time it would
*  be easy to implement this function.
*
*  Until then I'll leave this unimplemented.  If there is enough clamor
*  it would be possible to keep track of the invocation stack using an
*  auxillary array, but that will definitely be a performance hit.
*/
getRuleInvocationStack: function(e, recognizerClassName)
{
throw new Error("Not implemented.");
},
getBacktrackingLevel: function() {
return this.state.backtracking;
},
/** Used to print out token names like ID during debugging and
*  error reporting.  The generated parsers implement a method
*  that overrides this to point to their String[] tokenNames.
*/
getTokenNames: function() {
return null;
},
/** For debugging and other purposes, might want the grammar name.
*  Have ANTLR generate an implementation for this method.
*/
getGrammarFileName: function() {
return null;
},
/** A convenience method for use most often with template rewrites.
*  Convert a List<Token> to List<String>
*/
toStrings: function(tokens) {
if ( !tokens ) {
return null;
}
var strings = [];
var i;
for (i=0; i<tokens.length; i++) {
strings.push(tokens[i].getText());
}
return strings;
},
/** Given a rule number and a start token index number, return
*  MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
*  start index.  If this rule has parsed input starting from the
*  start index before, then return where the rule stopped parsing.
*  It returns the index of the last token matched by the rule.
*
*  For now we use a hashtable and just the slow Object-based one.
*  Later, we can make a special one for ints and also one that
*  tosses out data after we commit past input position i.
*/
getRuleMemoization: function(ruleIndex, ruleStartIndex) {
if ( !this.state.ruleMemo[ruleIndex] ) {
this.state.ruleMemo[ruleIndex] = {};
}
var stopIndexI =
this.state.ruleMemo[ruleIndex][ruleStartIndex];
if ( !org.antlr.lang.isNumber(stopIndexI) ) {
return org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN;
}
return stopIndexI;
},
/** Has this rule already parsed input at the current index in the
*  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
*  If we attempted but failed to parse properly before, return
*  MEMO_RULE_FAILED.
*
*  This method has a side-effect: if we have seen this input for
*  this rule and successfully parsed before, then seek ahead to
*  1 past the stop token matched for this rule last time.
*/
alreadyParsedRule: function(input, ruleIndex) {
var stopIndex = this.getRuleMemoization(ruleIndex, input.index());
if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_UNKNOWN ) {
return false;
}
if ( stopIndex==org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED ) {
//System.out.println("rule "+ruleIndex+" will never succeed");
this.state.failed=true;
}
else {
input.seek(stopIndex+1); // jump to one past stop token
}
return true;
},
/** Record whether or not this rule parsed the input at this position
*  successfully.  Use a standard java hashtable for now.
*/
memoize: function(input,
ruleIndex,
ruleStartIndex)
{
var stopTokenIndex = this.state.failed ? 
org.antlr.runtime.BaseRecognizer.MEMO_RULE_FAILED : input.index()-1;
if ( !org.antlr.lang.isValue(this.state.ruleMemo) ) {
throw new Error("!!!!!!!!! memo array is null for "+ this.getGrammarFileName());
}
if ( ruleIndex >= this.state.ruleMemo.length ) {
throw new Error("!!!!!!!!! memo size is "+this.state.ruleMemo.length+", but rule index is "+ruleIndex);
}
if ( org.antlr.lang.isValue(this.state.ruleMemo[ruleIndex]) ) {
this.state.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex;
}
},
/** return how many rule/input-index pairs there are in total.
*  TODO: this includes synpreds.
*/
getRuleMemoizationCacheSize: function() {
var n = 0, i;
for (i = 0; this.state.ruleMemo && i < this.state.ruleMemo.length; i++) {
var ruleMap = this.state.ruleMemo[i];
if ( ruleMap ) {
// @todo need to get size of rulemap?
n += ruleMap.length; // how many input indexes are recorded?
}
}
return n;
},
traceIn: function(ruleName, ruleIndex, inputSymbol)  {
this.emitErrorMessage("enter "+ruleName+" "+inputSymbol);
if ( this.state.failed ) {
this.emitErrorMessage(" failed="+this.failed);
}
if ( this.state.backtracking>0 ) {
this.emitErrorMessage(" backtracking="+this.state.backtracking);
}
// System.out.println();
},
traceOut: function(ruleName, ruleIndex, inputSymbol) {
this.emitErrorMessage("exit "+ruleName+" "+inputSymbol);
if ( this.state.failed ) {
this.emitErrorMessage(" failed="+this.state.failed);
}
if ( this.state.backtracking>0 ) {
this.emitErrorMessage(" backtracking="+this.state.backtracking);
}
}
};
/** A lexer is recognizer that draws input symbols from a character stream.
*  lexer grammars result in a subclass of this object. A Lexer object
*  uses simplified match() and error recovery mechanisms in the interest
*  of speed.
*/
org.antlr.runtime.Lexer = function(input, state) {
if (state) {
org.antlr.runtime.Lexer.superclass.constructor.call(this, state);
}
if (input) {
this.input = input;
}
};
org.antlr.lang.extend(org.antlr.runtime.Lexer, org.antlr.runtime.BaseRecognizer, {
reset: function() {
// reset all recognizer state variables
org.antlr.runtime.Lexer.superclass.reset.call(this);
if ( org.antlr.lang.isValue(this.input) ) {
this.input.seek(0); // rewind the input
}
if ( !org.antlr.lang.isValue(this.state) ) {
return; // no shared state work to do
}
this.state.token = null;
this.state.type = org.antlr.runtime.Token.INVALID_TOKEN_TYPE;
this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
this.state.tokenStartCharIndex = -1;
this.state.tokenStartCharPositionInLine = -1;
this.state.tokenStartLine = -1;
this.state.text = null;
},
/** Return a token from this source; i.e., match a token on the char
*  stream.
*/
nextToken: function() {
while (true) {
this.state.token = null;
this.state.channel = org.antlr.runtime.Token.DEFAULT_CHANNEL;
this.state.tokenStartCharIndex = this.input.index();
this.state.tokenStartCharPositionInLine = this.input.getCharPositionInLine();
this.state.tokenStartLine = this.input.getLine();
this.state.text = null;
if ( this.input.LA(1)===org.antlr.runtime.CharStream.EOF ) {
return org.antlr.runtime.Token.EOF_TOKEN;
}
try {
this.mTokens();
if ( !org.antlr.lang.isValue(this.state.token) ) {
this.emit();
}
else if ( this.state.token==org.antlr.runtime.Token.SKIP_TOKEN ) {
continue;
}
return this.state.token;
}
catch (re) {
if ( re instanceof org.antlr.runtime.RecognitionException ) {
this.reportError(re);
} else if (re instanceof org.antlr.runtime.NoViableAltException) {
this.reportError(re);
this.recover(re);
} else {
throw re;
}
}
}
},
/** Instruct the lexer to skip creating a token for current lexer rule
*  and look for another token.  nextToken() knows to keep looking when
*  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
*  if token==null at end of any token rule, it creates one for you
*  and emits it.
*/
skip: function() {
this.state.token = org.antlr.runtime.Token.SKIP_TOKEN;
},
/** Set the char stream and reset the lexer */
setCharStream: function(input) {
this.input = null;
this.reset();
this.input = input;
},
getCharStream: function() {
return this.input;
},
getSourceName: function() {
return this.input.getSourceName();
},
/** Currently does not support multiple emits per nextToken invocation
*  for efficiency reasons.  Subclass and override this method and
*  nextToken (to push tokens into a list and pull from that list rather
*  than a single variable as this implementation does).
*
*  The standard method called to automatically emit a token at the
*  outermost lexical rule.  The token object should point into the
*  char buffer start..stop.  If there is a text override in 'text',
*  use that to set the token's text.  Override this method to emit
*  custom Token objects.
*
*  If you are building trees, then you should also override
*  Parser or TreeParser.getMissingSymbol().
*/
emit: function() {
if (arguments.length===0) {
var t = new org.antlr.runtime.CommonToken(this.input, this.state.type, this.state.channel, this.state.tokenStartCharIndex, this.getCharIndex()-1);
t.setLine(this.state.tokenStartLine);
t.setText(this.state.text);
t.setCharPositionInLine(this.state.tokenStartCharPositionInLine);
this.state.token = t;
return t;
} else {
this.state.token = arguments[0];
}
},
match: function(s) {
var i = 0,
mte;
if (org.antlr.lang.isString(s)) {
while ( i<s.length ) {
if ( this.input.LA(1)!=s.charAt(i) ) {
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return;
}
mte = new org.antlr.runtime.MismatchedTokenException(s.charAt(i), this.input);
this.recover(mte);
throw mte;
}
i++;
this.input.consume();
this.state.failed = false;
}
} else if (org.antlr.lang.isNumber(s)) {
if ( this.input.LA(1)!=s ) {
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return;
}
mte = new org.antlr.runtime.MismatchedTokenException(s, this.input);
this.recover(mte);
throw mte;
}
this.input.consume();
this.state.failed = false;
}
},
matchAny: function() {
this.input.consume();
},
matchRange: function(a, b) {
if ( this.input.LA(1)<a || this.input.LA(1)>b ) {
if ( this.state.backtracking>0 ) {
this.state.failed = true;
return;
}
mre = new org.antlr.runtime.MismatchedRangeException(a,b,this.input);
this.recover(mre);
throw mre;
}
this.input.consume();
this.state.failed = false;
},
getLine: function() {
return this.input.getLine();
},
getCharPositionInLine: function() {
return this.input.getCharPositionInLine();
},
/** What is the index of the current character of lookahead? */
getCharIndex: function() {
return this.input.index();
},
/** Return the text matched so far for the current token or any
*  text override.
*/
getText: function() {
if ( org.antlr.lang.isString(this.state.text) ) {
return this.state.text;
}
return this.input.substring(this.state.tokenStartCharIndex,this.getCharIndex()-1);
},
/** Set the complete text of this token; it wipes any previous
*  changes to the text.
*/
setText: function(text) {
this.state.text = text;
},
reportError: function(e) {
/** TODO: not thought about recovery in lexer yet.
*
// if we've already reported an error and have not matched a token
// yet successfully, don't report any errors.
if ( errorRecovery ) {
//System.err.print("[SPURIOUS] ");
return;
}
errorRecovery = true;
*/
this.displayRecognitionError(this.getTokenNames(), e);
},
getErrorMessage: function(e, tokenNames) {
var msg = null;
if ( e instanceof org.antlr.runtime.MismatchedTokenException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting "+this.getCharErrorDisplay(e.expecting);
}
else if ( e instanceof org.antlr.runtime.NoViableAltException ) {
msg = "no viable alternative at character "+this.getCharErrorDisplay(e.c);
}
else if ( e instanceof org.antlr.runtime.EarlyExitException ) {
msg = "required (...)+ loop did not match anything at character "+this.getCharErrorDisplay(e.c);
}
else if ( e instanceof org.antlr.runtime.MismatchedNotSetException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.MismatchedSetException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+e.expecting;
}
else if ( e instanceof org.antlr.runtime.MismatchedRangeException ) {
msg = "mismatched character "+this.getCharErrorDisplay(e.c)+" expecting set "+
this.getCharErrorDisplay(e.a)+".."+this.getCharErrorDisplay(e.b);
}
else {
msg = org.antlr.runtime.Lexer.superclass.getErrorMessage.call(this, e, tokenNames);
}
return msg;
},
getCharErrorDisplay: function(c) {
var s = c; //String.fromCharCode(c);
switch ( s ) {
case org.antlr.runtime.Token.EOF :
s = "<EOF>";
break;
case "\n" :
s = "\\n";
break;
case "\t" :
s = "\\t";
break;
case "\r" :
s = "\\r";
break;
}
return "'"+s+"'";
},
/** Lexers can normally match any char in it's vocabulary after matching
*  a token, so do the easy thing and just kill a character and hope
*  it all works out.  You can instead use the rule invocation stack
*  to do sophisticated error recovery if you are in a fragment rule.
*/
recover: function(re) {
this.input.consume();
},
traceIn: function(ruleName, ruleIndex)  {
var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
org.antlr.runtime.Lexer.superclass.traceIn.call(this, ruleName, ruleIndex, inputSymbol);
},
traceOut: function(ruleName, ruleIndex)  {
var inputSymbol = String.fromCharCode(this.input.LT(1))+" line="+this.getLine()+":"+this.getCharPositionInLine();
org.antlr.runtime.Lexer.superclass.traceOut.call(this, ruleName, ruleIndex, inputSymbol);
}
});
/** Rules that return more than a single value must return an object
*  containing all the values.  Besides the properties defined in
*  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
*  return values.  This class simply defines the minimum properties that
*  are always defined and methods to access the others that might be
*  available depending on output option such as template and tree.
*
*  Note text is not an actual property of the return value, it is computed
*  from start and stop using the input stream's toString() method.  I
*  could add a ctor to this so that we can pass in and store the input
*  stream, but I'm not sure we want to do that.  It would seem to be undefined
*  to get the .text property anyway if the rule matches tokens from multiple
*  input streams.
*
*  I do not use getters for fields of objects that are used simply to
*  group values such as this aggregate.  The getters/setters are there to
*  satisfy the superclass interface.
*/
org.antlr.runtime.ParserRuleReturnScope = function() {};
org.antlr.runtime.ParserRuleReturnScope.prototype = {
getStart: function() { return this.start; },
getStop: function() { return this.stop; }
};
/** This is identical to the ParserRuleReturnScope except that
*  the start property is a tree nodes not Token object
*  when you are parsing trees.  To be generic the tree node types
*  have to be Object.
*/
org.antlr.runtime.tree.TreeRuleReturnScope = function(){};
org.antlr.runtime.tree.TreeRuleReturnScope.prototype = {
getStart: function() { return this.start; }
};
/** A parser for TokenStreams.  "parser grammars" result in a subclass
*  of this.
*/
org.antlr.runtime.Parser = function(input, state) {
org.antlr.runtime.Parser.superclass.constructor.call(this, state);
this.setTokenStream(input);
};
org.antlr.lang.extend(org.antlr.runtime.Parser, org.antlr.runtime.BaseRecognizer, {
reset: function() {
// reset all recognizer state variables
org.antlr.runtime.Parser.superclass.reset.call(this);
if ( org.antlr.lang.isValue(this.input) ) {
this.input.seek(0); // rewind the input
}
},
getCurrentInputSymbol: function(input) {
return input.LT(1);
},
getMissingSymbol: function(input,
e,
expectedTokenType,
follow)
{
var tokenText =
"<missing "+this.getTokenNames()[expectedTokenType]+">";
var t = new org.antlr.runtime.CommonToken(expectedTokenType, tokenText);
var current = input.LT(1);
var old_current;
if ( current.getType() === org.antlr.runtime.Token.EOF ) {
old_current = current;
current = input.LT(-1);
// handle edge case where there are no good tokens in the stream
if (!current) {
current = old_current;
}
}
t.line = current.getLine();
t.charPositionInLine = current.getCharPositionInLine();
t.channel = org.antlr.runtime.BaseRecognizer.DEFAULT_TOKEN_CHANNEL;
return t;
},
/** Set the token stream and reset the parser */
setTokenStream: function(input) {
this.input = null;
this.reset();
this.input = input;
},
getTokenStream: function() {
return this.input;
},
getSourceName: function() {
return this.input.getSourceName();
},
traceIn: function(ruleName, ruleIndex)  {
org.antlr.runtime.Parser.superclass.traceIn.call(
this, ruleName, ruleIndex, this.input.LT(1));
},
traceOut: function(ruleName, ruleIndex)  {
org.antlr.runtime.Parser.superclass.traceOut.call(
this, ruleName, ruleIndex, this.input.LT(1));
}
});
/** A DFA implemented as a set of transition tables.
*
*  Any state that has a semantic predicate edge is special; those states
*  are generated with if-then-else structures in a specialStateTransition()
*  which is generated by cyclicDFA template.
*
*  There are at most 32767 states (16-bit signed short).
*  Could get away with byte sometimes but would have to generate different
*  types and the simulation code too.  For a point of reference, the Java
*  lexer's Tokens rule DFA has 326 states roughly.
*/
org.antlr.runtime.DFA = function() {};
org.antlr.runtime.DFA.prototype = {
/** From the input stream, predict what alternative will succeed
*  using this DFA (representing the covering regular approximation
*  to the underlying CFL).  Return an alternative number 1..n.  Throw
*  an exception upon error.
*/
predict: function(input) {
var mark = input.mark(), // remember where decision started in input
s = 0, // we always start at s0
specialState,
c,
snext;
try {
while ( true ) {
specialState = this.special[s];
if ( specialState>=0 ) {
s = this.specialStateTransition(specialState,input);
if (s===-1) {
this.noViableAlt(s, input);
return 0;
}
input.consume();
continue;
}
if ( this.accept[s] >= 1 ) {
return this.accept[s];
}
// look for a normal char transition
c = input.LA(1); // -1 == \uFFFF, all tokens fit in 65000 space
if (c===org.antlr.runtime.Token.EOF) {
c = -1;
} else if (org.antlr.lang.isString(c)) {
c = c.charCodeAt(0);
}
if (c>=this.min[s] && c<=this.max[s]) {
snext = this.transition[s][c-this.min[s]]; // move to next state
if ( snext < 0 ) {
// was in range but not a normal transition
// must check EOT, which is like the else clause.
// eot[s]>=0 indicates that an EOT edge goes to another
// state.
if ( this.eot[s]>=0 ) {  // EOT Transition to accept state?
s = this.eot[s];
input.consume();
// TODO: I had this as return accept[eot[s]]
// which assumed here that the EOT edge always
// went to an accept...faster to do this, but
// what about predicated edges coming from EOT
// target?
continue;
}
this.noViableAlt(s,input);
return 0;
}
s = snext;
input.consume();
continue;
}
if ( this.eot[s]>=0 ) {  // EOT Transition?
s = this.eot[s];
input.consume();
continue;
}
if ( c==org.antlr.runtime.Token.EOF && this.eof[s]>=0 ) {  // EOF Transition to accept state?
return this.accept[this.eof[s]];
}
// not in range and not EOF/EOT, must be invalid symbol
this.noViableAlt(s,input);
return 0;
}
}
finally {
input.rewind(mark);
}
},
noViableAlt: function(s, input) {
if (this.recognizer.state.backtracking>0) {
this.recognizer.state.failed=true;
return;
}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(),
this.decisionNumber,
s,
input);
this.error(nvae);
throw nvae;
},
/** A hook for debugging interface */
error: function(nvae) { },
specialStateTransition: function(s, input) {
return -1;
},
getDescription: function() {
return "n/a";
}
};
org.antlr.lang.augmentObject(org.antlr.runtime.DFA, {
/** Given a String that has a run-length-encoding of some unsigned shorts
*  like "\1\2\3\9", convert to short[] {2,9,9,9}.
*/
unpackEncodedString: function(encodedString) {
// walk first to find how big it is.
var i,
data = [],
di = 0,
n,
v,
j;
for (i=0; i<encodedString.length; i+=2) {
n = encodedString.charCodeAt(i);
v = encodedString.charCodeAt(i+1);
if (v===0xffff) {
v = -1; // overflow at 16 bits
}
// add v n times to data
for (j=1; j<=n; j++) {
data[di++] = v;
}
}
return data;
},
// alias
unpackEncodedStringToUnsignedChars: function(encodedString) {
return org.antlr.runtime.DFA.unpackEncodedString(encodedString);
}
});
/** A parser for a stream of tree nodes.  "tree grammars" result in a subclass
*  of this.  All the error reporting and recovery is shared with Parser via
*  the BaseRecognizer superclass.
*/
org.antlr.runtime.tree.TreeParser = function(input) {
org.antlr.runtime.tree.TreeParser.superclass.constructor.call(this, arguments[1]);
this.setTreeNodeStream(input);
};
(function(){
var TP = org.antlr.runtime.tree.TreeParser;
org.antlr.lang.augmentObject(TP, {
DOWN: org.antlr.runtime.Token.DOWN,
UP: org.antlr.runtime.Token.UP
});
org.antlr.lang.extend(TP, org.antlr.runtime.BaseRecognizer, {
reset: function() {
TP.superclass.reset.call(this); // reset all recognizer state variables
if ( this.input ) {
this.input.seek(0); // rewind the input
}
},
/** Set the input stream */
setTreeNodeStream: function(input) {
this.input = input;
},
getTreeNodeStream: function() {
return this.input;
},
getSourceName: function() {
return this.input.getSourceName();
},
getCurrentInputSymbol: function(input) {
return input.LT(1);
},
getMissingSymbol: function(input, e, expectedTokenType, follow) {
var tokenText =
"<missing "+this.getTokenNames()[expectedTokenType]+">";
return new org.antlr.runtime.tree.CommonTree(new org.antlr.runtime.CommonToken(expectedTokenType, tokenText));
},
/** Match '.' in tree parser has special meaning.  Skip node or
*  entire tree if node has children.  If children, scan until
*  corresponding UP node.
*/
matchAny: function(ignore) { // ignore stream, copy of this.input
this.state.errorRecovery = false;
this.state.failed = false;
var look = this.input.LT(1);
if ( this.input.getTreeAdaptor().getChildCount(look)===0 ) {
this.input.consume(); // not subtree, consume 1 node and return
return;
}
// current node is a subtree, skip to corresponding UP.
// must count nesting level to get right UP
var level=0,
tokenType = this.input.getTreeAdaptor().getType(look);
while ( tokenType!==org.antlr.runtime.Token.EOF &&
!(tokenType===TP.UP && level===0) )
{
this.input.consume();
look = this.input.LT(1);
tokenType = this.input.getTreeAdaptor().getType(look);
if ( tokenType === TP.DOWN ) {
level++;
}
else if ( tokenType === TP.UP ) {
level--;
}
}
this.input.consume(); // consume UP
},
/** We have DOWN/UP nodes in the stream that have no line info; override.
*  plus we want to alter the exception type.  Don't try to recover
*       *  from tree parser errors inline...
*/
mismatch: function(input, ttype, follow) {
throw new org.antlr.runtime.MismatchedTreeNodeException(ttype, input);
},
/** Prefix error message with the grammar name because message is
*  always intended for the programmer because the parser built
*  the input tree not the user.
*/
getErrorHeader: function(e) {
return this.getGrammarFileName()+": node from "+
(e.approximateLineInfo?"after ":"")+"line "+e.line+":"+e.charPositionInLine;
},
/** Tree parsers parse nodes they usually have a token object as
*  payload. Set the exception token and do the default behavior.
*/
getErrorMessage: function(e, tokenNames) {
var adaptor;
if ( this instanceof TP ) {
adaptor = e.input.getTreeAdaptor();
e.token = adaptor.getToken(e.node);
if ( !org.antlr.lang.isValue(e.token) ) { // could be an UP/DOWN node
e.token = new org.antlr.runtime.CommonToken(
adaptor.getType(e.node),
adaptor.getText(e.node));
}
}
return TP.superclass.getErrorMessage.call(this, e, tokenNames);
},
traceIn: function(ruleName, ruleIndex) {
TP.superclass.traceIn.call(this, ruleName, ruleIndex, this.input.LT(1));
},
traceOut: function(ruleName, ruleIndex) {
TP.superclass.traceOut.call(this, ruleName, ruleIndex, this.input.LT(1));
}
});
})();
//-------- js/Ham4Parser.js --------
// $ANTLR 3.3 Nov 30, 2010 12:50:56 Ham4Parser.g 2020-05-16 18:26:33
// Parser header: Start
// Logger enhanced when run from HtoG Tool
var H4PLogger = this.getCWAEnv().get("Logger").get("SiGML");
// Parser header: End
var Ham4Parser = function(input, state) {
if (!state) {
state = new org.antlr.runtime.RecognizerSharedState();
}
(function(){
// Parser members
var errorCount = 0;
var errorString = "";
this.reportError = function(ex) {
if (typeof H4PLogger.warn === "function") H4PLogger.warn("Parsing Error: " + ex);
var pfx = errorCount == 0 ? "" : "\n";
errorCount++;
errorString += pfx + "[" + ex + "]";
}
this.trace = function(str) {
if (typeof H4PLogger.trace === "function") H4PLogger.trace(str);
};
this.checkErrors = function() {
if (errorCount == 0)
return null
else
return { errCount: errorCount, errText: errorString };
}
// //########  BEGIN GENERATED CODE  ########
}).call(this);
Ham4Parser.superclass.constructor.call(this, input, state);
this.dfa13 = new Ham4Parser.DFA13(this);
this.dfa14 = new Ham4Parser.DFA14(this);
this.dfa16 = new Ham4Parser.DFA16(this);
this.dfa15 = new Ham4Parser.DFA15(this);
this.dfa18 = new Ham4Parser.DFA18(this);
this.dfa21 = new Ham4Parser.DFA21(this);
this.dfa25 = new Ham4Parser.DFA25(this);
this.dfa23 = new Ham4Parser.DFA23(this);
this.dfa26 = new Ham4Parser.DFA26(this);
this.dfa33 = new Ham4Parser.DFA33(this);
this.dfa34 = new Ham4Parser.DFA34(this);
this.dfa35 = new Ham4Parser.DFA35(this);
this.dfa36 = new Ham4Parser.DFA36(this);
this.dfa49 = new Ham4Parser.DFA49(this);
this.dfa54 = new Ham4Parser.DFA54(this);
this.dfa56 = new Ham4Parser.DFA56(this);
this.dfa57 = new Ham4Parser.DFA57(this);
this.dfa58 = new Ham4Parser.DFA58(this);
this.dfa59 = new Ham4Parser.DFA59(this);
this.dfa60 = new Ham4Parser.DFA60(this);
this.dfa61 = new Ham4Parser.DFA61(this);
this.dfa92 = new Ham4Parser.DFA92(this);
this.dfa93 = new Ham4Parser.DFA93(this);
this.dfa95 = new Ham4Parser.DFA95(this);
this.dfa98 = new Ham4Parser.DFA98(this);
this.dfa97 = new Ham4Parser.DFA97(this);
this.dfa96 = new Ham4Parser.DFA96(this);
this.dfa102 = new Ham4Parser.DFA102(this);
this.dfa103 = new Ham4Parser.DFA103(this);
this.dfa104 = new Ham4Parser.DFA104(this);
this.dfa105 = new Ham4Parser.DFA105(this);
this.dfa106 = new Ham4Parser.DFA106(this);
this.dfa107 = new Ham4Parser.DFA107(this);
this.dfa108 = new Ham4Parser.DFA108(this);
this.dfa111 = new Ham4Parser.DFA111(this);
this.dfa109 = new Ham4Parser.DFA109(this);
this.dfa110 = new Ham4Parser.DFA110(this);
this.dfa112 = new Ham4Parser.DFA112(this);
this.dfa113 = new Ham4Parser.DFA113(this);
this.dfa114 = new Ham4Parser.DFA114(this);
this.dfa115 = new Ham4Parser.DFA115(this);
this.dfa116 = new Ham4Parser.DFA116(this);
this.dfa127 = new Ham4Parser.DFA127(this);
this.dfa128 = new Ham4Parser.DFA128(this);
this.dfa129 = new Ham4Parser.DFA129(this);
this.dfa130 = new Ham4Parser.DFA130(this);
this.dfa131 = new Ham4Parser.DFA131(this);
this.dfa132 = new Ham4Parser.DFA132(this);
this.dfa133 = new Ham4Parser.DFA133(this);
this.dfa134 = new Ham4Parser.DFA134(this);
this.dfa136 = new Ham4Parser.DFA136(this);
this.dfa137 = new Ham4Parser.DFA137(this);
this.dfa157 = new Ham4Parser.DFA157(this);
this.dfa171 = new Ham4Parser.DFA171(this);
this.dfa173 = new Ham4Parser.DFA173(this);
this.dfa180 = new Ham4Parser.DFA180(this);
this.dfa181 = new Ham4Parser.DFA181(this);
this.dfa182 = new Ham4Parser.DFA182(this);
/* @todo only create adaptor if output=AST */
this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
};
org.antlr.lang.augmentObject(Ham4Parser, {
EOF: -1,
WS: 4,
HamTab: 5,
HamLinefeed: 6,
HamPagebreak: 7,
HamReturn: 8,
HamVersion40: 9,
HamSpace: 10,
HamExclaim: 11,
HamQuery: 12,
HamFullstop: 13,
HamComma: 14,
HamPlus: 15,
HamMetaalt: 16,
HamClocku: 17,
HamClockul: 18,
HamClockl: 19,
HamClockdl: 20,
HamClockd: 21,
HamClockdr: 22,
HamClockr: 23,
HamClockur: 24,
HamClockfull: 25,
HamSymmpar: 26,
HamSymmlr: 27,
HamFist: 28,
HamFlathand: 29,
HamFinger2: 30,
HamFinger23: 31,
HamFinger23spread: 32,
HamFinger2345: 33,
HamThumboutmod: 34,
HamThumbacrossmod: 35,
HamPinch12: 36,
HamPinchall: 37,
HamPinch12open: 38,
HamCee12: 39,
HamCeeall: 40,
HamCee12open: 41,
HamThumbopenmod: 42,
HamFingerstraightmod: 43,
HamFingerbendmod: 44,
HamFingerhookedmod: 45,
HamNondominant: 46,
HamDoublebent: 47,
HamDoublehooked: 48,
HamExtfingeru: 49,
HamExtfingerur: 50,
HamExtfingerr: 51,
HamExtfingerdr: 52,
HamExtfingerd: 53,
HamExtfingerdl: 54,
HamExtfingerl: 55,
HamExtfingerul: 56,
HamExtfingerol: 57,
HamExtfingero: 58,
HamExtfingeror: 59,
HamExtfingeril: 60,
HamExtfingeri: 61,
HamExtfingerir: 62,
HamExtfingerui: 63,
HamExtfingerdi: 64,
HamExtfingerdo: 65,
HamExtfingeruo: 66,
HamEarlobe: 67,
HamNostrils: 68,
HamShouldertop: 69,
HamPalmu: 70,
HamPalmur: 71,
HamPalmr: 72,
HamPalmdr: 73,
HamPalmd: 74,
HamPalmdl: 75,
HamPalml: 76,
HamPalmul: 77,
HamReplace: 78,
HamArmextended: 79,
HamBehind: 80,
HamEtc: 81,
HamOrirelative: 82,
HamTongue: 83,
HamTeeth: 84,
HamStomach: 85,
HamNeutralspace: 86,
HamHead: 87,
HamHeadtop: 88,
HamForehead: 89,
HamEyebrows: 90,
HamEyes: 91,
HamNose: 92,
HamEar: 93,
HamCheek: 94,
HamLips: 95,
HamChin: 96,
HamUnderchin: 97,
HamNeck: 98,
HamShoulders: 99,
HamChest: 100,
HamBelowstomach: 101,
HamLrbeside: 102,
HamLrat: 103,
HamUpperarm: 104,
HamElbow: 105,
HamElbowinside: 106,
HamLowerarm: 107,
HamWristback: 108,
HamWristpulse: 109,
HamThumbball: 110,
HamPalm: 111,
HamHandback: 112,
HamThumb: 113,
HamIndexfinger: 114,
HamMiddlefinger: 115,
HamRingfinger: 116,
HamPinky: 117,
HamThumbside: 118,
HamPinkyside: 119,
HamBetween: 120,
HamFingertip: 121,
HamFingernail: 122,
HamFingerpad: 123,
HamFingermidjoint: 124,
HamFingerbase: 125,
HamFingerside: 126,
HamWristtopulse: 127,
HamWristtoback: 128,
HamWristtothumb: 129,
HamWristtopinky: 130,
HamCoreftag: 131,
HamCorefref: 132,
HamNomotion: 133,
HamMoveu: 134,
HamMoveur: 135,
HamMover: 136,
HamMovedr: 137,
HamMoved: 138,
HamMovedl: 139,
HamMovel: 140,
HamMoveul: 141,
HamMoveol: 142,
HamMoveo: 143,
HamMoveor: 144,
HamMoveil: 145,
HamMovei: 146,
HamMoveir: 147,
HamMoveui: 148,
HamMovedi: 149,
HamMovedo: 150,
HamMoveuo: 151,
HamMovecross: 152,
HamMovex: 153,
HamSmallmod: 154,
HamLargemod: 155,
HamArcl: 156,
HamArcu: 157,
HamArcr: 158,
HamArcd: 159,
HamWavy: 160,
HamZigzag: 161,
HamFingerplay: 162,
HamParbegin: 163,
HamParend: 164,
HamCircleo: 165,
HamCirclei: 166,
HamCircled: 167,
HamCircleu: 168,
HamCirclel: 169,
HamCircler: 170,
HamIncreasing: 171,
HamDecreasing: 172,
HamClose: 173,
HamTouch: 174,
HamInterlock: 175,
HamCross: 176,
HamFast: 177,
HamSlow: 178,
HamTense: 179,
HamRest: 180,
HamHalt: 181,
HamRepeatfromstart: 182,
HamRepeatfromstartseveral: 183,
HamRepeatcontinue: 184,
HamRepeatcontinueseveral: 185,
HamSeqbegin: 186,
HamSeqend: 187,
HamAlternatingmotion: 188,
HamRepeatreverse: 189,
HamBrushing: 190,
HamNonipsi: 191,
HamEllipseh: 192,
HamEllipseur: 193,
HamEllipsev: 194,
HamEllipseul: 195,
HamMime: 196,
HamAltbegin: 197,
HamAltend: 198,
HamNodding: 199,
HamSwinging: 200,
HamTwisting: 201,
HamStircw: 202,
HamStirccw: 203,
HamFusionbegin: 204,
HamFusionend: 205,
HamCircleul: 206,
HamCircledr: 207,
HamCircleur: 208,
HamCircledl: 209,
HamCircleol: 210,
HamCircleir: 211,
HamCircleor: 212,
HamCircleil: 213,
HamCircledo: 214,
HamCircleui: 215,
HamCircledi: 216,
HamCircleuo: 217,
HamNbs: 218,
HAMSIGNS: 219,
SIGN2: 220,
SIGN1: 221,
ICFG2: 222,
ICFG1: 223,
NMICLIST: 224,
NMICUNIT: 225,
MICFG2: 226,
MICFG1: 227,
HDCONFIG2: 228,
HDCONFIG1: 229,
SPLITHDCFG2: 230,
HDCFGTAIL2: 231,
HSHAPE2: 232,
HSHAPE1: 233,
BASICHDSHP1: 234,
BASICHDSHP: 235,
HSCLASS: 236,
FIBENDING: 237,
THUMBPOS: 238,
FINGERLIST: 239,
FISHPLIST: 240,
FICRSSLIST: 241,
FSHAPE: 242,
FCROSSING: 243,
THSPECIAL: 244,
EXTFIDIR2: 245,
EXTFIDIR1: 246,
EXTFIDIR: 247,
PALMOR2: 248,
PALMOR1: 249,
LOC2: 250,
LOC1: 251,
LOCTNBODYARM: 252,
LOCTNBODY: 253,
LOCTNHAND: 254,
LOCTNARM: 255,
LEVBODY: 256,
LEVHAND: 257,
LEVARM: 258,
HCONSTLLN: 259,
CNTCTBODY: 260,
CNTCTHAND: 261,
CNTCTOFHAND: 262,
A2TLIST: 263,
A1TLIST: 264,
A1LIST: 265,
ACTION2T: 266,
ACTION1T: 267,
ACTION2: 268,
ACTION1: 269,
PARACT2T: 270,
SEQACT2T: 271,
SPLITACT2LOC2: 272,
SPLITACT2T: 273,
PARACT1T: 274,
SEQACT1T: 275,
NMACT1T: 276,
PARACT1: 277,
REPETITIONS: 278,
SIMPLEMVMT: 279,
STRGHTMVMT: 280,
CRCLRMVMT: 281,
REPLACE: 282,
SPLITREPLACETL: 283,
REPLACETAIL1: 284,
HSFINGERITEM: 285,
LOCBODY: 286,
MOVINGREPETITION: 287,
SEQACT1: 288,
SEQFUSEDACT2T: 289,
SEQFUSEDACT1T: 290,
SEQFUSEDACT1: 291,
CNTCTOHHAND: 292,
CNTCTOHARM: 293
});
(function(){
// public class variables
var EOF= -1,
WS= 4,
HamTab= 5,
HamLinefeed= 6,
HamPagebreak= 7,
HamReturn= 8,
HamVersion40= 9,
HamSpace= 10,
HamExclaim= 11,
HamQuery= 12,
HamFullstop= 13,
HamComma= 14,
HamPlus= 15,
HamMetaalt= 16,
HamClocku= 17,
HamClockul= 18,
HamClockl= 19,
HamClockdl= 20,
HamClockd= 21,
HamClockdr= 22,
HamClockr= 23,
HamClockur= 24,
HamClockfull= 25,
HamSymmpar= 26,
HamSymmlr= 27,
HamFist= 28,
HamFlathand= 29,
HamFinger2= 30,
HamFinger23= 31,
HamFinger23spread= 32,
HamFinger2345= 33,
HamThumboutmod= 34,
HamThumbacrossmod= 35,
HamPinch12= 36,
HamPinchall= 37,
HamPinch12open= 38,
HamCee12= 39,
HamCeeall= 40,
HamCee12open= 41,
HamThumbopenmod= 42,
HamFingerstraightmod= 43,
HamFingerbendmod= 44,
HamFingerhookedmod= 45,
HamNondominant= 46,
HamDoublebent= 47,
HamDoublehooked= 48,
HamExtfingeru= 49,
HamExtfingerur= 50,
HamExtfingerr= 51,
HamExtfingerdr= 52,
HamExtfingerd= 53,
HamExtfingerdl= 54,
HamExtfingerl= 55,
HamExtfingerul= 56,
HamExtfingerol= 57,
HamExtfingero= 58,
HamExtfingeror= 59,
HamExtfingeril= 60,
HamExtfingeri= 61,
HamExtfingerir= 62,
HamExtfingerui= 63,
HamExtfingerdi= 64,
HamExtfingerdo= 65,
HamExtfingeruo= 66,
HamEarlobe= 67,
HamNostrils= 68,
HamShouldertop= 69,
HamPalmu= 70,
HamPalmur= 71,
HamPalmr= 72,
HamPalmdr= 73,
HamPalmd= 74,
HamPalmdl= 75,
HamPalml= 76,
HamPalmul= 77,
HamReplace= 78,
HamArmextended= 79,
HamBehind= 80,
HamEtc= 81,
HamOrirelative= 82,
HamTongue= 83,
HamTeeth= 84,
HamStomach= 85,
HamNeutralspace= 86,
HamHead= 87,
HamHeadtop= 88,
HamForehead= 89,
HamEyebrows= 90,
HamEyes= 91,
HamNose= 92,
HamEar= 93,
HamCheek= 94,
HamLips= 95,
HamChin= 96,
HamUnderchin= 97,
HamNeck= 98,
HamShoulders= 99,
HamChest= 100,
HamBelowstomach= 101,
HamLrbeside= 102,
HamLrat= 103,
HamUpperarm= 104,
HamElbow= 105,
HamElbowinside= 106,
HamLowerarm= 107,
HamWristback= 108,
HamWristpulse= 109,
HamThumbball= 110,
HamPalm= 111,
HamHandback= 112,
HamThumb= 113,
HamIndexfinger= 114,
HamMiddlefinger= 115,
HamRingfinger= 116,
HamPinky= 117,
HamThumbside= 118,
HamPinkyside= 119,
HamBetween= 120,
HamFingertip= 121,
HamFingernail= 122,
HamFingerpad= 123,
HamFingermidjoint= 124,
HamFingerbase= 125,
HamFingerside= 126,
HamWristtopulse= 127,
HamWristtoback= 128,
HamWristtothumb= 129,
HamWristtopinky= 130,
HamCoreftag= 131,
HamCorefref= 132,
HamNomotion= 133,
HamMoveu= 134,
HamMoveur= 135,
HamMover= 136,
HamMovedr= 137,
HamMoved= 138,
HamMovedl= 139,
HamMovel= 140,
HamMoveul= 141,
HamMoveol= 142,
HamMoveo= 143,
HamMoveor= 144,
HamMoveil= 145,
HamMovei= 146,
HamMoveir= 147,
HamMoveui= 148,
HamMovedi= 149,
HamMovedo= 150,
HamMoveuo= 151,
HamMovecross= 152,
HamMovex= 153,
HamSmallmod= 154,
HamLargemod= 155,
HamArcl= 156,
HamArcu= 157,
HamArcr= 158,
HamArcd= 159,
HamWavy= 160,
HamZigzag= 161,
HamFingerplay= 162,
HamParbegin= 163,
HamParend= 164,
HamCircleo= 165,
HamCirclei= 166,
HamCircled= 167,
HamCircleu= 168,
HamCirclel= 169,
HamCircler= 170,
HamIncreasing= 171,
HamDecreasing= 172,
HamClose= 173,
HamTouch= 174,
HamInterlock= 175,
HamCross= 176,
HamFast= 177,
HamSlow= 178,
HamTense= 179,
HamRest= 180,
HamHalt= 181,
HamRepeatfromstart= 182,
HamRepeatfromstartseveral= 183,
HamRepeatcontinue= 184,
HamRepeatcontinueseveral= 185,
HamSeqbegin= 186,
HamSeqend= 187,
HamAlternatingmotion= 188,
HamRepeatreverse= 189,
HamBrushing= 190,
HamNonipsi= 191,
HamEllipseh= 192,
HamEllipseur= 193,
HamEllipsev= 194,
HamEllipseul= 195,
HamMime= 196,
HamAltbegin= 197,
HamAltend= 198,
HamNodding= 199,
HamSwinging= 200,
HamTwisting= 201,
HamStircw= 202,
HamStirccw= 203,
HamFusionbegin= 204,
HamFusionend= 205,
HamCircleul= 206,
HamCircledr= 207,
HamCircleur= 208,
HamCircledl= 209,
HamCircleol= 210,
HamCircleir= 211,
HamCircleor= 212,
HamCircleil= 213,
HamCircledo= 214,
HamCircleui= 215,
HamCircledi= 216,
HamCircleuo= 217,
HamNbs= 218,
HAMSIGNS= 219,
SIGN2= 220,
SIGN1= 221,
ICFG2= 222,
ICFG1= 223,
NMICLIST= 224,
NMICUNIT= 225,
MICFG2= 226,
MICFG1= 227,
HDCONFIG2= 228,
HDCONFIG1= 229,
SPLITHDCFG2= 230,
HDCFGTAIL2= 231,
HSHAPE2= 232,
HSHAPE1= 233,
BASICHDSHP1= 234,
BASICHDSHP= 235,
HSCLASS= 236,
FIBENDING= 237,
THUMBPOS= 238,
FINGERLIST= 239,
FISHPLIST= 240,
FICRSSLIST= 241,
FSHAPE= 242,
FCROSSING= 243,
THSPECIAL= 244,
EXTFIDIR2= 245,
EXTFIDIR1= 246,
EXTFIDIR= 247,
PALMOR2= 248,
PALMOR1= 249,
LOC2= 250,
LOC1= 251,
LOCTNBODYARM= 252,
LOCTNBODY= 253,
LOCTNHAND= 254,
LOCTNARM= 255,
LEVBODY= 256,
LEVHAND= 257,
LEVARM= 258,
HCONSTLLN= 259,
CNTCTBODY= 260,
CNTCTHAND= 261,
CNTCTOFHAND= 262,
A2TLIST= 263,
A1TLIST= 264,
A1LIST= 265,
ACTION2T= 266,
ACTION1T= 267,
ACTION2= 268,
ACTION1= 269,
PARACT2T= 270,
SEQACT2T= 271,
SPLITACT2LOC2= 272,
SPLITACT2T= 273,
PARACT1T= 274,
SEQACT1T= 275,
NMACT1T= 276,
PARACT1= 277,
REPETITIONS= 278,
SIMPLEMVMT= 279,
STRGHTMVMT= 280,
CRCLRMVMT= 281,
REPLACE= 282,
SPLITREPLACETL= 283,
REPLACETAIL1= 284,
HSFINGERITEM= 285,
LOCBODY= 286,
MOVINGREPETITION= 287,
SEQACT1= 288,
SEQFUSEDACT2T= 289,
SEQFUSEDACT1T= 290,
SEQFUSEDACT1= 291,
CNTCTOHHAND= 292,
CNTCTOHARM= 293;
// public instance methods/vars
org.antlr.lang.extend(Ham4Parser, org.antlr.runtime.Parser, {
setTreeAdaptor: function(adaptor) {
this.adaptor = adaptor;
},
getTreeAdaptor: function() {
return this.adaptor;
},
getTokenNames: function() { return Ham4Parser.tokenNames; },
getGrammarFileName: function() { return "Ham4Parser.g"; }
});
org.antlr.lang.augmentObject(Ham4Parser.prototype, {
// inline static return class
hamsinglesign_return: (function() {
Ham4Parser.hamsinglesign_return = function(){};
org.antlr.lang.extend(Ham4Parser.hamsinglesign_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:142:1: hamsinglesign : hamsignseq EOF -> ^( HAMSIGNS ( hamsignseq )? ) ;
// $ANTLR start "hamsinglesign"
hamsinglesign: function() {
var retval = new Ham4Parser.hamsinglesign_return();
retval.start = this.input.LT(1);
var root_0 = null;
var EOF2 = null;
var hamsignseq1 = null;
var EOF2_tree=null;
var stream_EOF=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token EOF");
var stream_hamsignseq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule hamsignseq");
try {
// Ham4Parser.g:143:2: ( hamsignseq EOF -> ^( HAMSIGNS ( hamsignseq )? ) )
// Ham4Parser.g:143:6: hamsignseq EOF
this.pushFollow(Ham4Parser.FOLLOW_hamsignseq_in_hamsinglesign734);
hamsignseq1=this.hamsignseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_hamsignseq.add(hamsignseq1.getTree());
EOF2=this.match(this.input,EOF,Ham4Parser.FOLLOW_EOF_in_hamsinglesign744); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_EOF.add(EOF2);
// AST REWRITE
// elements: hamsignseq
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 146:2: -> ^( HAMSIGNS ( hamsignseq )? )
{
// Ham4Parser.g:146:5: ^( HAMSIGNS ( hamsignseq )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HAMSIGNS, "HAMSIGNS"), root_1);
// Ham4Parser.g:146:16: ( hamsignseq )?
if ( stream_hamsignseq.hasNext() ) {
this.adaptor.addChild(root_1, stream_hamsignseq.nextTree());
}
stream_hamsignseq.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hamsignseq_return: (function() {
Ham4Parser.hamsignseq_return = function(){};
org.antlr.lang.extend(Ham4Parser.hamsignseq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:152:1: hamsignseq : ( sign2or1 ( HamPlus sign2or1 )* )? ;
// $ANTLR start "hamsignseq"
hamsignseq: function() {
var retval = new Ham4Parser.hamsignseq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamPlus4 = null;
var sign2or13 = null;
var sign2or15 = null;
var HamPlus4_tree=null;
this.trace("ANTLR Parse: hamsignseq starts "+this.state.backtracking);
try {
// Ham4Parser.g:173:5: ( ( sign2or1 ( HamPlus sign2or1 )* )? )
// Ham4Parser.g:174:9: ( sign2or1 ( HamPlus sign2or1 )* )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:174:9: ( sign2or1 ( HamPlus sign2or1 )* )?
var alt2=2;
var LA2_0 = this.input.LA(1);
if ( ((LA2_0>=HamSymmpar && LA2_0<=HamFinger2345)||(LA2_0>=HamPinch12 && LA2_0<=HamCee12open)||LA2_0==HamNondominant||LA2_0==HamNomotion||LA2_0==HamParbegin||LA2_0==HamSeqbegin) ) {
alt2=1;
}
switch (alt2) {
case 1 :
// Ham4Parser.g:175:13: sign2or1 ( HamPlus sign2or1 )*
this.pushFollow(Ham4Parser.FOLLOW_sign2or1_in_hamsignseq812);
sign2or13=this.sign2or1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign2or13.getTree());
// Ham4Parser.g:176:13: ( HamPlus sign2or1 )*
loop1:
do {
var alt1=2;
var LA1_0 = this.input.LA(1);
if ( (LA1_0==HamPlus) ) {
alt1=1;
}
switch (alt1) {
case 1 :
// Ham4Parser.g:177:17: HamPlus sign2or1
HamPlus4=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_hamsignseq844); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_sign2or1_in_hamsignseq864);
sign2or15=this.sign2or1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign2or15.getTree());
break;
default :
break loop1;
}
} while (true);
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hamsignseq finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sign2or1_return: (function() {
Ham4Parser.sign2or1_return = function(){};
org.antlr.lang.extend(Ham4Parser.sign2or1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:183:1: sign2or1 : ( ( HamNondominant initialconfig1 )=> nondomsign1 | sign2 );
// $ANTLR start "sign2or1"
sign2or1: function() {
var retval = new Ham4Parser.sign2or1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nondomsign16 = null;
var sign27 = null;
this.trace("ANTLR Parse: sign2or1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:202:5: ( ( HamNondominant initialconfig1 )=> nondomsign1 | sign2 )
var alt3=2;
var LA3_0 = this.input.LA(1);
if ( (LA3_0==HamNondominant) ) {
var LA3_1 = this.input.LA(2);
if ( (this.synpred1_Ham4Parser()) ) {
alt3=1;
}
else if ( (true) ) {
alt3=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 3, 1, this.input);
throw nvae;
}
}
else if ( ((LA3_0>=HamSymmpar && LA3_0<=HamFinger2345)||(LA3_0>=HamPinch12 && LA3_0<=HamCee12open)||LA3_0==HamNomotion||LA3_0==HamParbegin||LA3_0==HamSeqbegin) ) {
alt3=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 3, 0, this.input);
throw nvae;
}
switch (alt3) {
case 1 :
// Ham4Parser.g:203:9: ( HamNondominant initialconfig1 )=> nondomsign1
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_nondomsign1_in_sign2or1951);
nondomsign16=this.nondomsign1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, nondomsign16.getTree());
break;
case 2 :
// Ham4Parser.g:207:9: sign2
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_sign2_in_sign2or1967);
sign27=this.sign2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sign27.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sign2or1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sign2_return: (function() {
Ham4Parser.sign2_return = function(){};
org.antlr.lang.extend(Ham4Parser.sign2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:210:1: sign2 : ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) ) ;
// $ANTLR start "sign2"
sign2: function() {
var retval = new Ham4Parser.sign2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNomotion13 = null;
var HamNondominant14 = null;
var HamNomotion17 = null;
var symmoperator8 = null;
var initialconfig29 = null;
var a2tstar10 = null;
var initialconfig211 = null;
var a1tstar12 = null;
var initialconfig115 = null;
var a1tstar16 = null;
var initialconfig118 = null;
var a1tstar19 = null;
var HamNomotion13_tree=null;
var HamNondominant14_tree=null;
var HamNomotion17_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_symmoperator=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule symmoperator");
var stream_a2tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a2tstar");
var stream_initialconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig2");
var stream_a1tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tstar");
var stream_initialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig1");
this.trace("ANTLR Parse: sign2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:254:5: ( ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) ) )
// Ham4Parser.g:255:5: ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) )
// Ham4Parser.g:255:5: ( symmoperator initialconfig2 a2tstar -> ^( SIGN2 symmoperator initialconfig2 a2tstar ) | initialconfig2 a1tstar -> ^( SIGN2 initialconfig2 a1tstar ) | ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar ) | HamNomotion initialconfig1 a1tstar -> ^( SIGN2 HamNomotion initialconfig1 a1tstar ) )
var alt4=4;
switch ( this.input.LA(1) ) {
case HamSymmpar:
case HamSymmlr:
alt4=1;
break;
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
case HamNondominant:
case HamParbegin:
case HamSeqbegin:
alt4=2;
break;
case HamNomotion:
var LA4_6 = this.input.LA(2);
if ( (this.synpred2_Ham4Parser()) ) {
alt4=3;
}
else if ( (true) ) {
alt4=4;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 6, this.input);
throw nvae;
}
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);
throw nvae;
}
switch (alt4) {
case 1 :
// Ham4Parser.g:256:9: symmoperator initialconfig2 a2tstar
this.pushFollow(Ham4Parser.FOLLOW_symmoperator_in_sign21008);
symmoperator8=this.symmoperator();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_symmoperator.add(symmoperator8.getTree());
this.pushFollow(Ham4Parser.FOLLOW_initialconfig2_in_sign21018);
initialconfig29=this.initialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig2.add(initialconfig29.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a2tstar_in_sign21028);
a2tstar10=this.a2tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a2tstar.add(a2tstar10.getTree());
// AST REWRITE
// elements: symmoperator, a2tstar, initialconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 259:6: -> ^( SIGN2 symmoperator initialconfig2 a2tstar )
{
// Ham4Parser.g:259:9: ^( SIGN2 symmoperator initialconfig2 a2tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_symmoperator.nextTree());
this.adaptor.addChild(root_1, stream_initialconfig2.nextTree());
this.adaptor.addChild(root_1, stream_a2tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:261:9: initialconfig2 a1tstar
this.pushFollow(Ham4Parser.FOLLOW_initialconfig2_in_sign21061);
initialconfig211=this.initialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig2.add(initialconfig211.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21071);
a1tstar12=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar12.getTree());
// AST REWRITE
// elements: a1tstar, initialconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 263:6: -> ^( SIGN2 initialconfig2 a1tstar )
{
// Ham4Parser.g:263:9: ^( SIGN2 initialconfig2 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_initialconfig2.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:272:9: ( HamNomotion HamNondominant initialconfig1 )=> HamNomotion HamNondominant initialconfig1 a1tstar
HamNomotion13=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_sign21137); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion13);
HamNondominant14=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_sign21147); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant14);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_sign21157);
initialconfig115=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig115.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21167);
a1tstar16=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar16.getTree());
// AST REWRITE
// elements: HamNomotion, a1tstar, HamNondominant, initialconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 278:6: -> ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar )
{
// Ham4Parser.g:278:9: ^( SIGN2 HamNomotion HamNondominant initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:280:9: HamNomotion initialconfig1 a1tstar
HamNomotion17=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_sign21202); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion17);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_sign21212);
initialconfig118=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig118.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_sign21222);
a1tstar19=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar19.getTree());
// AST REWRITE
// elements: initialconfig1, HamNomotion, a1tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 283:6: -> ^( SIGN2 HamNomotion initialconfig1 a1tstar )
{
// Ham4Parser.g:283:9: ^( SIGN2 HamNomotion initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN2, "SIGN2"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sign2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nondomsign1_return: (function() {
Ham4Parser.nondomsign1_return = function(){};
org.antlr.lang.extend(Ham4Parser.nondomsign1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:287:1: nondomsign1 : HamNondominant initialconfig1 a1tstar -> ^( SIGN1 HamNondominant initialconfig1 a1tstar ) ;
// $ANTLR start "nondomsign1"
nondomsign1: function() {
var retval = new Ham4Parser.nondomsign1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNondominant20 = null;
var initialconfig121 = null;
var a1tstar22 = null;
var HamNondominant20_tree=null;
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_initialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule initialconfig1");
var stream_a1tstar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tstar");
this.trace("ANTLR Parse: nondomsign1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:305:5: ( HamNondominant initialconfig1 a1tstar -> ^( SIGN1 HamNondominant initialconfig1 a1tstar ) )
// Ham4Parser.g:305:9: HamNondominant initialconfig1 a1tstar
HamNondominant20=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_nondomsign11274); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant20);
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_nondomsign11284);
initialconfig121=this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_initialconfig1.add(initialconfig121.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tstar_in_nondomsign11294);
a1tstar22=this.a1tstar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tstar.add(a1tstar22.getTree());
// AST REWRITE
// elements: HamNondominant, initialconfig1, a1tstar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 309:9: -> ^( SIGN1 HamNondominant initialconfig1 a1tstar )
{
// Ham4Parser.g:309:12: ^( SIGN1 HamNondominant initialconfig1 a1tstar )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIGN1, "SIGN1"), root_1);
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
this.adaptor.addChild(root_1, stream_initialconfig1.nextTree());
this.adaptor.addChild(root_1, stream_a1tstar.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nondomsign1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
symmoperator_return: (function() {
Ham4Parser.symmoperator_return = function(){};
org.antlr.lang.extend(Ham4Parser.symmoperator_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:312:1: symmoperator : ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ;
// $ANTLR start "symmoperator"
symmoperator: function() {
var retval = new Ham4Parser.symmoperator_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set23 = null;
var HamFingerstraightmod24 = null;
var HamLargemod25 = null;
var HamLargemod26 = null;
var HamFingerstraightmod27 = null;
var HamAlternatingmotion28 = null;
var HamNonipsi29 = null;
var set23_tree=null;
var HamFingerstraightmod24_tree=null;
var HamLargemod25_tree=null;
var HamLargemod26_tree=null;
var HamFingerstraightmod27_tree=null;
var HamAlternatingmotion28_tree=null;
var HamNonipsi29_tree=null;
this.trace("ANTLR Parse: symmoperator starts "+this.state.backtracking);
try {
// Ham4Parser.g:339:5: ( ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4Parser.g:339:9: ( HamSymmpar | HamSymmlr ) ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )? ( HamAlternatingmotion )? ( HamNonipsi )?
root_0 = this.adaptor.nil();
set23=this.input.LT(1);
if ( (this.input.LA(1)>=HamSymmpar && this.input.LA(1)<=HamSymmlr) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set23));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:344:9: ( HamFingerstraightmod ( HamLargemod )? | HamLargemod ( HamFingerstraightmod )? )?
var alt7=3;
var LA7_0 = this.input.LA(1);
if ( (LA7_0==HamFingerstraightmod) ) {
alt7=1;
}
else if ( (LA7_0==HamLargemod) ) {
alt7=2;
}
switch (alt7) {
case 1 :
// Ham4Parser.g:345:13: HamFingerstraightmod ( HamLargemod )?
HamFingerstraightmod24=this.match(this.input,HamFingerstraightmod,Ham4Parser.FOLLOW_HamFingerstraightmod_in_symmoperator1424); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamFingerstraightmod24_tree = this.adaptor.create(HamFingerstraightmod24);
this.adaptor.addChild(root_0, HamFingerstraightmod24_tree);
}
// Ham4Parser.g:346:13: ( HamLargemod )?
var alt5=2;
var LA5_0 = this.input.LA(1);
if ( (LA5_0==HamLargemod) ) {
alt5=1;
}
switch (alt5) {
case 1 :
// Ham4Parser.g:346:15: HamLargemod
HamLargemod25=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_symmoperator1440); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamLargemod25_tree = this.adaptor.create(HamLargemod25);
this.adaptor.addChild(root_0, HamLargemod25_tree);
}
break;
}
break;
case 2 :
// Ham4Parser.g:348:13: HamLargemod ( HamFingerstraightmod )?
HamLargemod26=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_symmoperator1467); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamLargemod26_tree = this.adaptor.create(HamLargemod26);
this.adaptor.addChild(root_0, HamLargemod26_tree);
}
// Ham4Parser.g:349:13: ( HamFingerstraightmod )?
var alt6=2;
var LA6_0 = this.input.LA(1);
if ( (LA6_0==HamFingerstraightmod) ) {
alt6=1;
}
switch (alt6) {
case 1 :
// Ham4Parser.g:349:15: HamFingerstraightmod
HamFingerstraightmod27=this.match(this.input,HamFingerstraightmod,Ham4Parser.FOLLOW_HamFingerstraightmod_in_symmoperator1483); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamFingerstraightmod27_tree = this.adaptor.create(HamFingerstraightmod27);
this.adaptor.addChild(root_0, HamFingerstraightmod27_tree);
}
break;
}
break;
}
// Ham4Parser.g:351:9: ( HamAlternatingmotion )?
var alt8=2;
var LA8_0 = this.input.LA(1);
if ( (LA8_0==HamAlternatingmotion) ) {
alt8=1;
}
switch (alt8) {
case 1 :
// Ham4Parser.g:351:11: HamAlternatingmotion
HamAlternatingmotion28=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_symmoperator1509); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion28_tree = this.adaptor.create(HamAlternatingmotion28);
this.adaptor.addChild(root_0, HamAlternatingmotion28_tree);
}
break;
}
// Ham4Parser.g:352:9: ( HamNonipsi )?
var alt9=2;
var LA9_0 = this.input.LA(1);
if ( (LA9_0==HamNonipsi) ) {
alt9=1;
}
switch (alt9) {
case 1 :
// Ham4Parser.g:352:11: HamNonipsi
HamNonipsi29=this.match(this.input,HamNonipsi,Ham4Parser.FOLLOW_HamNonipsi_in_symmoperator1524); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNonipsi29_tree = this.adaptor.create(HamNonipsi29);
this.adaptor.addChild(root_0, HamNonipsi29_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: symmoperator finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
initialconfig2_return: (function() {
Ham4Parser.initialconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.initialconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:358:1: initialconfig2 : ( nminitialconfig )? minitialconfig2 -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 ) ;
// $ANTLR start "initialconfig2"
initialconfig2: function() {
var retval = new Ham4Parser.initialconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nminitialconfig30 = null;
var minitialconfig231 = null;
var stream_minitialconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minitialconfig2");
var stream_nminitialconfig=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nminitialconfig");
this.trace("ANTLR Parse: initialconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:375:5: ( ( nminitialconfig )? minitialconfig2 -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 ) )
// Ham4Parser.g:375:9: ( nminitialconfig )? minitialconfig2
// Ham4Parser.g:375:9: ( nminitialconfig )?
var alt10=2;
var LA10_0 = this.input.LA(1);
if ( (LA10_0==HamSeqbegin) ) {
alt10=1;
}
switch (alt10) {
case 1 :
// Ham4Parser.g:375:11: nminitialconfig
this.pushFollow(Ham4Parser.FOLLOW_nminitialconfig_in_initialconfig21561);
nminitialconfig30=this.nminitialconfig();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nminitialconfig.add(nminitialconfig30.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_minitialconfig2_in_initialconfig21574);
minitialconfig231=this.minitialconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_minitialconfig2.add(minitialconfig231.getTree());
// AST REWRITE
// elements: nminitialconfig, minitialconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 378:9: -> ^( ICFG2 ( nminitialconfig )? minitialconfig2 )
{
// Ham4Parser.g:378:12: ^( ICFG2 ( nminitialconfig )? minitialconfig2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ICFG2, "ICFG2"), root_1);
// Ham4Parser.g:378:20: ( nminitialconfig )?
if ( stream_nminitialconfig.hasNext() ) {
this.adaptor.addChild(root_1, stream_nminitialconfig.nextTree());
}
stream_nminitialconfig.reset();
this.adaptor.addChild(root_1, stream_minitialconfig2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: initialconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
initialconfig1_return: (function() {
Ham4Parser.initialconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.initialconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:381:1: initialconfig1 : ( nminitialconfig )? minitialconfig1 -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 ) ;
// $ANTLR start "initialconfig1"
initialconfig1: function() {
var retval = new Ham4Parser.initialconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nminitialconfig32 = null;
var minitialconfig133 = null;
var stream_minitialconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule minitialconfig1");
var stream_nminitialconfig=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nminitialconfig");
this.trace("ANTLR Parse: initialconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:398:5: ( ( nminitialconfig )? minitialconfig1 -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 ) )
// Ham4Parser.g:398:9: ( nminitialconfig )? minitialconfig1
// Ham4Parser.g:398:9: ( nminitialconfig )?
var alt11=2;
var LA11_0 = this.input.LA(1);
if ( (LA11_0==HamSeqbegin) ) {
alt11=1;
}
switch (alt11) {
case 1 :
// Ham4Parser.g:398:11: nminitialconfig
this.pushFollow(Ham4Parser.FOLLOW_nminitialconfig_in_initialconfig11633);
nminitialconfig32=this.nminitialconfig();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nminitialconfig.add(nminitialconfig32.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_minitialconfig1_in_initialconfig11646);
minitialconfig133=this.minitialconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_minitialconfig1.add(minitialconfig133.getTree());
// AST REWRITE
// elements: nminitialconfig, minitialconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 401:9: -> ^( ICFG1 ( nminitialconfig )? minitialconfig1 )
{
// Ham4Parser.g:401:12: ^( ICFG1 ( nminitialconfig )? minitialconfig1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ICFG1, "ICFG1"), root_1);
// Ham4Parser.g:401:20: ( nminitialconfig )?
if ( stream_nminitialconfig.hasNext() ) {
this.adaptor.addChild(root_1, stream_nminitialconfig.nextTree());
}
stream_nminitialconfig.reset();
this.adaptor.addChild(root_1, stream_minitialconfig1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: initialconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nminitialconfig_return: (function() {
Ham4Parser.nminitialconfig_return = function(){};
org.antlr.lang.extend(Ham4Parser.nminitialconfig_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:404:1: nminitialconfig : ( nmicunit )+ -> ^( NMICLIST ( nmicunit )* ) ;
// $ANTLR start "nminitialconfig"
nminitialconfig: function() {
var retval = new Ham4Parser.nminitialconfig_return();
retval.start = this.input.LT(1);
var root_0 = null;
var nmicunit34 = null;
var stream_nmicunit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule nmicunit");
this.trace("ANTLR Parse: nminitialconfig starts "+this.state.backtracking);
try {
// Ham4Parser.g:421:5: ( ( nmicunit )+ -> ^( NMICLIST ( nmicunit )* ) )
// Ham4Parser.g:421:9: ( nmicunit )+
// Ham4Parser.g:421:9: ( nmicunit )+
var cnt12=0;
loop12:
do {
var alt12=2;
var LA12_0 = this.input.LA(1);
if ( (LA12_0==HamSeqbegin) ) {
alt12=1;
}
switch (alt12) {
case 1 :
// Ham4Parser.g:422:13: nmicunit
this.pushFollow(Ham4Parser.FOLLOW_nmicunit_in_nminitialconfig1717);
nmicunit34=this.nmicunit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_nmicunit.add(nmicunit34.getTree());
break;
default :
if ( cnt12 >= 1 ) {
break loop12;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(12, this.input);
throw eee;
}
cnt12++;
} while (true);
// AST REWRITE
// elements: nmicunit
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 424:9: -> ^( NMICLIST ( nmicunit )* )
{
// Ham4Parser.g:424:12: ^( NMICLIST ( nmicunit )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMICLIST, "NMICLIST"), root_1);
// Ham4Parser.g:424:23: ( nmicunit )*
while ( stream_nmicunit.hasNext() ) {
this.adaptor.addChild(root_1, stream_nmicunit.nextTree());
}
stream_nmicunit.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nminitialconfig finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
nmicunit_return: (function() {
Ham4Parser.nmicunit_return = function(){};
org.antlr.lang.extend(Ham4Parser.nmicunit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:427:1: nmicunit : HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 ) ;
// $ANTLR start "nmicunit"
nmicunit: function() {
var retval = new Ham4Parser.nmicunit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin35 = null;
var HamSeqend39 = null;
var levelbody36 = null;
var levelarm37 = null;
var action138 = null;
var HamSeqbegin35_tree=null;
var HamSeqend39_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_levelbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelbody");
var stream_levelarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelarm");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: nmicunit starts "+this.state.backtracking);
try {
// Ham4Parser.g:451:5: ( HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 ) )
// Ham4Parser.g:452:9: HamSeqbegin ( ( levelbody )=> levelbody | levelarm ) action1 HamSeqend
HamSeqbegin35=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_nmicunit1780); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin35);
// Ham4Parser.g:453:9: ( ( levelbody )=> levelbody | levelarm )
var alt13=2;
alt13 = this.dfa13.predict(this.input);
switch (alt13) {
case 1 :
// Ham4Parser.g:454:11: ( levelbody )=> levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_nmicunit1811);
levelbody36=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelbody.add(levelbody36.getTree());
break;
case 2 :
// Ham4Parser.g:456:11: levelarm
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_nmicunit1833);
levelarm37=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelarm.add(levelarm37.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_action1_in_nmicunit1853);
action138=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action138.getTree());
HamSeqend39=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_nmicunit1863); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend39);
// AST REWRITE
// elements: levelbody, levelarm, action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 461:9: -> ^( NMICUNIT ( levelbody )? ( levelarm )? action1 )
{
// Ham4Parser.g:461:12: ^( NMICUNIT ( levelbody )? ( levelarm )? action1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMICUNIT, "NMICUNIT"), root_1);
// Ham4Parser.g:461:23: ( levelbody )?
if ( stream_levelbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelbody.nextTree());
}
stream_levelbody.reset();
// Ham4Parser.g:461:34: ( levelarm )?
if ( stream_levelarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelarm.nextTree());
}
stream_levelarm.reset();
this.adaptor.addChild(root_1, stream_action1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: nmicunit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
minitialconfig2_return: (function() {
Ham4Parser.minitialconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.minitialconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:465:1: minitialconfig2 : ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) ) ;
// $ANTLR start "minitialconfig2"
minitialconfig2: function() {
var retval = new Ham4Parser.minitialconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin42 = null;
var HamPlus44 = null;
var HamParend46 = null;
var HamPlus47 = null;
var HamParend48 = null;
var loc = null;
var ploc = null;
var handconfig240 = null;
var location241 = null;
var handconfig143 = null;
var location145 = null;
var HamParbegin42_tree=null;
var HamPlus44_tree=null;
var HamParend46_tree=null;
var HamPlus47_tree=null;
var HamParend48_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_location2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
var stream_handconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig2");
this.trace("ANTLR Parse: minitialconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:509:5: ( ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) ) )
// Ham4Parser.g:510:5: ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) )
// Ham4Parser.g:510:5: ( ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )? -> ^( MICFG2 handconfig2 ( location2 )? ) | HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) ) )
var alt17=2;
var LA17_0 = this.input.LA(1);
if ( ((LA17_0>=HamFist && LA17_0<=HamFinger2345)||(LA17_0>=HamPinch12 && LA17_0<=HamCee12open)) && (this.synpred4_Ham4Parser())) {
alt17=1;
}
else if ( (LA17_0==HamNondominant) && (this.synpred4_Ham4Parser())) {
alt17=1;
}
else if ( (LA17_0==HamParbegin) ) {
var LA17_3 = this.input.LA(2);
if ( (this.synpred4_Ham4Parser()) ) {
alt17=1;
}
else if ( (true) ) {
alt17=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 17, 3, this.input);
throw nvae;
}
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 17, 0, this.input);
throw nvae;
}
switch (alt17) {
case 1 :
// Ham4Parser.g:511:9: ( handconfig2 )=> handconfig2 ( ( location2 )=> location2 )?
this.pushFollow(Ham4Parser.FOLLOW_handconfig2_in_minitialconfig21961);
handconfig240=this.handconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig2.add(handconfig240.getTree());
// Ham4Parser.g:514:9: ( ( location2 )=> location2 )?
var alt14=2;
alt14 = this.dfa14.predict(this.input);
switch (alt14) {
case 1 :
// Ham4Parser.g:515:13: ( location2 )=> location2
this.pushFollow(Ham4Parser.FOLLOW_location2_in_minitialconfig22017);
location241=this.location2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2.add(location241.getTree());
break;
}
// AST REWRITE
// elements: location2, handconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 519:6: -> ^( MICFG2 handconfig2 ( location2 )? )
{
// Ham4Parser.g:519:9: ^( MICFG2 handconfig2 ( location2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig2.nextTree());
// Ham4Parser.g:519:30: ( location2 )?
if ( stream_location2.hasNext() ) {
this.adaptor.addChild(root_1, stream_location2.nextTree());
}
stream_location2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:521:9: HamParbegin handconfig1 ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )
HamParbegin42=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_minitialconfig22060); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin42);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_minitialconfig22071);
handconfig143=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig143.getTree());
// Ham4Parser.g:523:9: ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )
var alt16=2;
alt16 = this.dfa16.predict(this.input);
switch (alt16) {
case 1 :
// Ham4Parser.g:524:13: ( HamPlus )=> HamPlus location1 HamParend
HamPlus44=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_minitialconfig22127); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus44);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22142);
location145=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location145.getTree());
HamParend46=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_minitialconfig22156); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend46);
// AST REWRITE
// elements: location1, HamPlus, handconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 530:6: -> ^( MICFG2 handconfig1 HamPlus location1 )
{
// Ham4Parser.g:530:9: ^( MICFG2 handconfig1 HamPlus location1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_location1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:532:13: loc= location1 HamPlus (ploc= location1 )? HamParend
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22200);
loc=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(loc.getTree());
HamPlus47=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_minitialconfig22214); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus47);
// Ham4Parser.g:535:13: (ploc= location1 )?
var alt15=2;
alt15 = this.dfa15.predict(this.input);
switch (alt15) {
case 1 :
// Ham4Parser.g:535:15: ploc= location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig22233);
ploc=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(ploc.getTree());
break;
}
HamParend48=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_minitialconfig22250); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend48);
// AST REWRITE
// elements: ploc, HamPlus, handconfig1, loc
// token labels: 
// rule labels: loc, ploc, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_loc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token loc",loc!=null?loc.tree:null);
var stream_ploc=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token ploc",ploc!=null?ploc.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 537:6: -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? )
{
// Ham4Parser.g:537:9: ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG2, "MICFG2"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
this.adaptor.addChild(root_1, stream_loc.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
// Ham4Parser.g:537:43: ( $ploc)?
if ( stream_ploc.hasNext() ) {
this.adaptor.addChild(root_1, stream_ploc.nextTree());
}
stream_ploc.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: minitialconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
minitialconfig1_return: (function() {
Ham4Parser.minitialconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.minitialconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:542:1: minitialconfig1 : handconfig1 ( location1 )? -> ^( MICFG1 handconfig1 ( location1 )? ) ;
// $ANTLR start "minitialconfig1"
minitialconfig1: function() {
var retval = new Ham4Parser.minitialconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handconfig149 = null;
var location150 = null;
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
this.trace("ANTLR Parse: minitialconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:560:5: ( handconfig1 ( location1 )? -> ^( MICFG1 handconfig1 ( location1 )? ) )
// Ham4Parser.g:561:9: handconfig1 ( location1 )?
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_minitialconfig12324);
handconfig149=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig149.getTree());
// Ham4Parser.g:562:9: ( location1 )?
var alt18=2;
alt18 = this.dfa18.predict(this.input);
switch (alt18) {
case 1 :
// Ham4Parser.g:562:11: location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_minitialconfig12336);
location150=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location150.getTree());
break;
}
// AST REWRITE
// elements: handconfig1, location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 564:6: -> ^( MICFG1 handconfig1 ( location1 )? )
{
// Ham4Parser.g:564:9: ^( MICFG1 handconfig1 ( location1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MICFG1, "MICFG1"), root_1);
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
// Ham4Parser.g:564:30: ( location1 )?
if ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: minitialconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfig2_return: (function() {
Ham4Parser.handconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:570:1: handconfig2 : ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) ) ;
// $ANTLR start "handconfig2"
handconfig2: function() {
var retval = new Ham4Parser.handconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshape251 = null;
var handconfigtail252 = null;
var handshape253 = null;
var splithandconfig254 = null;
var stream_handshape2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape2");
var stream_handconfigtail2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfigtail2");
var stream_splithandconfig2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splithandconfig2");
this.trace("ANTLR Parse: handconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:599:5: ( ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) ) )
// Ham4Parser.g:600:5: ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) )
// Ham4Parser.g:600:5: ( ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2 -> ^( HDCONFIG2 handshape2 handconfigtail2 ) | ( handshape2 )=> handshape2 -> ^( HDCONFIG2 handshape2 ) | splithandconfig2 -> ^( HDCONFIG2 splithandconfig2 ) )
var alt19=3;
switch ( this.input.LA(1) ) {
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
var LA19_1 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 1, this.input);
throw nvae;
}
break;
case HamNondominant:
var LA19_2 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 2, this.input);
throw nvae;
}
break;
case HamParbegin:
var LA19_3 = this.input.LA(2);
if ( (this.synpred7_Ham4Parser()) ) {
alt19=1;
}
else if ( (this.synpred8_Ham4Parser()) ) {
alt19=2;
}
else if ( (true) ) {
alt19=3;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 3, this.input);
throw nvae;
}
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 19, 0, this.input);
throw nvae;
}
switch (alt19) {
case 1 :
// Ham4Parser.g:601:9: ( handshape2 ( HamParbegin )? extfidir1 )=> handshape2 handconfigtail2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_handconfig22441);
handshape251=this.handshape2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape2.add(handshape251.getTree());
this.pushFollow(Ham4Parser.FOLLOW_handconfigtail2_in_handconfig22451);
handconfigtail252=this.handconfigtail2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfigtail2.add(handconfigtail252.getTree());
// AST REWRITE
// elements: handshape2, handconfigtail2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 605:6: -> ^( HDCONFIG2 handshape2 handconfigtail2 )
{
// Ham4Parser.g:605:9: ^( HDCONFIG2 handshape2 handconfigtail2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_handshape2.nextTree());
this.adaptor.addChild(root_1, stream_handconfigtail2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:607:9: ( handshape2 )=> handshape2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_handconfig22506);
handshape253=this.handshape2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape2.add(handshape253.getTree());
// AST REWRITE
// elements: handshape2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 610:6: -> ^( HDCONFIG2 handshape2 )
{
// Ham4Parser.g:610:9: ^( HDCONFIG2 handshape2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_handshape2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:612:9: splithandconfig2
this.pushFollow(Ham4Parser.FOLLOW_splithandconfig2_in_handconfig22535);
splithandconfig254=this.splithandconfig2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splithandconfig2.add(splithandconfig254.getTree());
// AST REWRITE
// elements: splithandconfig2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 613:6: -> ^( HDCONFIG2 splithandconfig2 )
{
// Ham4Parser.g:613:9: ^( HDCONFIG2 splithandconfig2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG2, "HDCONFIG2"), root_1);
this.adaptor.addChild(root_1, stream_splithandconfig2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfig1_return: (function() {
Ham4Parser.handconfig1_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfig1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:618:1: handconfig1 : handshape1 ( extfidir1 palmor1 )? -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? ) ;
// $ANTLR start "handconfig1"
handconfig1: function() {
var retval = new Ham4Parser.handconfig1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshape155 = null;
var extfidir156 = null;
var palmor157 = null;
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: handconfig1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:638:5: ( handshape1 ( extfidir1 palmor1 )? -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? ) )
// Ham4Parser.g:638:9: handshape1 ( extfidir1 palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handconfig12584);
handshape155=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape155.getTree());
// Ham4Parser.g:639:9: ( extfidir1 palmor1 )?
var alt20=2;
var LA20_0 = this.input.LA(1);
if ( ((LA20_0>=HamExtfingeru && LA20_0<=HamExtfingeruo)) ) {
alt20=1;
}
switch (alt20) {
case 1 :
// Ham4Parser.g:640:13: extfidir1 palmor1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfig12608);
extfidir156=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir156.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfig12622);
palmor157=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor157.getTree());
break;
}
// AST REWRITE
// elements: handshape1, extfidir1, palmor1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 644:6: -> ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? )
{
// Ham4Parser.g:644:9: ^( HDCONFIG1 handshape1 ( extfidir1 )? ( palmor1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCONFIG1, "HDCONFIG1"), root_1);
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
// Ham4Parser.g:644:32: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:644:43: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfig1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splithandconfig2_return: (function() {
Ham4Parser.splithandconfig2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splithandconfig2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:649:1: splithandconfig2 : HamParbegin handconfig1 HamPlus handconfig1 HamParend -> ^( SPLITHDCFG2 ( handconfig1 )* ) ;
// $ANTLR start "splithandconfig2"
splithandconfig2: function() {
var retval = new Ham4Parser.splithandconfig2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin58 = null;
var HamPlus60 = null;
var HamParend62 = null;
var handconfig159 = null;
var handconfig161 = null;
var HamParbegin58_tree=null;
var HamPlus60_tree=null;
var HamParend62_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_handconfig1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconfig1");
this.trace("ANTLR Parse: splithandconfig2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:669:5: ( HamParbegin handconfig1 HamPlus handconfig1 HamParend -> ^( SPLITHDCFG2 ( handconfig1 )* ) )
// Ham4Parser.g:669:9: HamParbegin handconfig1 HamPlus handconfig1 HamParend
HamParbegin58=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splithandconfig22692); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin58);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_splithandconfig22703);
handconfig159=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig159.getTree());
HamPlus60=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splithandconfig22713); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus60);
this.pushFollow(Ham4Parser.FOLLOW_handconfig1_in_splithandconfig22724);
handconfig161=this.handconfig1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconfig1.add(handconfig161.getTree());
HamParend62=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splithandconfig22734); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend62);
// AST REWRITE
// elements: handconfig1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 675:6: -> ^( SPLITHDCFG2 ( handconfig1 )* )
{
// Ham4Parser.g:675:9: ^( SPLITHDCFG2 ( handconfig1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITHDCFG2, "SPLITHDCFG2"), root_1);
// Ham4Parser.g:675:23: ( handconfig1 )*
while ( stream_handconfig1.hasNext() ) {
this.adaptor.addChild(root_1, stream_handconfig1.nextTree());
}
stream_handconfig1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splithandconfig2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconfigtail2_return: (function() {
Ham4Parser.handconfigtail2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconfigtail2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:678:1: handconfigtail2 : ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) ) ;
// $ANTLR start "handconfigtail2"
handconfigtail2: function() {
var retval = new Ham4Parser.handconfigtail2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin65 = null;
var HamPlus66 = null;
var HamParend67 = null;
var efd1 = null;
var por1 = null;
var efd2 = null;
var por2 = null;
var extfidir263 = null;
var palmor264 = null;
var HamParbegin65_tree=null;
var HamPlus66_tree=null;
var HamParend67_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_palmor2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor2");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
var stream_extfidir2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir2");
this.trace("ANTLR Parse: handconfigtail2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:708:5: ( ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) ) )
// Ham4Parser.g:709:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )
// Ham4Parser.g:709:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )
var alt21=2;
alt21 = this.dfa21.predict(this.input);
switch (alt21) {
case 1 :
// Ham4Parser.g:710:9: ( extfidir2 )=> extfidir2 palmor2
this.pushFollow(Ham4Parser.FOLLOW_extfidir2_in_handconfigtail22823);
extfidir263=this.extfidir2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir2.add(extfidir263.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor2_in_handconfigtail22833);
palmor264=this.palmor2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor2.add(palmor264.getTree());
// AST REWRITE
// elements: palmor2, extfidir2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 714:5: -> ^( HDCFGTAIL2 extfidir2 palmor2 )
{
// Ham4Parser.g:714:8: ^( HDCFGTAIL2 extfidir2 palmor2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCFGTAIL2, "HDCFGTAIL2"), root_1);
this.adaptor.addChild(root_1, stream_extfidir2.nextTree());
this.adaptor.addChild(root_1, stream_palmor2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:716:9: HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend
HamParbegin65=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handconfigtail22863); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin65);
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfigtail22876);
efd1=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(efd1.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfigtail22888);
por1=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(por1.getTree());
HamPlus66=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handconfigtail22898); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus66);
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_handconfigtail22911);
efd2=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(efd2.getTree());
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_handconfigtail22923);
por2=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(por2.getTree());
HamParend67=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handconfigtail22933); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend67);
// AST REWRITE
// elements: por2, efd2, efd1, por1
// token labels: 
// rule labels: efd2, efd1, por1, por2, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_efd2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token efd2",efd2!=null?efd2.tree:null);
var stream_efd1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token efd1",efd1!=null?efd1.tree:null);
var stream_por1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token por1",por1!=null?por1.tree:null);
var stream_por2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token por2",por2!=null?por2.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 723:5: -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2)
{
// Ham4Parser.g:723:8: ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HDCFGTAIL2, "HDCFGTAIL2"), root_1);
this.adaptor.addChild(root_1, stream_efd1.nextTree());
this.adaptor.addChild(root_1, stream_por1.nextTree());
this.adaptor.addChild(root_1, stream_efd2.nextTree());
this.adaptor.addChild(root_1, stream_por2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconfigtail2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshape2_return: (function() {
Ham4Parser.handshape2_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshape2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:730:1: handshape2 : ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) ) ;
// $ANTLR start "handshape2"
handshape2: function() {
var retval = new Ham4Parser.handshape2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin69 = null;
var HamPlus70 = null;
var HamParend71 = null;
var hs1 = null;
var hs2 = null;
var handshape168 = null;
var HamParbegin69_tree=null;
var HamPlus70_tree=null;
var HamParend71_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
this.trace("ANTLR Parse: handshape2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:755:5: ( ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) ) )
// Ham4Parser.g:756:5: ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) )
// Ham4Parser.g:756:5: ( handshape1 -> ^( HSHAPE2 handshape1 ) | HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend -> ^( HSHAPE2 $hs1 $hs2) )
var alt22=2;
var LA22_0 = this.input.LA(1);
if ( ((LA22_0>=HamFist && LA22_0<=HamFinger2345)||(LA22_0>=HamPinch12 && LA22_0<=HamCee12open)||LA22_0==HamNondominant) ) {
alt22=1;
}
else if ( (LA22_0==HamParbegin) ) {
alt22=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 22, 0, this.input);
throw nvae;
}
switch (alt22) {
case 1 :
// Ham4Parser.g:757:9: handshape1
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23006);
handshape168=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape168.getTree());
// AST REWRITE
// elements: handshape1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 758:6: -> ^( HSHAPE2 handshape1 )
{
// Ham4Parser.g:758:9: ^( HSHAPE2 handshape1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE2, "HSHAPE2"), root_1);
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:760:9: HamParbegin hs1= handshape1 HamPlus hs2= handshape1 HamParend
HamParbegin69=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handshape23035); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin69);
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23050);
hs1=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(hs1.getTree());
HamPlus70=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handshape23060); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus70);
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_handshape23075);
hs2=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(hs2.getTree());
HamParend71=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handshape23085); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend71);
// AST REWRITE
// elements: hs2, hs1
// token labels: 
// rule labels: hs2, hs1, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_hs2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token hs2",hs2!=null?hs2.tree:null);
var stream_hs1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token hs1",hs1!=null?hs1.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 765:6: -> ^( HSHAPE2 $hs1 $hs2)
{
// Ham4Parser.g:765:9: ^( HSHAPE2 $hs1 $hs2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE2, "HSHAPE2"), root_1);
this.adaptor.addChild(root_1, stream_hs1.nextTree());
this.adaptor.addChild(root_1, stream_hs2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshape2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshape1_return: (function() {
Ham4Parser.handshape1_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshape1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:769:1: handshape1 : basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist ) -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? ) ;
// $ANTLR start "handshape1"
handshape1: function() {
var retval = new Ham4Parser.handshape1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var basichandshape172 = null;
var cautiousfingerlist73 = null;
var fingershapelist74 = null;
var fingercrossinglist75 = null;
var thumbbetweenexplicit76 = null;
var cautiousfingerlist77 = null;
var fingershapelist78 = null;
var fingercrossinglist79 = null;
var thumbspecial80 = null;
var fingerlist81 = null;
var fingershapelist82 = null;
var fingercrossinglist83 = null;
var thumbbetweendefault84 = null;
var thumbextra85 = null;
var fingerlist86 = null;
var fingershapelist87 = null;
var fingercrossinglist88 = null;
var stream_thumbbetweenexplicit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbbetweenexplicit");
var stream_cautiousfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule cautiousfingerlist");
var stream_thumbspecial=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbspecial");
var stream_thumbbetweendefault=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbbetweendefault");
var stream_basichandshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule basichandshape1");
var stream_fingershapelist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingershapelist");
var stream_fingercrossinglist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingercrossinglist");
var stream_fingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerlist");
var stream_thumbextra=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbextra");
this.trace("ANTLR Parse: handshape1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:817:5: ( basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist ) -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? ) )
// Ham4Parser.g:817:7: basichandshape1 ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )
this.pushFollow(Ham4Parser.FOLLOW_basichandshape1_in_handshape13136);
basichandshape172=this.basichandshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape1.add(basichandshape172.getTree());
// Ham4Parser.g:818:9: ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )
var alt25=4;
alt25 = this.dfa25.predict(this.input);
switch (alt25) {
case 1 :
// Ham4Parser.g:819:13: ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit
this.pushFollow(Ham4Parser.FOLLOW_cautiousfingerlist_in_handshape13201);
cautiousfingerlist73=this.cautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_cautiousfingerlist.add(cautiousfingerlist73.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13215);
fingershapelist74=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist74.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13229);
fingercrossinglist75=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist75.getTree());
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweenexplicit_in_handshape13243);
thumbbetweenexplicit76=this.thumbbetweenexplicit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbbetweenexplicit.add(thumbbetweenexplicit76.getTree());
break;
case 2 :
// Ham4Parser.g:827:13: ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )?
this.pushFollow(Ham4Parser.FOLLOW_cautiousfingerlist_in_handshape13321);
cautiousfingerlist77=this.cautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_cautiousfingerlist.add(cautiousfingerlist77.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13335);
fingershapelist78=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist78.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13349);
fingercrossinglist79=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist79.getTree());
// Ham4Parser.g:832:13: ( ( thumbspecial )=> thumbspecial )?
var alt23=2;
alt23 = this.dfa23.predict(this.input);
switch (alt23) {
case 1 :
// Ham4Parser.g:832:15: ( thumbspecial )=> thumbspecial
this.pushFollow(Ham4Parser.FOLLOW_thumbspecial_in_handshape13373);
thumbspecial80=this.thumbspecial();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbspecial.add(thumbspecial80.getTree());
break;
}
break;
case 3 :
// Ham4Parser.g:835:13: ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra )
this.pushFollow(Ham4Parser.FOLLOW_fingerlist_in_handshape13454);
fingerlist81=this.fingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerlist.add(fingerlist81.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13468);
fingershapelist82=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist82.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13482);
fingercrossinglist83=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist83.getTree());
// Ham4Parser.g:840:13: ( thumbbetweendefault | thumbextra )
var alt24=2;
var LA24_0 = this.input.LA(1);
if ( (LA24_0==HamBetween) ) {
alt24=1;
}
else if ( (LA24_0==HamThumb||(LA24_0>=HamFingertip && LA24_0<=HamFingerside)) ) {
alt24=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);
throw nvae;
}
switch (alt24) {
case 1 :
// Ham4Parser.g:840:15: thumbbetweendefault
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_handshape13498);
thumbbetweendefault84=this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbbetweendefault.add(thumbbetweendefault84.getTree());
break;
case 2 :
// Ham4Parser.g:840:37: thumbextra
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_handshape13502);
thumbextra85=this.thumbextra();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbextra.add(thumbextra85.getTree());
break;
}
break;
case 4 :
// Ham4Parser.g:843:13: fingerlist fingershapelist fingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_fingerlist_in_handshape13535);
fingerlist86=this.fingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerlist.add(fingerlist86.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingershapelist_in_handshape13549);
fingershapelist87=this.fingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingershapelist.add(fingershapelist87.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingercrossinglist_in_handshape13563);
fingercrossinglist88=this.fingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingercrossinglist.add(fingercrossinglist88.getTree());
break;
}
// AST REWRITE
// elements: thumbextra, fingercrossinglist, basichandshape1, thumbbetweendefault, thumbbetweenexplicit, cautiousfingerlist, fingershapelist, thumbspecial, fingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 850:2: -> ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? )
{
// Ham4Parser.g:850:5: ^( HSHAPE1 basichandshape1 ( cautiousfingerlist )? ( fingerlist )? ( fingershapelist )? ( fingercrossinglist )? ( thumbbetweenexplicit )? ( thumbspecial )? ( thumbbetweendefault )? ( thumbextra )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSHAPE1, "HSHAPE1"), root_1);
this.adaptor.addChild(root_1, stream_basichandshape1.nextTree());
// Ham4Parser.g:850:31: ( cautiousfingerlist )?
if ( stream_cautiousfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_cautiousfingerlist.nextTree());
}
stream_cautiousfingerlist.reset();
// Ham4Parser.g:850:51: ( fingerlist )?
if ( stream_fingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingerlist.nextTree());
}
stream_fingerlist.reset();
// Ham4Parser.g:850:63: ( fingershapelist )?
if ( stream_fingershapelist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingershapelist.nextTree());
}
stream_fingershapelist.reset();
// Ham4Parser.g:850:80: ( fingercrossinglist )?
if ( stream_fingercrossinglist.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingercrossinglist.nextTree());
}
stream_fingercrossinglist.reset();
// Ham4Parser.g:851:4: ( thumbbetweenexplicit )?
if ( stream_thumbbetweenexplicit.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbbetweenexplicit.nextTree());
}
stream_thumbbetweenexplicit.reset();
// Ham4Parser.g:851:26: ( thumbspecial )?
if ( stream_thumbspecial.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbspecial.nextTree());
}
stream_thumbspecial.reset();
// Ham4Parser.g:851:40: ( thumbbetweendefault )?
if ( stream_thumbbetweendefault.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbbetweendefault.nextTree());
}
stream_thumbbetweendefault.reset();
// Ham4Parser.g:851:61: ( thumbextra )?
if ( stream_thumbextra.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumbextra.nextTree());
}
stream_thumbextra.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshape1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
basichandshape1_return: (function() {
Ham4Parser.basichandshape1_return = function(){};
org.antlr.lang.extend(Ham4Parser.basichandshape1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:854:1: basichandshape1 : basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )? -> ^( BASICHDSHP1 ( basichandshape )* ) ;
// $ANTLR start "basichandshape1"
basichandshape1: function() {
var retval = new Ham4Parser.basichandshape1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween90 = null;
var basichandshape89 = null;
var basichandshape91 = null;
var HamBetween90_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_basichandshape=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule basichandshape");
this.trace("ANTLR Parse: basichandshape1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:875:5: ( basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )? -> ^( BASICHDSHP1 ( basichandshape )* ) )
// Ham4Parser.g:875:9: basichandshape ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?
this.pushFollow(Ham4Parser.FOLLOW_basichandshape_in_basichandshape13649);
basichandshape89=this.basichandshape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape.add(basichandshape89.getTree());
// Ham4Parser.g:876:9: ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?
var alt26=2;
alt26 = this.dfa26.predict(this.input);
switch (alt26) {
case 1 :
// Ham4Parser.g:877:13: ( HamBetween handshapeclass )=> HamBetween basichandshape
HamBetween90=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_basichandshape13714); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween90);
this.pushFollow(Ham4Parser.FOLLOW_basichandshape_in_basichandshape13729);
basichandshape91=this.basichandshape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_basichandshape.add(basichandshape91.getTree());
break;
}
// AST REWRITE
// elements: basichandshape
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 882:6: -> ^( BASICHDSHP1 ( basichandshape )* )
{
// Ham4Parser.g:882:9: ^( BASICHDSHP1 ( basichandshape )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(BASICHDSHP1, "BASICHDSHP1"), root_1);
// Ham4Parser.g:882:23: ( basichandshape )*
while ( stream_basichandshape.hasNext() ) {
this.adaptor.addChild(root_1, stream_basichandshape.nextTree());
}
stream_basichandshape.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: basichandshape1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
basichandshape_return: (function() {
Ham4Parser.basichandshape_return = function(){};
org.antlr.lang.extend(Ham4Parser.basichandshape_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:885:1: basichandshape : ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )? -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? ) ;
// $ANTLR start "basichandshape"
basichandshape: function() {
var retval = new Ham4Parser.basichandshape_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNondominant93 = null;
var HamEtc94 = null;
var handshapeclass92 = null;
var handbendandthumb95 = null;
var HamNondominant93_tree=null;
var HamEtc94_tree=null;
var stream_HamNondominant=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNondominant");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_handshapeclass=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshapeclass");
var stream_handbendandthumb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handbendandthumb");
this.trace("ANTLR Parse: basichandshape starts "+this.state.backtracking);
try {
// Ham4Parser.g:907:5: ( ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )? -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? ) )
// Ham4Parser.g:907:9: ( handshapeclass | HamNondominant ) ( HamEtc )? ( handbendandthumb )?
// Ham4Parser.g:907:9: ( handshapeclass | HamNondominant )
var alt27=2;
var LA27_0 = this.input.LA(1);
if ( ((LA27_0>=HamFist && LA27_0<=HamFinger2345)||(LA27_0>=HamPinch12 && LA27_0<=HamCee12open)) ) {
alt27=1;
}
else if ( (LA27_0==HamNondominant) ) {
alt27=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 27, 0, this.input);
throw nvae;
}
switch (alt27) {
case 1 :
// Ham4Parser.g:908:13: handshapeclass
this.pushFollow(Ham4Parser.FOLLOW_handshapeclass_in_basichandshape3797);
handshapeclass92=this.handshapeclass();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshapeclass.add(handshapeclass92.getTree());
break;
case 2 :
// Ham4Parser.g:910:13: HamNondominant
HamNondominant93=this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_basichandshape3821); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNondominant.add(HamNondominant93);
break;
}
// Ham4Parser.g:912:9: ( HamEtc )?
var alt28=2;
var LA28_0 = this.input.LA(1);
if ( (LA28_0==HamEtc) ) {
alt28=1;
}
switch (alt28) {
case 1 :
// Ham4Parser.g:912:11: HamEtc
HamEtc94=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_basichandshape3843); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc94);
break;
}
// Ham4Parser.g:913:9: ( handbendandthumb )?
var alt29=2;
var LA29_0 = this.input.LA(1);
if ( ((LA29_0>=HamThumboutmod && LA29_0<=HamThumbacrossmod)||(LA29_0>=HamThumbopenmod && LA29_0<=HamFingerhookedmod)||(LA29_0>=HamDoublebent && LA29_0<=HamDoublehooked)) ) {
alt29=1;
}
switch (alt29) {
case 1 :
// Ham4Parser.g:913:9: handbendandthumb
this.pushFollow(Ham4Parser.FOLLOW_handbendandthumb_in_basichandshape3856);
handbendandthumb95=this.handbendandthumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handbendandthumb.add(handbendandthumb95.getTree());
break;
}
// AST REWRITE
// elements: handbendandthumb, HamEtc, HamNondominant, handshapeclass
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 915:9: -> ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? )
{
// Ham4Parser.g:915:12: ^( BASICHDSHP ( handshapeclass )? ( HamNondominant )? ( HamEtc )? ( handbendandthumb )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(BASICHDSHP, "BASICHDSHP"), root_1);
// Ham4Parser.g:915:25: ( handshapeclass )?
if ( stream_handshapeclass.hasNext() ) {
this.adaptor.addChild(root_1, stream_handshapeclass.nextTree());
}
stream_handshapeclass.reset();
// Ham4Parser.g:915:41: ( HamNondominant )?
if ( stream_HamNondominant.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamNondominant.nextNode());
}
stream_HamNondominant.reset();
// Ham4Parser.g:915:57: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:915:65: ( handbendandthumb )?
if ( stream_handbendandthumb.hasNext() ) {
this.adaptor.addChild(root_1, stream_handbendandthumb.nextTree());
}
stream_handbendandthumb.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: basichandshape finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handbendandthumb_return: (function() {
Ham4Parser.handbendandthumb_return = function(){};
org.antlr.lang.extend(Ham4Parser.handbendandthumb_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:918:1: handbendandthumb : ( thumbpos ( fingerbending )? | fingerbending ( thumbpos )? );
// $ANTLR start "handbendandthumb"
handbendandthumb: function() {
var retval = new Ham4Parser.handbendandthumb_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbpos96 = null;
var fingerbending97 = null;
var fingerbending98 = null;
var thumbpos99 = null;
this.trace("ANTLR Parse: handbendandthumb starts "+this.state.backtracking);
try {
// Ham4Parser.g:937:5: ( thumbpos ( fingerbending )? | fingerbending ( thumbpos )? )
var alt32=2;
var LA32_0 = this.input.LA(1);
if ( ((LA32_0>=HamThumboutmod && LA32_0<=HamThumbacrossmod)||LA32_0==HamThumbopenmod) ) {
alt32=1;
}
else if ( ((LA32_0>=HamFingerstraightmod && LA32_0<=HamFingerhookedmod)||(LA32_0>=HamDoublebent && LA32_0<=HamDoublehooked)) ) {
alt32=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 32, 0, this.input);
throw nvae;
}
switch (alt32) {
case 1 :
// Ham4Parser.g:938:9: thumbpos ( fingerbending )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbpos_in_handbendandthumb3927);
thumbpos96=this.thumbpos();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbpos96.getTree());
// Ham4Parser.g:939:9: ( fingerbending )?
var alt30=2;
var LA30_0 = this.input.LA(1);
if ( ((LA30_0>=HamFingerstraightmod && LA30_0<=HamFingerhookedmod)||(LA30_0>=HamDoublebent && LA30_0<=HamDoublehooked)) ) {
alt30=1;
}
switch (alt30) {
case 1 :
// Ham4Parser.g:939:11: fingerbending
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_handbendandthumb3939);
fingerbending97=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerbending97.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:941:9: fingerbending ( thumbpos )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_handbendandthumb3958);
fingerbending98=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerbending98.getTree());
// Ham4Parser.g:942:9: ( thumbpos )?
var alt31=2;
var LA31_0 = this.input.LA(1);
if ( ((LA31_0>=HamThumboutmod && LA31_0<=HamThumbacrossmod)||LA31_0==HamThumbopenmod) ) {
alt31=1;
}
switch (alt31) {
case 1 :
// Ham4Parser.g:942:11: thumbpos
this.pushFollow(Ham4Parser.FOLLOW_thumbpos_in_handbendandthumb3970);
thumbpos99=this.thumbpos();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbpos99.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handbendandthumb finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerlist_return: (function() {
Ham4Parser.fingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:945:1: fingerlist : recfingerlist -> ^( FINGERLIST ( recfingerlist )? ) ;
// $ANTLR start "fingerlist"
fingerlist: function() {
var retval = new Ham4Parser.fingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingerlist100 = null;
var stream_recfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingerlist");
this.trace("ANTLR Parse: fingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:960:5: ( recfingerlist -> ^( FINGERLIST ( recfingerlist )? ) )
// Ham4Parser.g:960:9: recfingerlist
this.pushFollow(Ham4Parser.FOLLOW_recfingerlist_in_fingerlist4002);
recfingerlist100=this.recfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingerlist.add(recfingerlist100.getTree());
// AST REWRITE
// elements: recfingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 961:5: -> ^( FINGERLIST ( recfingerlist )? )
{
// Ham4Parser.g:961:8: ^( FINGERLIST ( recfingerlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FINGERLIST, "FINGERLIST"), root_1);
// Ham4Parser.g:961:21: ( recfingerlist )?
if ( stream_recfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingerlist.nextTree());
}
stream_recfingerlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingerlist_return: (function() {
Ham4Parser.recfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:964:1: recfingerlist : ( ( hsfingeritem )=> hsfingeritem recfingerlist )? ;
// $ANTLR start "recfingerlist"
recfingerlist: function() {
var retval = new Ham4Parser.recfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var hsfingeritem101 = null;
var recfingerlist102 = null;
this.trace("ANTLR Parse: recfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:984:5: ( ( ( hsfingeritem )=> hsfingeritem recfingerlist )? )
// Ham4Parser.g:985:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:985:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?
var alt33=2;
alt33 = this.dfa33.predict(this.input);
switch (alt33) {
case 1 :
// Ham4Parser.g:986:13: ( hsfingeritem )=> hsfingeritem recfingerlist
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_recfingerlist4111);
hsfingeritem101=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem101.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingerlist_in_recfingerlist4125);
recfingerlist102=this.recfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingerlist102.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
cautiousfingerlist_return: (function() {
Ham4Parser.cautiousfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.cautiousfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:993:1: cautiousfingerlist : reccautiousfingerlist -> ^( FINGERLIST ( reccautiousfingerlist )? ) ;
// $ANTLR start "cautiousfingerlist"
cautiousfingerlist: function() {
var retval = new Ham4Parser.cautiousfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var reccautiousfingerlist103 = null;
var stream_reccautiousfingerlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule reccautiousfingerlist");
this.trace("ANTLR Parse: cautiousfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1008:5: ( reccautiousfingerlist -> ^( FINGERLIST ( reccautiousfingerlist )? ) )
// Ham4Parser.g:1008:9: reccautiousfingerlist
this.pushFollow(Ham4Parser.FOLLOW_reccautiousfingerlist_in_cautiousfingerlist4165);
reccautiousfingerlist103=this.reccautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_reccautiousfingerlist.add(reccautiousfingerlist103.getTree());
// AST REWRITE
// elements: reccautiousfingerlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1009:5: -> ^( FINGERLIST ( reccautiousfingerlist )? )
{
// Ham4Parser.g:1009:8: ^( FINGERLIST ( reccautiousfingerlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FINGERLIST, "FINGERLIST"), root_1);
// Ham4Parser.g:1009:21: ( reccautiousfingerlist )?
if ( stream_reccautiousfingerlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_reccautiousfingerlist.nextTree());
}
stream_reccautiousfingerlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: cautiousfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
reccautiousfingerlist_return: (function() {
Ham4Parser.reccautiousfingerlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.reccautiousfingerlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1012:1: reccautiousfingerlist : ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )? ;
// $ANTLR start "reccautiousfingerlist"
reccautiousfingerlist: function() {
var retval = new Ham4Parser.reccautiousfingerlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var hsfingeritem104 = null;
var reccautiousfingerlist105 = null;
this.trace("ANTLR Parse: reccautiousfingerlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1032:5: ( ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )? )
// Ham4Parser.g:1033:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1033:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?
var alt34=2;
alt34 = this.dfa34.predict(this.input);
switch (alt34) {
case 1 :
// Ham4Parser.g:1034:13: ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_reccautiousfingerlist4268);
hsfingeritem104=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem104.getTree());
this.pushFollow(Ham4Parser.FOLLOW_reccautiousfingerlist_in_reccautiousfingerlist4282);
reccautiousfingerlist105=this.reccautiousfingerlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, reccautiousfingerlist105.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: reccautiousfingerlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingershapelist_return: (function() {
Ham4Parser.fingershapelist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingershapelist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1041:1: fingershapelist : recfingershapelist -> ^( FISHPLIST ( recfingershapelist )? ) ;
// $ANTLR start "fingershapelist"
fingershapelist: function() {
var retval = new Ham4Parser.fingershapelist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingershapelist106 = null;
var stream_recfingershapelist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingershapelist");
this.trace("ANTLR Parse: fingershapelist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1056:5: ( recfingershapelist -> ^( FISHPLIST ( recfingershapelist )? ) )
// Ham4Parser.g:1056:9: recfingershapelist
this.pushFollow(Ham4Parser.FOLLOW_recfingershapelist_in_fingershapelist4322);
recfingershapelist106=this.recfingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingershapelist.add(recfingershapelist106.getTree());
// AST REWRITE
// elements: recfingershapelist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1057:5: -> ^( FISHPLIST ( recfingershapelist )? )
{
// Ham4Parser.g:1057:8: ^( FISHPLIST ( recfingershapelist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FISHPLIST, "FISHPLIST"), root_1);
// Ham4Parser.g:1057:20: ( recfingershapelist )?
if ( stream_recfingershapelist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingershapelist.nextTree());
}
stream_recfingershapelist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingershapelist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingershapelist_return: (function() {
Ham4Parser.recfingershapelist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingershapelist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1060:1: recfingershapelist : ( ( fingershape )=> fingershape recfingershapelist )? ;
// $ANTLR start "recfingershapelist"
recfingershapelist: function() {
var retval = new Ham4Parser.recfingershapelist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingershape107 = null;
var recfingershapelist108 = null;
this.trace("ANTLR Parse: recfingershapelist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1080:5: ( ( ( fingershape )=> fingershape recfingershapelist )? )
// Ham4Parser.g:1081:9: ( ( fingershape )=> fingershape recfingershapelist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1081:9: ( ( fingershape )=> fingershape recfingershapelist )?
var alt35=2;
alt35 = this.dfa35.predict(this.input);
switch (alt35) {
case 1 :
// Ham4Parser.g:1082:13: ( fingershape )=> fingershape recfingershapelist
this.pushFollow(Ham4Parser.FOLLOW_fingershape_in_recfingershapelist4426);
fingershape107=this.fingershape();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingershape107.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingershapelist_in_recfingershapelist4440);
recfingershapelist108=this.recfingershapelist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingershapelist108.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingershapelist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingercrossinglist_return: (function() {
Ham4Parser.fingercrossinglist_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingercrossinglist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1089:1: fingercrossinglist : recfingercrossinglist -> ^( FICRSSLIST ( recfingercrossinglist )? ) ;
// $ANTLR start "fingercrossinglist"
fingercrossinglist: function() {
var retval = new Ham4Parser.fingercrossinglist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var recfingercrossinglist109 = null;
var stream_recfingercrossinglist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule recfingercrossinglist");
this.trace("ANTLR Parse: fingercrossinglist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1104:5: ( recfingercrossinglist -> ^( FICRSSLIST ( recfingercrossinglist )? ) )
// Ham4Parser.g:1104:9: recfingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_recfingercrossinglist_in_fingercrossinglist4480);
recfingercrossinglist109=this.recfingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_recfingercrossinglist.add(recfingercrossinglist109.getTree());
// AST REWRITE
// elements: recfingercrossinglist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1105:5: -> ^( FICRSSLIST ( recfingercrossinglist )? )
{
// Ham4Parser.g:1105:8: ^( FICRSSLIST ( recfingercrossinglist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FICRSSLIST, "FICRSSLIST"), root_1);
// Ham4Parser.g:1105:21: ( recfingercrossinglist )?
if ( stream_recfingercrossinglist.hasNext() ) {
this.adaptor.addChild(root_1, stream_recfingercrossinglist.nextTree());
}
stream_recfingercrossinglist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingercrossinglist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
recfingercrossinglist_return: (function() {
Ham4Parser.recfingercrossinglist_return = function(){};
org.antlr.lang.extend(Ham4Parser.recfingercrossinglist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1108:1: recfingercrossinglist : ( ( fingercrossing )=> fingercrossing recfingercrossinglist )? ;
// $ANTLR start "recfingercrossinglist"
recfingercrossinglist: function() {
var retval = new Ham4Parser.recfingercrossinglist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingercrossing110 = null;
var recfingercrossinglist111 = null;
this.trace("ANTLR Parse: recfingercrossinglist starts "+this.state.backtracking);
try {
// Ham4Parser.g:1128:5: ( ( ( fingercrossing )=> fingercrossing recfingercrossinglist )? )
// Ham4Parser.g:1129:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:1129:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?
var alt36=2;
alt36 = this.dfa36.predict(this.input);
switch (alt36) {
case 1 :
// Ham4Parser.g:1130:13: ( fingercrossing )=> fingercrossing recfingercrossinglist
this.pushFollow(Ham4Parser.FOLLOW_fingercrossing_in_recfingercrossinglist4581);
fingercrossing110=this.fingercrossing();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingercrossing110.getTree());
this.pushFollow(Ham4Parser.FOLLOW_recfingercrossinglist_in_recfingercrossinglist4595);
recfingercrossinglist111=this.recfingercrossinglist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, recfingercrossinglist111.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: recfingercrossinglist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hsfingeritem_return: (function() {
Ham4Parser.hsfingeritem_return = function(){};
org.antlr.lang.extend(Ham4Parser.hsfingeritem_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1137:1: hsfingeritem : finger ( HamLargemod )? -> ^( HSFINGERITEM finger ( HamLargemod )? ) ;
// $ANTLR start "hsfingeritem"
hsfingeritem: function() {
var retval = new Ham4Parser.hsfingeritem_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamLargemod113 = null;
var finger112 = null;
var HamLargemod113_tree=null;
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_finger=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule finger");
this.trace("ANTLR Parse: hsfingeritem starts "+this.state.backtracking);
try {
// Ham4Parser.g:1154:5: ( finger ( HamLargemod )? -> ^( HSFINGERITEM finger ( HamLargemod )? ) )
// Ham4Parser.g:1154:9: finger ( HamLargemod )?
this.pushFollow(Ham4Parser.FOLLOW_finger_in_hsfingeritem4651);
finger112=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger112.getTree());
// Ham4Parser.g:1155:9: ( HamLargemod )?
var alt37=2;
var LA37_0 = this.input.LA(1);
if ( (LA37_0==HamLargemod) ) {
alt37=1;
}
switch (alt37) {
case 1 :
// Ham4Parser.g:1155:11: HamLargemod
HamLargemod113=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_hsfingeritem4663); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod113);
break;
}
// AST REWRITE
// elements: finger, HamLargemod
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1157:9: -> ^( HSFINGERITEM finger ( HamLargemod )? )
{
// Ham4Parser.g:1157:12: ^( HSFINGERITEM finger ( HamLargemod )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSFINGERITEM, "HSFINGERITEM"), root_1);
this.adaptor.addChild(root_1, stream_finger.nextTree());
// Ham4Parser.g:1157:34: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hsfingeritem finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
digit_return: (function() {
Ham4Parser.digit_return = function(){};
org.antlr.lang.extend(Ham4Parser.digit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1160:1: digit : ( thumb | finger );
// $ANTLR start "digit"
digit: function() {
var retval = new Ham4Parser.digit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb114 = null;
var finger115 = null;
this.trace("ANTLR Parse: digit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1175:5: ( thumb | finger )
var alt38=2;
var LA38_0 = this.input.LA(1);
if ( (LA38_0==HamThumb) ) {
alt38=1;
}
else if ( ((LA38_0>=HamIndexfinger && LA38_0<=HamPinky)) ) {
alt38=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 38, 0, this.input);
throw nvae;
}
switch (alt38) {
case 1 :
// Ham4Parser.g:1175:9: thumb
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_digit4723);
thumb114=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumb114.getTree());
break;
case 2 :
// Ham4Parser.g:1176:9: finger
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_finger_in_digit4733);
finger115=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, finger115.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: digit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
hsdigit_return: (function() {
Ham4Parser.hsdigit_return = function(){};
org.antlr.lang.extend(Ham4Parser.hsdigit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1179:1: hsdigit : ( thumb | hsfingeritem );
// $ANTLR start "hsdigit"
hsdigit: function() {
var retval = new Ham4Parser.hsdigit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb116 = null;
var hsfingeritem117 = null;
this.trace("ANTLR Parse: hsdigit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1194:5: ( thumb | hsfingeritem )
var alt39=2;
var LA39_0 = this.input.LA(1);
if ( (LA39_0==HamThumb) ) {
alt39=1;
}
else if ( ((LA39_0>=HamIndexfinger && LA39_0<=HamPinky)) ) {
alt39=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 39, 0, this.input);
throw nvae;
}
switch (alt39) {
case 1 :
// Ham4Parser.g:1194:9: thumb
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_hsdigit4783);
thumb116=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumb116.getTree());
break;
case 2 :
// Ham4Parser.g:1195:9: hsfingeritem
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_hsdigit4793);
hsfingeritem117=this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, hsfingeritem117.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: hsdigit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingershape_return: (function() {
Ham4Parser.fingershape_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingershape_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1198:1: fingershape : digit fingerbending -> ^( FSHAPE digit fingerbending ) ;
// $ANTLR start "fingershape"
fingershape: function() {
var retval = new Ham4Parser.fingershape_return();
retval.start = this.input.LT(1);
var root_0 = null;
var digit118 = null;
var fingerbending119 = null;
var stream_fingerbending=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerbending");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: fingershape starts "+this.state.backtracking);
try {
// Ham4Parser.g:1215:5: ( digit fingerbending -> ^( FSHAPE digit fingerbending ) )
// Ham4Parser.g:1215:9: digit fingerbending
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingershape4822);
digit118=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(digit118.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_fingershape4832);
fingerbending119=this.fingerbending();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerbending.add(fingerbending119.getTree());
// AST REWRITE
// elements: digit, fingerbending
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1218:9: -> ^( FSHAPE digit fingerbending )
{
// Ham4Parser.g:1218:12: ^( FSHAPE digit fingerbending )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FSHAPE, "FSHAPE"), root_1);
this.adaptor.addChild(root_1, stream_digit.nextTree());
this.adaptor.addChild(root_1, stream_fingerbending.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingershape finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingercrossing_return: (function() {
Ham4Parser.fingercrossing_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingercrossing_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1221:1: fingercrossing : d1= digit fingerpart d2= digit -> ^( FCROSSING $d1 fingerpart $d2) ;
// $ANTLR start "fingercrossing"
fingercrossing: function() {
var retval = new Ham4Parser.fingercrossing_return();
retval.start = this.input.LT(1);
var root_0 = null;
var d1 = null;
var d2 = null;
var fingerpart120 = null;
var stream_fingerpart=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerpart");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: fingercrossing starts "+this.state.backtracking);
try {
// Ham4Parser.g:1239:5: (d1= digit fingerpart d2= digit -> ^( FCROSSING $d1 fingerpart $d2) )
// Ham4Parser.g:1239:9: d1= digit fingerpart d2= digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingercrossing4892);
d1=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(d1.getTree());
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_fingercrossing4902);
fingerpart120=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerpart.add(fingerpart120.getTree());
this.pushFollow(Ham4Parser.FOLLOW_digit_in_fingercrossing4916);
d2=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(d2.getTree());
// AST REWRITE
// elements: fingerpart, d2, d1
// token labels: 
// rule labels: d1, d2, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_d1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token d1",d1!=null?d1.tree:null);
var stream_d2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token d2",d2!=null?d2.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1243:9: -> ^( FCROSSING $d1 fingerpart $d2)
{
// Ham4Parser.g:1243:12: ^( FCROSSING $d1 fingerpart $d2)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FCROSSING, "FCROSSING"), root_1);
this.adaptor.addChild(root_1, stream_d1.nextTree());
this.adaptor.addChild(root_1, stream_fingerpart.nextTree());
this.adaptor.addChild(root_1, stream_d2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingercrossing finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbspecial_return: (function() {
Ham4Parser.thumbspecial_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbspecial_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1246:1: thumbspecial : ( thumbbetween | thumbextra );
// $ANTLR start "thumbspecial"
thumbspecial: function() {
var retval = new Ham4Parser.thumbspecial_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbbetween121 = null;
var thumbextra122 = null;
this.trace("ANTLR Parse: thumbspecial starts "+this.state.backtracking);
try {
// Ham4Parser.g:1261:5: ( thumbbetween | thumbextra )
var alt40=2;
var LA40_0 = this.input.LA(1);
if ( ((LA40_0>=HamIndexfinger && LA40_0<=HamPinky)||LA40_0==HamBetween) ) {
alt40=1;
}
else if ( (LA40_0==HamThumb||(LA40_0>=HamFingertip && LA40_0<=HamFingerside)) ) {
alt40=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 40, 0, this.input);
throw nvae;
}
switch (alt40) {
case 1 :
// Ham4Parser.g:1261:9: thumbbetween
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetween_in_thumbspecial4976);
thumbbetween121=this.thumbbetween();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetween121.getTree());
break;
case 2 :
// Ham4Parser.g:1262:9: thumbextra
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_thumbspecial4986);
thumbextra122=this.thumbextra();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbextra122.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbspecial finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetween_return: (function() {
Ham4Parser.thumbbetween_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetween_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1265:1: thumbbetween : ( thumbbetweenexplicit | thumbbetweendefault );
// $ANTLR start "thumbbetween"
thumbbetween: function() {
var retval = new Ham4Parser.thumbbetween_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbbetweenexplicit123 = null;
var thumbbetweendefault124 = null;
this.trace("ANTLR Parse: thumbbetween starts "+this.state.backtracking);
try {
// Ham4Parser.g:1280:5: ( thumbbetweenexplicit | thumbbetweendefault )
var alt41=2;
var LA41_0 = this.input.LA(1);
if ( ((LA41_0>=HamIndexfinger && LA41_0<=HamPinky)) ) {
alt41=1;
}
else if ( (LA41_0==HamBetween) ) {
alt41=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);
throw nvae;
}
switch (alt41) {
case 1 :
// Ham4Parser.g:1280:9: thumbbetweenexplicit
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweenexplicit_in_thumbbetween5015);
thumbbetweenexplicit123=this.thumbbetweenexplicit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetweenexplicit123.getTree());
break;
case 2 :
// Ham4Parser.g:1281:9: thumbbetweendefault
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_thumbbetween5025);
thumbbetweendefault124=this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, thumbbetweendefault124.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetween finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetweenexplicit_return: (function() {
Ham4Parser.thumbbetweenexplicit_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetweenexplicit_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1284:1: thumbbetweenexplicit : finger HamBetween finger -> ^( THSPECIAL ^( HamBetween ( finger )* ) ) ;
// $ANTLR start "thumbbetweenexplicit"
thumbbetweenexplicit: function() {
var retval = new Ham4Parser.thumbbetweenexplicit_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween126 = null;
var finger125 = null;
var finger127 = null;
var HamBetween126_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_finger=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule finger");
this.trace("ANTLR Parse: thumbbetweenexplicit starts "+this.state.backtracking);
try {
// Ham4Parser.g:1302:5: ( finger HamBetween finger -> ^( THSPECIAL ^( HamBetween ( finger )* ) ) )
// Ham4Parser.g:1302:9: finger HamBetween finger
this.pushFollow(Ham4Parser.FOLLOW_finger_in_thumbbetweenexplicit5054);
finger125=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger125.getTree());
HamBetween126=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_thumbbetweenexplicit5064); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween126);
this.pushFollow(Ham4Parser.FOLLOW_finger_in_thumbbetweenexplicit5075);
finger127=this.finger();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_finger.add(finger127.getTree());
// AST REWRITE
// elements: finger, HamBetween
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1306:9: -> ^( THSPECIAL ^( HamBetween ( finger )* ) )
{
// Ham4Parser.g:1306:12: ^( THSPECIAL ^( HamBetween ( finger )* ) )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
// Ham4Parser.g:1306:24: ^( HamBetween ( finger )* )
{
var root_2 = this.adaptor.nil();
root_2 = this.adaptor.becomeRoot(stream_HamBetween.nextNode(), root_2);
// Ham4Parser.g:1306:37: ( finger )*
while ( stream_finger.hasNext() ) {
this.adaptor.addChild(root_2, stream_finger.nextTree());
}
stream_finger.reset();
this.adaptor.addChild(root_1, root_2);
}
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetweenexplicit finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbbetweendefault_return: (function() {
Ham4Parser.thumbbetweendefault_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbbetweendefault_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1309:1: thumbbetweendefault : HamBetween -> ^( THSPECIAL HamBetween ) ;
// $ANTLR start "thumbbetweendefault"
thumbbetweendefault: function() {
var retval = new Ham4Parser.thumbbetweendefault_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween128 = null;
var HamBetween128_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
this.trace("ANTLR Parse: thumbbetweendefault starts "+this.state.backtracking);
try {
// Ham4Parser.g:1325:5: ( HamBetween -> ^( THSPECIAL HamBetween ) )
// Ham4Parser.g:1325:9: HamBetween
HamBetween128=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_thumbbetweendefault5134); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween128);
// AST REWRITE
// elements: HamBetween
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1327:9: -> ^( THSPECIAL HamBetween )
{
// Ham4Parser.g:1327:12: ^( THSPECIAL HamBetween )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
this.adaptor.addChild(root_1, stream_HamBetween.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbbetweendefault finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbextra_return: (function() {
Ham4Parser.thumbextra_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbextra_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1330:1: thumbextra : ( thumb | fingerpart ) -> ^( THSPECIAL ( thumb )? ( fingerpart )? ) ;
// $ANTLR start "thumbextra"
thumbextra: function() {
var retval = new Ham4Parser.thumbextra_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumb129 = null;
var fingerpart130 = null;
var stream_fingerpart=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerpart");
var stream_thumb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumb");
this.trace("ANTLR Parse: thumbextra starts "+this.state.backtracking);
try {
// Ham4Parser.g:1350:5: ( ( thumb | fingerpart ) -> ^( THSPECIAL ( thumb )? ( fingerpart )? ) )
// Ham4Parser.g:1351:5: ( thumb | fingerpart )
// Ham4Parser.g:1351:5: ( thumb | fingerpart )
var alt42=2;
var LA42_0 = this.input.LA(1);
if ( (LA42_0==HamThumb) ) {
alt42=1;
}
else if ( ((LA42_0>=HamFingertip && LA42_0<=HamFingerside)) ) {
alt42=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 42, 0, this.input);
throw nvae;
}
switch (alt42) {
case 1 :
// Ham4Parser.g:1352:9: thumb
this.pushFollow(Ham4Parser.FOLLOW_thumb_in_thumbextra5200);
thumb129=this.thumb();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumb.add(thumb129.getTree());
break;
case 2 :
// Ham4Parser.g:1354:9: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_thumbextra5216);
fingerpart130=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerpart.add(fingerpart130.getTree());
break;
}
// AST REWRITE
// elements: thumb, fingerpart
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1356:5: -> ^( THSPECIAL ( thumb )? ( fingerpart )? )
{
// Ham4Parser.g:1356:8: ^( THSPECIAL ( thumb )? ( fingerpart )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THSPECIAL, "THSPECIAL"), root_1);
// Ham4Parser.g:1356:20: ( thumb )?
if ( stream_thumb.hasNext() ) {
this.adaptor.addChild(root_1, stream_thumb.nextTree());
}
stream_thumb.reset();
// Ham4Parser.g:1356:27: ( fingerpart )?
if ( stream_fingerpart.hasNext() ) {
this.adaptor.addChild(root_1, stream_fingerpart.nextTree());
}
stream_fingerpart.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbextra finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir2_return: (function() {
Ham4Parser.extfidir2_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1362:1: extfidir2 : ( extfidir1 | splitextfidir2 ) -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? ) ;
// $ANTLR start "extfidir2"
extfidir2: function() {
var retval = new Ham4Parser.extfidir2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidir1131 = null;
var splitextfidir2132 = null;
var stream_splitextfidir2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitextfidir2");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: extfidir2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1382:5: ( ( extfidir1 | splitextfidir2 ) -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? ) )
// Ham4Parser.g:1383:5: ( extfidir1 | splitextfidir2 )
// Ham4Parser.g:1383:5: ( extfidir1 | splitextfidir2 )
var alt43=2;
var LA43_0 = this.input.LA(1);
if ( ((LA43_0>=HamExtfingeru && LA43_0<=HamExtfingeruo)) ) {
alt43=1;
}
else if ( (LA43_0==HamParbegin) ) {
alt43=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 43, 0, this.input);
throw nvae;
}
switch (alt43) {
case 1 :
// Ham4Parser.g:1384:9: extfidir1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_extfidir25282);
extfidir1131=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1131.getTree());
break;
case 2 :
// Ham4Parser.g:1386:9: splitextfidir2
this.pushFollow(Ham4Parser.FOLLOW_splitextfidir2_in_extfidir25298);
splitextfidir2132=this.splitextfidir2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitextfidir2.add(splitextfidir2132.getTree());
break;
}
// AST REWRITE
// elements: extfidir1, splitextfidir2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1388:5: -> ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? )
{
// Ham4Parser.g:1388:8: ^( EXTFIDIR2 ( extfidir1 )? ( splitextfidir2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR2, "EXTFIDIR2"), root_1);
// Ham4Parser.g:1388:20: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:1388:31: ( splitextfidir2 )?
if ( stream_splitextfidir2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitextfidir2.nextTree());
}
stream_splitextfidir2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidir2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitextfidir2_return: (function() {
Ham4Parser.splitextfidir2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitextfidir2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1391:1: splitextfidir2 : HamParbegin extfidir1 HamPlus extfidir1 HamParend ;
// $ANTLR start "splitextfidir2"
splitextfidir2: function() {
var retval = new Ham4Parser.splitextfidir2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin133 = null;
var HamPlus135 = null;
var HamParend137 = null;
var extfidir1134 = null;
var extfidir1136 = null;
var HamParbegin133_tree=null;
var HamPlus135_tree=null;
var HamParend137_tree=null;
this.trace("ANTLR Parse: splitextfidir2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1409:5: ( HamParbegin extfidir1 HamPlus extfidir1 HamParend )
// Ham4Parser.g:1409:9: HamParbegin extfidir1 HamPlus extfidir1 HamParend
root_0 = this.adaptor.nil();
HamParbegin133=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitextfidir25349); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_splitextfidir25361);
extfidir1134=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, extfidir1134.getTree());
HamPlus135=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitextfidir25371); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_splitextfidir25383);
extfidir1136=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, extfidir1136.getTree());
HamParend137=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitextfidir25393); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitextfidir2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir1_return: (function() {
Ham4Parser.extfidir1_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1416:1: extfidir1 : extfidir ( HamBetween extfidir )? ( HamOrirelative )? -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* ) ;
// $ANTLR start "extfidir1"
extfidir1: function() {
var retval = new Ham4Parser.extfidir1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween139 = null;
var HamOrirelative141 = null;
var extfidir138 = null;
var extfidir140 = null;
var HamBetween139_tree=null;
var HamOrirelative141_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_HamOrirelative=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamOrirelative");
var stream_extfidir=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir");
this.trace("ANTLR Parse: extfidir1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1438:5: ( extfidir ( HamBetween extfidir )? ( HamOrirelative )? -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* ) )
// Ham4Parser.g:1438:9: extfidir ( HamBetween extfidir )? ( HamOrirelative )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir_in_extfidir15424);
extfidir138=this.extfidir();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir.add(extfidir138.getTree());
// Ham4Parser.g:1439:9: ( HamBetween extfidir )?
var alt44=2;
var LA44_0 = this.input.LA(1);
if ( (LA44_0==HamBetween) ) {
alt44=1;
}
switch (alt44) {
case 1 :
// Ham4Parser.g:1440:13: HamBetween extfidir
HamBetween139=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_extfidir15448); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween139);
this.pushFollow(Ham4Parser.FOLLOW_extfidir_in_extfidir15462);
extfidir140=this.extfidir();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir.add(extfidir140.getTree());
break;
}
// Ham4Parser.g:1443:9: ( HamOrirelative )?
var alt45=2;
var LA45_0 = this.input.LA(1);
if ( (LA45_0==HamOrirelative) ) {
alt45=1;
}
switch (alt45) {
case 1 :
// Ham4Parser.g:1444:13: HamOrirelative
HamOrirelative141=this.match(this.input,HamOrirelative,Ham4Parser.FOLLOW_HamOrirelative_in_extfidir15497); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamOrirelative.add(HamOrirelative141);
break;
}
// AST REWRITE
// elements: extfidir, HamOrirelative
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1446:6: -> ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* )
{
// Ham4Parser.g:1446:9: ^( EXTFIDIR1 ( extfidir )* ( HamOrirelative )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR1, "EXTFIDIR1"), root_1);
// Ham4Parser.g:1446:21: ( extfidir )*
while ( stream_extfidir.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir.nextTree());
}
stream_extfidir.reset();
// Ham4Parser.g:1446:31: ( HamOrirelative )*
while ( stream_HamOrirelative.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamOrirelative.nextNode());
}
stream_HamOrirelative.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidir1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor2_return: (function() {
Ham4Parser.palmor2_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1452:1: palmor2 : ( palmor1 | splitpalmor2 ) -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? ) ;
// $ANTLR start "palmor2"
palmor2: function() {
var retval = new Ham4Parser.palmor2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var palmor1142 = null;
var splitpalmor2143 = null;
var stream_splitpalmor2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitpalmor2");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
this.trace("ANTLR Parse: palmor2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1472:5: ( ( palmor1 | splitpalmor2 ) -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? ) )
// Ham4Parser.g:1473:5: ( palmor1 | splitpalmor2 )
// Ham4Parser.g:1473:5: ( palmor1 | splitpalmor2 )
var alt46=2;
var LA46_0 = this.input.LA(1);
if ( ((LA46_0>=HamPalmu && LA46_0<=HamPalmul)) ) {
alt46=1;
}
else if ( (LA46_0==HamParbegin) ) {
alt46=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 46, 0, this.input);
throw nvae;
}
switch (alt46) {
case 1 :
// Ham4Parser.g:1474:9: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_palmor25569);
palmor1142=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1142.getTree());
break;
case 2 :
// Ham4Parser.g:1476:9: splitpalmor2
this.pushFollow(Ham4Parser.FOLLOW_splitpalmor2_in_palmor25585);
splitpalmor2143=this.splitpalmor2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitpalmor2.add(splitpalmor2143.getTree());
break;
}
// AST REWRITE
// elements: palmor1, splitpalmor2
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1478:5: -> ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? )
{
// Ham4Parser.g:1478:8: ^( PALMOR2 ( palmor1 )? ( splitpalmor2 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PALMOR2, "PALMOR2"), root_1);
// Ham4Parser.g:1478:18: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
// Ham4Parser.g:1478:27: ( splitpalmor2 )?
if ( stream_splitpalmor2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitpalmor2.nextTree());
}
stream_splitpalmor2.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitpalmor2_return: (function() {
Ham4Parser.splitpalmor2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitpalmor2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1481:1: splitpalmor2 : HamParbegin palmor1 HamPlus palmor1 HamParend ;
// $ANTLR start "splitpalmor2"
splitpalmor2: function() {
var retval = new Ham4Parser.splitpalmor2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin144 = null;
var HamPlus146 = null;
var HamParend148 = null;
var palmor1145 = null;
var palmor1147 = null;
var HamParbegin144_tree=null;
var HamPlus146_tree=null;
var HamParend148_tree=null;
this.trace("ANTLR Parse: splitpalmor2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1499:5: ( HamParbegin palmor1 HamPlus palmor1 HamParend )
// Ham4Parser.g:1499:9: HamParbegin palmor1 HamPlus palmor1 HamParend
root_0 = this.adaptor.nil();
HamParbegin144=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitpalmor25636); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_splitpalmor25648);
palmor1145=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, palmor1145.getTree());
HamPlus146=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitpalmor25658); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_splitpalmor25670);
palmor1147=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, palmor1147.getTree());
HamParend148=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitpalmor25680); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitpalmor2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor1_return: (function() {
Ham4Parser.palmor1_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1506:1: palmor1 : palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )? -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* ) ;
// $ANTLR start "palmor1"
palmor1: function() {
var retval = new Ham4Parser.palmor1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween150 = null;
var HamEtc152 = null;
var HamOrirelative153 = null;
var palmor149 = null;
var palmor151 = null;
var HamBetween150_tree=null;
var HamEtc152_tree=null;
var HamOrirelative153_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_HamOrirelative=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamOrirelative");
var stream_palmor=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor");
this.trace("ANTLR Parse: palmor1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1530:5: ( palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )? -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* ) )
// Ham4Parser.g:1530:9: palmor ( HamBetween palmor | HamEtc )? ( HamOrirelative )?
this.pushFollow(Ham4Parser.FOLLOW_palmor_in_palmor15711);
palmor149=this.palmor();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor.add(palmor149.getTree());
// Ham4Parser.g:1531:9: ( HamBetween palmor | HamEtc )?
var alt47=3;
var LA47_0 = this.input.LA(1);
if ( (LA47_0==HamBetween) ) {
alt47=1;
}
else if ( (LA47_0==HamEtc) ) {
alt47=2;
}
switch (alt47) {
case 1 :
// Ham4Parser.g:1532:13: HamBetween palmor
HamBetween150=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_palmor15735); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween150);
this.pushFollow(Ham4Parser.FOLLOW_palmor_in_palmor15749);
palmor151=this.palmor();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor.add(palmor151.getTree());
break;
case 2 :
// Ham4Parser.g:1535:7: HamEtc
HamEtc152=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_palmor15767); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc152);
break;
}
// Ham4Parser.g:1537:9: ( HamOrirelative )?
var alt48=2;
var LA48_0 = this.input.LA(1);
if ( (LA48_0==HamOrirelative) ) {
alt48=1;
}
switch (alt48) {
case 1 :
// Ham4Parser.g:1538:13: HamOrirelative
HamOrirelative153=this.match(this.input,HamOrirelative,Ham4Parser.FOLLOW_HamOrirelative_in_palmor15802); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamOrirelative.add(HamOrirelative153);
break;
}
// AST REWRITE
// elements: HamOrirelative, palmor, HamEtc
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1540:6: -> ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* )
{
// Ham4Parser.g:1540:9: ^( PALMOR1 ( palmor )* ( HamEtc )* ( HamOrirelative )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PALMOR1, "PALMOR1"), root_1);
// Ham4Parser.g:1540:19: ( palmor )*
while ( stream_palmor.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor.nextTree());
}
stream_palmor.reset();
// Ham4Parser.g:1540:27: ( HamEtc )*
while ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:1540:35: ( HamOrirelative )*
while ( stream_HamOrirelative.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamOrirelative.nextNode());
}
stream_HamOrirelative.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location2_return: (function() {
Ham4Parser.location2_return = function(){};
org.antlr.lang.extend(Ham4Parser.location2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1546:1: location2 : ( location1as2 | location2not1 ) ;
// $ANTLR start "location2"
location2: function() {
var retval = new Ham4Parser.location2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var location1as2154 = null;
var location2not1155 = null;
this.trace("ANTLR Parse: location2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1565:5: ( ( location1as2 | location2not1 ) )
// Ham4Parser.g:1566:5: ( location1as2 | location2not1 )
root_0 = this.adaptor.nil();
// Ham4Parser.g:1566:5: ( location1as2 | location2not1 )
var alt49=2;
alt49 = this.dfa49.predict(this.input);
switch (alt49) {
case 1 :
// Ham4Parser.g:1567:9: location1as2
this.pushFollow(Ham4Parser.FOLLOW_location1as2_in_location25877);
location1as2154=this.location1as2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location1as2154.getTree());
break;
case 2 :
// Ham4Parser.g:1569:9: location2not1
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_location25893);
location2not1155=this.location2not1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location2not1155.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location1as2_return: (function() {
Ham4Parser.location1as2_return = function(){};
org.antlr.lang.extend(Ham4Parser.location1as2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1573:1: location1as2 : location1 -> ^( LOC2 location1 ) ;
// $ANTLR start "location1as2"
location1as2: function() {
var retval = new Ham4Parser.location1as2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var location1156 = null;
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
this.trace("ANTLR Parse: location1as2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1588:5: ( location1 -> ^( LOC2 location1 ) )
// Ham4Parser.g:1588:9: location1
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location1as25928);
location1156=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1156.getTree());
// AST REWRITE
// elements: location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1589:6: -> ^( LOC2 location1 )
{
// Ham4Parser.g:1589:9: ^( LOC2 location1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
this.adaptor.addChild(root_1, stream_location1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location1as2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location2not1_return: (function() {
Ham4Parser.location2not1_return = function(){};
org.antlr.lang.extend(Ham4Parser.location2not1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1592:1: location2not1 : ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) ) ;
// $ANTLR start "location2not1"
location2not1: function() {
var retval = new Ham4Parser.location2not1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNeutralspace158 = null;
var HamArmextended159 = null;
var HamParbegin161 = null;
var HamPlus163 = null;
var HamParend165 = null;
var handconstellation157 = null;
var locationbody160 = null;
var location1162 = null;
var location1164 = null;
var HamNeutralspace158_tree=null;
var HamArmextended159_tree=null;
var HamParbegin161_tree=null;
var HamPlus163_tree=null;
var HamParend165_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_HamNeutralspace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNeutralspace");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_locationbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbody");
var stream_handconstellation=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconstellation");
this.trace("ANTLR Parse: location2not1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1625:5: ( ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) ) )
// Ham4Parser.g:1626:5: ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) )
// Ham4Parser.g:1626:5: ( ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? ) -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? ) | HamParbegin location1 HamPlus location1 HamParend -> ^( LOC2 ( location1 )* ) )
var alt53=2;
var LA53_0 = this.input.LA(1);
if ( (LA53_0==HamParbegin) ) {
var LA53_1 = this.input.LA(2);
if ( (this.synpred19_Ham4Parser()) ) {
alt53=1;
}
else if ( (true) ) {
alt53=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 53, 1, this.input);
throw nvae;
}
}
else if ( ((LA53_0>=HamClose && LA53_0<=HamTouch)) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else if ( ((LA53_0>=HamInterlock && LA53_0<=HamCross)) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else if ( (LA53_0==HamSeqbegin) && (this.synpred19_Ham4Parser())) {
alt53=1;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 53, 0, this.input);
throw nvae;
}
switch (alt53) {
case 1 :
// Ham4Parser.g:1627:9: ( handconstellation )=> handconstellation ( HamNeutralspace ( HamArmextended )? | ( locationbody )? )
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_location2not16006);
handconstellation157=this.handconstellation();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconstellation.add(handconstellation157.getTree());
// Ham4Parser.g:1630:9: ( HamNeutralspace ( HamArmextended )? | ( locationbody )? )
var alt52=2;
var LA52_0 = this.input.LA(1);
if ( (LA52_0==HamNeutralspace) ) {
alt52=1;
}
else if ( (LA52_0==EOF||LA52_0==HamPlus||(LA52_0>=HamEarlobe && LA52_0<=HamShouldertop)||LA52_0==HamReplace||(LA52_0>=HamTongue && LA52_0<=HamStomach)||(LA52_0>=HamHead && LA52_0<=HamLrat)||(LA52_0>=HamNomotion && LA52_0<=HamMovex)||(LA52_0>=HamFingerplay && LA52_0<=HamCircler)||(LA52_0>=HamRepeatfromstart && LA52_0<=HamRepeatreverse)||(LA52_0>=HamNodding && LA52_0<=HamCircleuo)) ) {
alt52=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 52, 0, this.input);
throw nvae;
}
switch (alt52) {
case 1 :
// Ham4Parser.g:1631:13: HamNeutralspace ( HamArmextended )?
HamNeutralspace158=this.match(this.input,HamNeutralspace,Ham4Parser.FOLLOW_HamNeutralspace_in_location2not16030); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNeutralspace.add(HamNeutralspace158);
// Ham4Parser.g:1632:13: ( HamArmextended )?
var alt50=2;
var LA50_0 = this.input.LA(1);
if ( (LA50_0==HamArmextended) ) {
alt50=1;
}
switch (alt50) {
case 1 :
// Ham4Parser.g:1632:15: HamArmextended
HamArmextended159=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_location2not16046); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended159);
break;
}
break;
case 2 :
// Ham4Parser.g:1634:13: ( locationbody )?
// Ham4Parser.g:1634:13: ( locationbody )?
var alt51=2;
var LA51_0 = this.input.LA(1);
if ( ((LA51_0>=HamEarlobe && LA51_0<=HamShouldertop)||(LA51_0>=HamTongue && LA51_0<=HamStomach)||(LA51_0>=HamHead && LA51_0<=HamLrat)) ) {
alt51=1;
}
switch (alt51) {
case 1 :
// Ham4Parser.g:1634:15: locationbody
this.pushFollow(Ham4Parser.FOLLOW_locationbody_in_location2not16075);
locationbody160=this.locationbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbody.add(locationbody160.getTree());
break;
}
break;
}
// AST REWRITE
// elements: handconstellation, HamArmextended, locationbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1636:6: -> ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? )
{
// Ham4Parser.g:1636:9: ^( LOC2 handconstellation ( HamArmextended )? ( locationbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
this.adaptor.addChild(root_1, stream_handconstellation.nextTree());
// Ham4Parser.g:1636:34: ( HamArmextended )?
if ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:1636:50: ( locationbody )?
if ( stream_locationbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbody.nextTree());
}
stream_locationbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:1638:9: HamParbegin location1 HamPlus location1 HamParend
HamParbegin161=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_location2not16123); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin161);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location2not16133);
location1162=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1162.getTree());
HamPlus163=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_location2not16143); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus163);
this.pushFollow(Ham4Parser.FOLLOW_location1_in_location2not16153);
location1164=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1164.getTree());
HamParend165=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_location2not16163); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend165);
// AST REWRITE
// elements: location1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1643:6: -> ^( LOC2 ( location1 )* )
{
// Ham4Parser.g:1643:9: ^( LOC2 ( location1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC2, "LOC2"), root_1);
// Ham4Parser.g:1643:16: ( location1 )*
while ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location2not1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
location1_return: (function() {
Ham4Parser.location1_return = function(){};
org.antlr.lang.extend(Ham4Parser.location1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1647:1: location1 : ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm ) -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? ) ;
// $ANTLR start "location1"
location1: function() {
var retval = new Ham4Parser.location1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var locationindexuse166 = null;
var locationhand167 = null;
var locationbodyarm168 = null;
var stream_locationindexuse=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationindexuse");
var stream_locationhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationhand");
var stream_locationbodyarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbodyarm");
this.trace("ANTLR Parse: location1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:1673:5: ( ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm ) -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? ) )
// Ham4Parser.g:1674:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )
// Ham4Parser.g:1674:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )
var alt54=3;
alt54 = this.dfa54.predict(this.input);
switch (alt54) {
case 1 :
// Ham4Parser.g:1675:9: ( locationindexuse )=> locationindexuse
this.pushFollow(Ham4Parser.FOLLOW_locationindexuse_in_location16268);
locationindexuse166=this.locationindexuse();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationindexuse.add(locationindexuse166.getTree());
break;
case 2 :
// Ham4Parser.g:1679:9: ( levelhand )=> locationhand
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_location16308);
locationhand167=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand167.getTree());
break;
case 3 :
// Ham4Parser.g:1683:9: locationbodyarm
this.pushFollow(Ham4Parser.FOLLOW_locationbodyarm_in_location16324);
locationbodyarm168=this.locationbodyarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbodyarm.add(locationbodyarm168.getTree());
break;
}
// AST REWRITE
// elements: locationhand, locationindexuse, locationbodyarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1685:5: -> ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? )
{
// Ham4Parser.g:1685:8: ^( LOC1 ( locationindexuse )? ( locationhand )? ( locationbodyarm )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOC1, "LOC1"), root_1);
// Ham4Parser.g:1685:15: ( locationindexuse )?
if ( stream_locationindexuse.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationindexuse.nextTree());
}
stream_locationindexuse.reset();
// Ham4Parser.g:1685:33: ( locationhand )?
if ( stream_locationhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationhand.nextTree());
}
stream_locationhand.reset();
// Ham4Parser.g:1685:47: ( locationbodyarm )?
if ( stream_locationbodyarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbodyarm.nextTree());
}
stream_locationbodyarm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: location1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationindexdefine_return: (function() {
Ham4Parser.locationindexdefine_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationindexdefine_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1688:1: locationindexdefine : digit HamCoreftag ;
// $ANTLR start "locationindexdefine"
locationindexdefine: function() {
var retval = new Ham4Parser.locationindexdefine_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamCoreftag170 = null;
var digit169 = null;
var HamCoreftag170_tree=null;
this.trace("ANTLR Parse: locationindexdefine starts "+this.state.backtracking);
try {
// Ham4Parser.g:1704:5: ( digit HamCoreftag )
// Ham4Parser.g:1705:9: digit HamCoreftag
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_digit_in_locationindexdefine6384);
digit169=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit169.getTree());
HamCoreftag170=this.match(this.input,HamCoreftag,Ham4Parser.FOLLOW_HamCoreftag_in_locationindexdefine6394); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationindexdefine finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationindexuse_return: (function() {
Ham4Parser.locationindexuse_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationindexuse_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1709:1: locationindexuse : digit HamCorefref ;
// $ANTLR start "locationindexuse"
locationindexuse: function() {
var retval = new Ham4Parser.locationindexuse_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamCorefref172 = null;
var digit171 = null;
var HamCorefref172_tree=null;
this.trace("ANTLR Parse: locationindexuse starts "+this.state.backtracking);
try {
// Ham4Parser.g:1725:5: ( digit HamCorefref )
// Ham4Parser.g:1726:9: digit HamCorefref
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_digit_in_locationindexuse6431);
digit171=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit171.getTree());
HamCorefref172=this.match(this.input,HamCorefref,Ham4Parser.FOLLOW_HamCorefref_in_locationindexuse6441); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationindexuse finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationbodyarm_return: (function() {
Ham4Parser.locationbodyarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationbodyarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1730:1: locationbodyarm : ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm ) -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* ) ;
// $ANTLR start "locationbodyarm"
locationbodyarm: function() {
var retval = new Ham4Parser.locationbodyarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNeutralspace173 = null;
var HamArmextended174 = null;
var locationbody175 = null;
var locationarm176 = null;
var HamNeutralspace173_tree=null;
var HamArmextended174_tree=null;
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_HamNeutralspace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNeutralspace");
var stream_locationbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationbody");
var stream_locationarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationarm");
this.trace("ANTLR Parse: locationbodyarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1755:5: ( ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm ) -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* ) )
// Ham4Parser.g:1756:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )
// Ham4Parser.g:1756:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )
var alt56=3;
alt56 = this.dfa56.predict(this.input);
switch (alt56) {
case 1 :
// Ham4Parser.g:1757:9: HamNeutralspace ( HamArmextended )?
HamNeutralspace173=this.match(this.input,HamNeutralspace,Ham4Parser.FOLLOW_HamNeutralspace_in_locationbodyarm6484); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNeutralspace.add(HamNeutralspace173);
// Ham4Parser.g:1758:9: ( HamArmextended )?
var alt55=2;
var LA55_0 = this.input.LA(1);
if ( (LA55_0==HamArmextended) ) {
alt55=1;
}
switch (alt55) {
case 1 :
// Ham4Parser.g:1758:11: HamArmextended
HamArmextended174=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_locationbodyarm6496); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended174);
break;
}
break;
case 2 :
// Ham4Parser.g:1760:9: ( levelbody )=> locationbody
this.pushFollow(Ham4Parser.FOLLOW_locationbody_in_locationbodyarm6539);
locationbody175=this.locationbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationbody.add(locationbody175.getTree());
break;
case 3 :
// Ham4Parser.g:1764:9: locationarm
this.pushFollow(Ham4Parser.FOLLOW_locationarm_in_locationbodyarm6555);
locationarm176=this.locationarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationarm.add(locationarm176.getTree());
break;
}
// AST REWRITE
// elements: HamArmextended, locationbody, locationarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1766:5: -> ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* )
{
// Ham4Parser.g:1766:8: ^( LOCTNBODYARM ( HamArmextended )* ( locationbody )* ( locationarm )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNBODYARM, "LOCTNBODYARM"), root_1);
// Ham4Parser.g:1766:23: ( HamArmextended )*
while ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:1766:39: ( locationbody )*
while ( stream_locationbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationbody.nextTree());
}
stream_locationbody.reset();
// Ham4Parser.g:1766:53: ( locationarm )*
while ( stream_locationarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationarm.nextTree());
}
stream_locationarm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationbodyarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationbody_return: (function() {
Ham4Parser.locationbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1769:1: locationbody : levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? ) ;
// $ANTLR start "locationbody"
locationbody: function() {
var retval = new Ham4Parser.locationbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBehind178 = null;
var levelcomplexbody177 = null;
var contactbody179 = null;
var HamBehind178_tree=null;
var stream_HamBehind=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBehind");
var stream_levelcomplexbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexbody");
var stream_contactbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactbody");
this.trace("ANTLR Parse: locationbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1787:5: ( levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? ) )
// Ham4Parser.g:1787:9: levelcomplexbody ( HamBehind )? ( ( contactbody )=> contactbody )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexbody_in_locationbody6609);
levelcomplexbody177=this.levelcomplexbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexbody.add(levelcomplexbody177.getTree());
// Ham4Parser.g:1788:9: ( HamBehind )?
var alt57=2;
alt57 = this.dfa57.predict(this.input);
switch (alt57) {
case 1 :
// Ham4Parser.g:1788:11: HamBehind
HamBehind178=this.match(this.input,HamBehind,Ham4Parser.FOLLOW_HamBehind_in_locationbody6621); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBehind.add(HamBehind178);
break;
}
// Ham4Parser.g:1789:9: ( ( contactbody )=> contactbody )?
var alt58=2;
alt58 = this.dfa58.predict(this.input);
switch (alt58) {
case 1 :
// Ham4Parser.g:1789:11: ( contactbody )=> contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_locationbody6644);
contactbody179=this.contactbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactbody.add(contactbody179.getTree());
break;
}
// AST REWRITE
// elements: HamBehind, contactbody, levelcomplexbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1791:7: -> ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? )
{
// Ham4Parser.g:1791:10: ^( LOCTNBODY levelcomplexbody ( HamBehind )? ( contactbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNBODY, "LOCTNBODY"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexbody.nextTree());
// Ham4Parser.g:1791:39: ( HamBehind )?
if ( stream_HamBehind.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamBehind.nextNode());
}
stream_HamBehind.reset();
// Ham4Parser.g:1791:50: ( contactbody )?
if ( stream_contactbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactbody.nextTree());
}
stream_contactbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationhand_return: (function() {
Ham4Parser.locationhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1794:1: locationhand : levelcomplexhand ( ( contacthand )=> contacthand )? -> ^( LOCTNHAND levelcomplexhand ( contacthand )? ) ;
// $ANTLR start "locationhand"
locationhand: function() {
var retval = new Ham4Parser.locationhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexhand180 = null;
var contacthand181 = null;
var stream_levelcomplexhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexhand");
var stream_contacthand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contacthand");
this.trace("ANTLR Parse: locationhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:1811:5: ( levelcomplexhand ( ( contacthand )=> contacthand )? -> ^( LOCTNHAND levelcomplexhand ( contacthand )? ) )
// Ham4Parser.g:1811:9: levelcomplexhand ( ( contacthand )=> contacthand )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexhand_in_locationhand6705);
levelcomplexhand180=this.levelcomplexhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexhand.add(levelcomplexhand180.getTree());
// Ham4Parser.g:1812:9: ( ( contacthand )=> contacthand )?
var alt59=2;
alt59 = this.dfa59.predict(this.input);
switch (alt59) {
case 1 :
// Ham4Parser.g:1812:11: ( contacthand )=> contacthand
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_locationhand6723);
contacthand181=this.contacthand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contacthand.add(contacthand181.getTree());
break;
}
// AST REWRITE
// elements: levelcomplexhand, contacthand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1814:7: -> ^( LOCTNHAND levelcomplexhand ( contacthand )? )
{
// Ham4Parser.g:1814:10: ^( LOCTNHAND levelcomplexhand ( contacthand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNHAND, "LOCTNHAND"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexhand.nextTree());
// Ham4Parser.g:1814:39: ( contacthand )?
if ( stream_contacthand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contacthand.nextTree());
}
stream_contacthand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locationarm_return: (function() {
Ham4Parser.locationarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locationarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1817:1: locationarm : levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? ) ;
// $ANTLR start "locationarm"
locationarm: function() {
var retval = new Ham4Parser.locationarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBehind183 = null;
var levelcomplexarm182 = null;
var contactbody184 = null;
var HamBehind183_tree=null;
var stream_HamBehind=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBehind");
var stream_contactbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactbody");
var stream_levelcomplexarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexarm");
this.trace("ANTLR Parse: locationarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1835:5: ( levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )? -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? ) )
// Ham4Parser.g:1835:9: levelcomplexarm ( HamBehind )? ( ( contactbody )=> contactbody )?
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexarm_in_locationarm6781);
levelcomplexarm182=this.levelcomplexarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexarm.add(levelcomplexarm182.getTree());
// Ham4Parser.g:1836:9: ( HamBehind )?
var alt60=2;
alt60 = this.dfa60.predict(this.input);
switch (alt60) {
case 1 :
// Ham4Parser.g:1836:11: HamBehind
HamBehind183=this.match(this.input,HamBehind,Ham4Parser.FOLLOW_HamBehind_in_locationarm6793); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBehind.add(HamBehind183);
break;
}
// Ham4Parser.g:1837:9: ( ( contactbody )=> contactbody )?
var alt61=2;
alt61 = this.dfa61.predict(this.input);
switch (alt61) {
case 1 :
// Ham4Parser.g:1837:11: ( contactbody )=> contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_locationarm6816);
contactbody184=this.contactbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactbody.add(contactbody184.getTree());
break;
}
// AST REWRITE
// elements: levelcomplexarm, contactbody, HamBehind
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1839:7: -> ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? )
{
// Ham4Parser.g:1839:10: ^( LOCTNARM levelcomplexarm ( HamBehind )? ( contactbody )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCTNARM, "LOCTNARM"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexarm.nextTree());
// Ham4Parser.g:1839:37: ( HamBehind )?
if ( stream_HamBehind.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamBehind.nextNode());
}
stream_HamBehind.reset();
// Ham4Parser.g:1839:48: ( contactbody )?
if ( stream_contactbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactbody.nextTree());
}
stream_contactbody.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locationarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexbody_return: (function() {
Ham4Parser.levelcomplexbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1842:1: levelcomplexbody : levelbody ( HamBetween levelbody )? ;
// $ANTLR start "levelcomplexbody"
levelcomplexbody: function() {
var retval = new Ham4Parser.levelcomplexbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween186 = null;
var levelbody185 = null;
var levelbody187 = null;
var HamBetween186_tree=null;
this.trace("ANTLR Parse: levelcomplexbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1860:5: ( levelbody ( HamBetween levelbody )? )
// Ham4Parser.g:1860:9: levelbody ( HamBetween levelbody )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_levelcomplexbody6877);
levelbody185=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelbody185.getTree());
// Ham4Parser.g:1861:9: ( HamBetween levelbody )?
var alt62=2;
var LA62_0 = this.input.LA(1);
if ( (LA62_0==HamBetween) ) {
alt62=1;
}
switch (alt62) {
case 1 :
// Ham4Parser.g:1862:13: HamBetween levelbody
HamBetween186=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexbody6901); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_levelcomplexbody6917);
levelbody187=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelbody187.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexhand_return: (function() {
Ham4Parser.levelcomplexhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1867:1: levelcomplexhand : levelhand ( HamBetween levelhand )? ;
// $ANTLR start "levelcomplexhand"
levelcomplexhand: function() {
var retval = new Ham4Parser.levelcomplexhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween189 = null;
var levelhand188 = null;
var levelhand190 = null;
var HamBetween189_tree=null;
this.trace("ANTLR Parse: levelcomplexhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:1885:5: ( levelhand ( HamBetween levelhand )? )
// Ham4Parser.g:1885:9: levelhand ( HamBetween levelhand )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_levelcomplexhand6957);
levelhand188=this.levelhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelhand188.getTree());
// Ham4Parser.g:1886:9: ( HamBetween levelhand )?
var alt63=2;
var LA63_0 = this.input.LA(1);
if ( (LA63_0==HamBetween) ) {
alt63=1;
}
switch (alt63) {
case 1 :
// Ham4Parser.g:1887:13: HamBetween levelhand
HamBetween189=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexhand6981); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_levelcomplexhand6997);
levelhand190=this.levelhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelhand190.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelcomplexarm_return: (function() {
Ham4Parser.levelcomplexarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelcomplexarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1892:1: levelcomplexarm : levelarm ( HamBetween levelarm )? ;
// $ANTLR start "levelcomplexarm"
levelcomplexarm: function() {
var retval = new Ham4Parser.levelcomplexarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween192 = null;
var levelarm191 = null;
var levelarm193 = null;
var HamBetween192_tree=null;
this.trace("ANTLR Parse: levelcomplexarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:1910:5: ( levelarm ( HamBetween levelarm )? )
// Ham4Parser.g:1910:9: levelarm ( HamBetween levelarm )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_levelcomplexarm7037);
levelarm191=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelarm191.getTree());
// Ham4Parser.g:1911:9: ( HamBetween levelarm )?
var alt64=2;
var LA64_0 = this.input.LA(1);
if ( (LA64_0==HamBetween) ) {
alt64=1;
}
switch (alt64) {
case 1 :
// Ham4Parser.g:1912:13: HamBetween levelarm
HamBetween192=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_levelcomplexarm7061); if (this.state.failed) return retval;
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_levelcomplexarm7077);
levelarm193=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, levelarm193.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelcomplexarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelbody_return: (function() {
Ham4Parser.levelbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1917:1: levelbody : ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) ) ;
// $ANTLR start "levelbody"
levelbody: function() {
var retval = new Ham4Parser.levelbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamEtc195 = null;
var HamEtc198 = null;
var HamEtc202 = null;
var HamEtc204 = null;
var locbody194 = null;
var side196 = null;
var locsided197 = null;
var side199 = null;
var side200 = null;
var locbody201 = null;
var locsided203 = null;
var HamEtc195_tree=null;
var HamEtc198_tree=null;
var HamEtc202_tree=null;
var HamEtc204_tree=null;
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_locsided=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locsided");
var stream_locbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locbody");
this.trace("ANTLR Parse: levelbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:1952:5: ( ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) ) )
// Ham4Parser.g:1953:5: ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) )
// Ham4Parser.g:1953:5: ( locbody ( HamEtc )? ( side )? -> ^( LEVBODY locbody ( HamEtc )? ( side )? ) | locsided ( HamEtc )? ( side )? -> ^( LEVBODY locsided ( HamEtc )? ( side )? ) | side ( locbody ( HamEtc )? | locsided ( HamEtc )? ) -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? ) )
var alt72=3;
switch ( this.input.LA(1) ) {
case HamNostrils:
case HamShouldertop:
case HamTongue:
case HamTeeth:
case HamStomach:
case HamHead:
case HamHeadtop:
case HamForehead:
case HamEyebrows:
case HamEyes:
case HamNose:
case HamLips:
case HamChin:
case HamUnderchin:
case HamNeck:
case HamShoulders:
case HamChest:
case HamBelowstomach:
alt72=1;
break;
case HamEarlobe:
case HamEar:
case HamCheek:
alt72=2;
break;
case HamLrbeside:
case HamLrat:
alt72=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 72, 0, this.input);
throw nvae;
}
switch (alt72) {
case 1 :
// Ham4Parser.g:1954:9: locbody ( HamEtc )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locbody_in_levelbody7129);
locbody194=this.locbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbody.add(locbody194.getTree());
// Ham4Parser.g:1955:9: ( HamEtc )?
var alt65=2;
var LA65_0 = this.input.LA(1);
if ( (LA65_0==HamEtc) ) {
alt65=1;
}
switch (alt65) {
case 1 :
// Ham4Parser.g:1955:11: HamEtc
HamEtc195=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7141); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc195);
break;
}
// Ham4Parser.g:1956:9: ( side )?
var alt66=2;
var LA66_0 = this.input.LA(1);
if ( ((LA66_0>=HamLrbeside && LA66_0<=HamLrat)) ) {
alt66=1;
}
switch (alt66) {
case 1 :
// Ham4Parser.g:1956:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7156);
side196=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side196.getTree());
break;
}
// AST REWRITE
// elements: side, HamEtc, locbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1957:6: -> ^( LEVBODY locbody ( HamEtc )? ( side )? )
{
// Ham4Parser.g:1957:9: ^( LEVBODY locbody ( HamEtc )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_locbody.nextTree());
// Ham4Parser.g:1957:27: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:1957:35: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:1959:9: locsided ( HamEtc )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locsided_in_levelbody7194);
locsided197=this.locsided();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locsided.add(locsided197.getTree());
// Ham4Parser.g:1960:9: ( HamEtc )?
var alt67=2;
var LA67_0 = this.input.LA(1);
if ( (LA67_0==HamEtc) ) {
alt67=1;
}
switch (alt67) {
case 1 :
// Ham4Parser.g:1960:11: HamEtc
HamEtc198=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7206); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc198);
break;
}
// Ham4Parser.g:1961:9: ( side )?
var alt68=2;
var LA68_0 = this.input.LA(1);
if ( ((LA68_0>=HamLrbeside && LA68_0<=HamLrat)) ) {
alt68=1;
}
switch (alt68) {
case 1 :
// Ham4Parser.g:1961:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7221);
side199=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side199.getTree());
break;
}
// AST REWRITE
// elements: locsided, HamEtc, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1962:6: -> ^( LEVBODY locsided ( HamEtc )? ( side )? )
{
// Ham4Parser.g:1962:9: ^( LEVBODY locsided ( HamEtc )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_locsided.nextTree());
// Ham4Parser.g:1962:28: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:1962:36: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:1964:9: side ( locbody ( HamEtc )? | locsided ( HamEtc )? )
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelbody7259);
side200=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side200.getTree());
// Ham4Parser.g:1965:9: ( locbody ( HamEtc )? | locsided ( HamEtc )? )
var alt71=2;
var LA71_0 = this.input.LA(1);
if ( ((LA71_0>=HamNostrils && LA71_0<=HamShouldertop)||(LA71_0>=HamTongue && LA71_0<=HamStomach)||(LA71_0>=HamHead && LA71_0<=HamNose)||(LA71_0>=HamLips && LA71_0<=HamBelowstomach)) ) {
alt71=1;
}
else if ( (LA71_0==HamEarlobe||(LA71_0>=HamEar && LA71_0<=HamCheek)) ) {
alt71=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 71, 0, this.input);
throw nvae;
}
switch (alt71) {
case 1 :
// Ham4Parser.g:1966:13: locbody ( HamEtc )?
this.pushFollow(Ham4Parser.FOLLOW_locbody_in_levelbody7283);
locbody201=this.locbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbody.add(locbody201.getTree());
// Ham4Parser.g:1967:13: ( HamEtc )?
var alt69=2;
var LA69_0 = this.input.LA(1);
if ( (LA69_0==HamEtc) ) {
alt69=1;
}
switch (alt69) {
case 1 :
// Ham4Parser.g:1967:15: HamEtc
HamEtc202=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7299); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc202);
break;
}
break;
case 2 :
// Ham4Parser.g:1969:13: locsided ( HamEtc )?
this.pushFollow(Ham4Parser.FOLLOW_locsided_in_levelbody7326);
locsided203=this.locsided();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locsided.add(locsided203.getTree());
// Ham4Parser.g:1970:13: ( HamEtc )?
var alt70=2;
var LA70_0 = this.input.LA(1);
if ( (LA70_0==HamEtc) ) {
alt70=1;
}
switch (alt70) {
case 1 :
// Ham4Parser.g:1970:15: HamEtc
HamEtc204=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelbody7342); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc204);
break;
}
break;
}
// AST REWRITE
// elements: side, HamEtc, locsided, locbody
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 1972:6: -> ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? )
{
// Ham4Parser.g:1972:9: ^( LEVBODY side ( locbody )? ( locsided )? ( HamEtc )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVBODY, "LEVBODY"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
// Ham4Parser.g:1972:24: ( locbody )?
if ( stream_locbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_locbody.nextTree());
}
stream_locbody.reset();
// Ham4Parser.g:1972:33: ( locsided )?
if ( stream_locsided.hasNext() ) {
this.adaptor.addChild(root_1, stream_locsided.nextTree());
}
stream_locsided.reset();
// Ham4Parser.g:1972:43: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelhand_return: (function() {
Ham4Parser.levelhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:1976:1: levelhand : ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) ) ;
// $ANTLR start "levelhand"
levelhand: function() {
var retval = new Ham4Parser.levelhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var lochand205 = null;
var dorsalorpalmar206 = null;
var side207 = null;
var side208 = null;
var lochand209 = null;
var dorsalorpalmar210 = null;
var stream_lochand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule lochand");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_dorsalorpalmar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dorsalorpalmar");
this.trace("ANTLR Parse: levelhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2001:5: ( ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) ) )
// Ham4Parser.g:2002:5: ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) )
// Ham4Parser.g:2002:5: ( lochand ( dorsalorpalmar )? ( side )? -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? ) | side lochand ( dorsalorpalmar )? -> ^( LEVHAND side lochand ( dorsalorpalmar )? ) )
var alt76=2;
var LA76_0 = this.input.LA(1);
if ( ((LA76_0>=HamWristback && LA76_0<=HamPinkyside)||(LA76_0>=HamFingertip && LA76_0<=HamFingerside)) ) {
alt76=1;
}
else if ( ((LA76_0>=HamLrbeside && LA76_0<=HamLrat)) ) {
alt76=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 76, 0, this.input);
throw nvae;
}
switch (alt76) {
case 1 :
// Ham4Parser.g:2003:9: lochand ( dorsalorpalmar )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_lochand_in_levelhand7424);
lochand205=this.lochand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_lochand.add(lochand205.getTree());
// Ham4Parser.g:2004:9: ( dorsalorpalmar )?
var alt73=2;
var LA73_0 = this.input.LA(1);
if ( ((LA73_0>=HamPalm && LA73_0<=HamHandback)) ) {
alt73=1;
}
switch (alt73) {
case 1 :
// Ham4Parser.g:2004:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelhand7436);
dorsalorpalmar206=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar206.getTree());
break;
}
// Ham4Parser.g:2005:9: ( side )?
var alt74=2;
var LA74_0 = this.input.LA(1);
if ( ((LA74_0>=HamLrbeside && LA74_0<=HamLrat)) ) {
alt74=1;
}
switch (alt74) {
case 1 :
// Ham4Parser.g:2005:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelhand7451);
side207=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side207.getTree());
break;
}
// AST REWRITE
// elements: side, lochand, dorsalorpalmar
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2006:5: -> ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? )
{
// Ham4Parser.g:2006:8: ^( LEVHAND lochand ( dorsalorpalmar )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVHAND, "LEVHAND"), root_1);
this.adaptor.addChild(root_1, stream_lochand.nextTree());
// Ham4Parser.g:2006:26: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
// Ham4Parser.g:2006:42: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2008:9: side lochand ( dorsalorpalmar )?
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelhand7488);
side208=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side208.getTree());
this.pushFollow(Ham4Parser.FOLLOW_lochand_in_levelhand7498);
lochand209=this.lochand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_lochand.add(lochand209.getTree());
// Ham4Parser.g:2010:9: ( dorsalorpalmar )?
var alt75=2;
var LA75_0 = this.input.LA(1);
if ( ((LA75_0>=HamPalm && LA75_0<=HamHandback)) ) {
alt75=1;
}
switch (alt75) {
case 1 :
// Ham4Parser.g:2010:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelhand7510);
dorsalorpalmar210=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar210.getTree());
break;
}
// AST REWRITE
// elements: dorsalorpalmar, lochand, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2011:5: -> ^( LEVHAND side lochand ( dorsalorpalmar )? )
{
// Ham4Parser.g:2011:8: ^( LEVHAND side lochand ( dorsalorpalmar )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVHAND, "LEVHAND"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
this.adaptor.addChild(root_1, stream_lochand.nextTree());
// Ham4Parser.g:2011:31: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
levelarm_return: (function() {
Ham4Parser.levelarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.levelarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2015:1: levelarm : ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) ) ;
// $ANTLR start "levelarm"
levelarm: function() {
var retval = new Ham4Parser.levelarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamEtc212 = null;
var HamEtc217 = null;
var locarm211 = null;
var dorsalorpalmar213 = null;
var side214 = null;
var side215 = null;
var locarm216 = null;
var dorsalorpalmar218 = null;
var HamEtc212_tree=null;
var HamEtc217_tree=null;
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_side=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule side");
var stream_dorsalorpalmar=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule dorsalorpalmar");
var stream_locarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locarm");
this.trace("ANTLR Parse: levelarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:2042:5: ( ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) ) )
// Ham4Parser.g:2043:5: ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) )
// Ham4Parser.g:2043:5: ( locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? ) | side locarm ( HamEtc )? ( dorsalorpalmar )? -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? ) )
var alt82=2;
var LA82_0 = this.input.LA(1);
if ( ((LA82_0>=HamUpperarm && LA82_0<=HamLowerarm)) ) {
alt82=1;
}
else if ( ((LA82_0>=HamLrbeside && LA82_0<=HamLrat)) ) {
alt82=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 82, 0, this.input);
throw nvae;
}
switch (alt82) {
case 1 :
// Ham4Parser.g:2044:9: locarm ( HamEtc )? ( dorsalorpalmar )? ( side )?
this.pushFollow(Ham4Parser.FOLLOW_locarm_in_levelarm7577);
locarm211=this.locarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locarm.add(locarm211.getTree());
// Ham4Parser.g:2045:9: ( HamEtc )?
var alt77=2;
var LA77_0 = this.input.LA(1);
if ( (LA77_0==HamEtc) ) {
alt77=1;
}
switch (alt77) {
case 1 :
// Ham4Parser.g:2045:11: HamEtc
HamEtc212=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelarm7589); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc212);
break;
}
// Ham4Parser.g:2046:9: ( dorsalorpalmar )?
var alt78=2;
var LA78_0 = this.input.LA(1);
if ( ((LA78_0>=HamPalm && LA78_0<=HamHandback)) ) {
alt78=1;
}
switch (alt78) {
case 1 :
// Ham4Parser.g:2046:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelarm7604);
dorsalorpalmar213=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar213.getTree());
break;
}
// Ham4Parser.g:2047:9: ( side )?
var alt79=2;
var LA79_0 = this.input.LA(1);
if ( ((LA79_0>=HamLrbeside && LA79_0<=HamLrat)) ) {
alt79=1;
}
switch (alt79) {
case 1 :
// Ham4Parser.g:2047:11: side
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelarm7619);
side214=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side214.getTree());
break;
}
// AST REWRITE
// elements: dorsalorpalmar, side, HamEtc, locarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2048:6: -> ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? )
{
// Ham4Parser.g:2048:9: ^( LEVARM locarm ( HamEtc )? ( dorsalorpalmar )? ( side )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVARM, "LEVARM"), root_1);
this.adaptor.addChild(root_1, stream_locarm.nextTree());
// Ham4Parser.g:2048:25: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2048:33: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
// Ham4Parser.g:2048:49: ( side )?
if ( stream_side.hasNext() ) {
this.adaptor.addChild(root_1, stream_side.nextTree());
}
stream_side.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2050:9: side locarm ( HamEtc )? ( dorsalorpalmar )?
this.pushFollow(Ham4Parser.FOLLOW_side_in_levelarm7660);
side215=this.side();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_side.add(side215.getTree());
this.pushFollow(Ham4Parser.FOLLOW_locarm_in_levelarm7670);
locarm216=this.locarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locarm.add(locarm216.getTree());
// Ham4Parser.g:2052:9: ( HamEtc )?
var alt80=2;
var LA80_0 = this.input.LA(1);
if ( (LA80_0==HamEtc) ) {
alt80=1;
}
switch (alt80) {
case 1 :
// Ham4Parser.g:2052:11: HamEtc
HamEtc217=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_levelarm7682); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc217);
break;
}
// Ham4Parser.g:2053:9: ( dorsalorpalmar )?
var alt81=2;
var LA81_0 = this.input.LA(1);
if ( ((LA81_0>=HamPalm && LA81_0<=HamHandback)) ) {
alt81=1;
}
switch (alt81) {
case 1 :
// Ham4Parser.g:2053:11: dorsalorpalmar
this.pushFollow(Ham4Parser.FOLLOW_dorsalorpalmar_in_levelarm7697);
dorsalorpalmar218=this.dorsalorpalmar();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_dorsalorpalmar.add(dorsalorpalmar218.getTree());
break;
}
// AST REWRITE
// elements: dorsalorpalmar, locarm, HamEtc, side
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2054:6: -> ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? )
{
// Ham4Parser.g:2054:9: ^( LEVARM side locarm ( HamEtc )? ( dorsalorpalmar )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LEVARM, "LEVARM"), root_1);
this.adaptor.addChild(root_1, stream_side.nextTree());
this.adaptor.addChild(root_1, stream_locarm.nextTree());
// Ham4Parser.g:2054:30: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:2054:38: ( dorsalorpalmar )?
if ( stream_dorsalorpalmar.hasNext() ) {
this.adaptor.addChild(root_1, stream_dorsalorpalmar.nextTree());
}
stream_dorsalorpalmar.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: levelarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactbody_return: (function() {
Ham4Parser.contactbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2058:1: contactbody : ( pcontact | HamArmextended | contactofhand ) -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? ) ;
// $ANTLR start "contactbody"
contactbody: function() {
var retval = new Ham4Parser.contactbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamArmextended220 = null;
var pcontact219 = null;
var contactofhand221 = null;
var HamArmextended220_tree=null;
var stream_HamArmextended=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamArmextended");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactofhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactofhand");
this.trace("ANTLR Parse: contactbody starts "+this.state.backtracking);
try {
// Ham4Parser.g:2080:5: ( ( pcontact | HamArmextended | contactofhand ) -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? ) )
// Ham4Parser.g:2081:5: ( pcontact | HamArmextended | contactofhand )
// Ham4Parser.g:2081:5: ( pcontact | HamArmextended | contactofhand )
var alt83=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt83=1;
break;
case HamArmextended:
alt83=2;
break;
case HamSeqbegin:
alt83=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 83, 0, this.input);
throw nvae;
}
switch (alt83) {
case 1 :
// Ham4Parser.g:2082:9: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contactbody7768);
pcontact219=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact219.getTree());
break;
case 2 :
// Ham4Parser.g:2084:9: HamArmextended
HamArmextended220=this.match(this.input,HamArmextended,Ham4Parser.FOLLOW_HamArmextended_in_contactbody7784); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamArmextended.add(HamArmextended220);
break;
case 3 :
// Ham4Parser.g:2086:9: contactofhand
this.pushFollow(Ham4Parser.FOLLOW_contactofhand_in_contactbody7800);
contactofhand221=this.contactofhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactofhand.add(contactofhand221.getTree());
break;
}
// AST REWRITE
// elements: pcontact, HamArmextended, contactofhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2088:5: -> ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? )
{
// Ham4Parser.g:2088:8: ^( CNTCTBODY ( pcontact )? ( HamArmextended )? ( contactofhand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTBODY, "CNTCTBODY"), root_1);
// Ham4Parser.g:2088:20: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2088:30: ( HamArmextended )?
if ( stream_HamArmextended.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamArmextended.nextNode());
}
stream_HamArmextended.reset();
// Ham4Parser.g:2088:46: ( contactofhand )?
if ( stream_contactofhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactofhand.nextTree());
}
stream_contactofhand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactbody finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contacthand_return: (function() {
Ham4Parser.contacthand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contacthand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2091:1: contacthand : ( pcontact | ccontact | contactofhand ) -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? ) ;
// $ANTLR start "contacthand"
contacthand: function() {
var retval = new Ham4Parser.contacthand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var pcontact222 = null;
var ccontact223 = null;
var contactofhand224 = null;
var stream_ccontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ccontact");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactofhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactofhand");
this.trace("ANTLR Parse: contacthand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2113:5: ( ( pcontact | ccontact | contactofhand ) -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? ) )
// Ham4Parser.g:2114:5: ( pcontact | ccontact | contactofhand )
// Ham4Parser.g:2114:5: ( pcontact | ccontact | contactofhand )
var alt84=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt84=1;
break;
case HamInterlock:
case HamCross:
alt84=2;
break;
case HamSeqbegin:
alt84=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 84, 0, this.input);
throw nvae;
}
switch (alt84) {
case 1 :
// Ham4Parser.g:2115:9: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contacthand7866);
pcontact222=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact222.getTree());
break;
case 2 :
// Ham4Parser.g:2117:9: ccontact
this.pushFollow(Ham4Parser.FOLLOW_ccontact_in_contacthand7882);
ccontact223=this.ccontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ccontact.add(ccontact223.getTree());
break;
case 3 :
// Ham4Parser.g:2119:9: contactofhand
this.pushFollow(Ham4Parser.FOLLOW_contactofhand_in_contacthand7898);
contactofhand224=this.contactofhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactofhand.add(contactofhand224.getTree());
break;
}
// AST REWRITE
// elements: pcontact, contactofhand, ccontact
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2121:5: -> ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? )
{
// Ham4Parser.g:2121:8: ^( CNTCTHAND ( pcontact )? ( ccontact )? ( contactofhand )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTHAND, "CNTCTHAND"), root_1);
// Ham4Parser.g:2121:20: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2121:30: ( ccontact )?
if ( stream_ccontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_ccontact.nextTree());
}
stream_ccontact.reset();
// Ham4Parser.g:2121:40: ( contactofhand )?
if ( stream_contactofhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactofhand.nextTree());
}
stream_contactofhand.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contacthand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handconstellation_return: (function() {
Ham4Parser.handconstellation_return = function(){};
org.antlr.lang.extend(Ham4Parser.handconstellation_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2124:1: handconstellation : ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand -> ^( HCONSTLLN ( locationhand )* contacthand ) ;
// $ANTLR start "handconstellation"
handconstellation: function() {
var retval = new Ham4Parser.handconstellation_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin225 = null;
var HamPlus227 = null;
var HamParend229 = null;
var locationhand226 = null;
var locationhand228 = null;
var contacthand230 = null;
var HamParbegin225_tree=null;
var HamPlus227_tree=null;
var HamParend229_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_contacthand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contacthand");
var stream_locationhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationhand");
this.trace("ANTLR Parse: handconstellation starts "+this.state.backtracking);
try {
// Ham4Parser.g:2147:5: ( ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand -> ^( HCONSTLLN ( locationhand )* contacthand ) )
// Ham4Parser.g:2147:9: ( HamParbegin locationhand HamPlus locationhand HamParend )? contacthand
// Ham4Parser.g:2147:9: ( HamParbegin locationhand HamPlus locationhand HamParend )?
var alt85=2;
var LA85_0 = this.input.LA(1);
if ( (LA85_0==HamParbegin) ) {
alt85=1;
}
switch (alt85) {
case 1 :
// Ham4Parser.g:2148:13: HamParbegin locationhand HamPlus locationhand HamParend
HamParbegin225=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_handconstellation7966); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin225);
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_handconstellation7981);
locationhand226=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand226.getTree());
HamPlus227=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_handconstellation7995); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus227);
this.pushFollow(Ham4Parser.FOLLOW_locationhand_in_handconstellation8010);
locationhand228=this.locationhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationhand.add(locationhand228.getTree());
HamParend229=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_handconstellation8024); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend229);
break;
}
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_handconstellation8046);
contacthand230=this.contacthand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contacthand.add(contacthand230.getTree());
// AST REWRITE
// elements: locationhand, contacthand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2156:6: -> ^( HCONSTLLN ( locationhand )* contacthand )
{
// Ham4Parser.g:2156:9: ^( HCONSTLLN ( locationhand )* contacthand )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HCONSTLLN, "HCONSTLLN"), root_1);
// Ham4Parser.g:2156:21: ( locationhand )*
while ( stream_locationhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationhand.nextTree());
}
stream_locationhand.reset();
this.adaptor.addChild(root_1, stream_contacthand.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handconstellation finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactofhand_return: (function() {
Ham4Parser.contactofhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactofhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2159:1: contactofhand : HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? ) ;
// $ANTLR start "contactofhand"
contactofhand: function() {
var retval = new Ham4Parser.contactofhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin231 = null;
var HamSeqend236 = null;
var pcontact232 = null;
var ccontact233 = null;
var contactohhand234 = null;
var contactoharm235 = null;
var HamSeqbegin231_tree=null;
var HamSeqend236_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_contactoharm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactoharm");
var stream_ccontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ccontact");
var stream_pcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule pcontact");
var stream_contactohhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule contactohhand");
this.trace("ANTLR Parse: contactofhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2188:5: ( HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? ) )
// Ham4Parser.g:2188:9: HamSeqbegin ( pcontact | ccontact ) ( ( levelhand )=> contactohhand | contactoharm ) HamSeqend
HamSeqbegin231=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_contactofhand8100); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin231);
// Ham4Parser.g:2189:9: ( pcontact | ccontact )
var alt86=2;
var LA86_0 = this.input.LA(1);
if ( ((LA86_0>=HamClose && LA86_0<=HamTouch)) ) {
alt86=1;
}
else if ( ((LA86_0>=HamInterlock && LA86_0<=HamCross)) ) {
alt86=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 86, 0, this.input);
throw nvae;
}
switch (alt86) {
case 1 :
// Ham4Parser.g:2190:13: pcontact
this.pushFollow(Ham4Parser.FOLLOW_pcontact_in_contactofhand8125);
pcontact232=this.pcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_pcontact.add(pcontact232.getTree());
break;
case 2 :
// Ham4Parser.g:2192:13: ccontact
this.pushFollow(Ham4Parser.FOLLOW_ccontact_in_contactofhand8149);
ccontact233=this.ccontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ccontact.add(ccontact233.getTree());
break;
}
// Ham4Parser.g:2194:9: ( ( levelhand )=> contactohhand | contactoharm )
var alt87=2;
var LA87_0 = this.input.LA(1);
if ( ((LA87_0>=HamWristback && LA87_0<=HamHandback)||(LA87_0>=HamThumbside && LA87_0<=HamPinkyside)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamFingertip && LA87_0<=HamFingerside)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( (LA87_0==HamThumb) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamIndexfinger && LA87_0<=HamPinky)) && (this.synpred26_Ham4Parser())) {
alt87=1;
}
else if ( ((LA87_0>=HamLrbeside && LA87_0<=HamLrat)) ) {
var LA87_5 = this.input.LA(2);
if ( (this.synpred26_Ham4Parser()) ) {
alt87=1;
}
else if ( (true) ) {
alt87=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 87, 5, this.input);
throw nvae;
}
}
else if ( ((LA87_0>=HamUpperarm && LA87_0<=HamLowerarm)) ) {
alt87=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 87, 0, this.input);
throw nvae;
}
switch (alt87) {
case 1 :
// Ham4Parser.g:2195:13: ( levelhand )=> contactohhand
this.pushFollow(Ham4Parser.FOLLOW_contactohhand_in_contactofhand8215);
contactohhand234=this.contactohhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactohhand.add(contactohhand234.getTree());
break;
case 2 :
// Ham4Parser.g:2199:13: contactoharm
this.pushFollow(Ham4Parser.FOLLOW_contactoharm_in_contactofhand8239);
contactoharm235=this.contactoharm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_contactoharm.add(contactoharm235.getTree());
break;
}
HamSeqend236=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_contactofhand8259); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend236);
// AST REWRITE
// elements: pcontact, ccontact, contactoharm, contactohhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2203:6: -> ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? )
{
// Ham4Parser.g:2203:9: ^( CNTCTOFHAND ( pcontact )? ( ccontact )? ( contactohhand )? ( contactoharm )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOFHAND, "CNTCTOFHAND"), root_1);
// Ham4Parser.g:2203:23: ( pcontact )?
if ( stream_pcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_pcontact.nextTree());
}
stream_pcontact.reset();
// Ham4Parser.g:2203:33: ( ccontact )?
if ( stream_ccontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_ccontact.nextTree());
}
stream_ccontact.reset();
// Ham4Parser.g:2203:43: ( contactohhand )?
if ( stream_contactohhand.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactohhand.nextTree());
}
stream_contactohhand.reset();
// Ham4Parser.g:2203:58: ( contactoharm )?
if ( stream_contactoharm.hasNext() ) {
this.adaptor.addChild(root_1, stream_contactoharm.nextTree());
}
stream_contactoharm.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactofhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactohhand_return: (function() {
Ham4Parser.contactohhand_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactohhand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2206:1: contactohhand : levelcomplexhand -> ^( CNTCTOHHAND levelcomplexhand ) ;
// $ANTLR start "contactohhand"
contactohhand: function() {
var retval = new Ham4Parser.contactohhand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexhand237 = null;
var stream_levelcomplexhand=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexhand");
this.trace("ANTLR Parse: contactohhand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2222:5: ( levelcomplexhand -> ^( CNTCTOHHAND levelcomplexhand ) )
// Ham4Parser.g:2222:9: levelcomplexhand
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexhand_in_contactohhand8321);
levelcomplexhand237=this.levelcomplexhand();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexhand.add(levelcomplexhand237.getTree());
// AST REWRITE
// elements: levelcomplexhand
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2224:6: -> ^( CNTCTOHHAND levelcomplexhand )
{
// Ham4Parser.g:2224:9: ^( CNTCTOHHAND levelcomplexhand )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOHHAND, "CNTCTOHHAND"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexhand.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactohhand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
contactoharm_return: (function() {
Ham4Parser.contactoharm_return = function(){};
org.antlr.lang.extend(Ham4Parser.contactoharm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2227:1: contactoharm : levelcomplexarm -> ^( CNTCTOHARM levelcomplexarm ) ;
// $ANTLR start "contactoharm"
contactoharm: function() {
var retval = new Ham4Parser.contactoharm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var levelcomplexarm238 = null;
var stream_levelcomplexarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelcomplexarm");
this.trace("ANTLR Parse: contactoharm starts "+this.state.backtracking);
try {
// Ham4Parser.g:2243:5: ( levelcomplexarm -> ^( CNTCTOHARM levelcomplexarm ) )
// Ham4Parser.g:2243:9: levelcomplexarm
this.pushFollow(Ham4Parser.FOLLOW_levelcomplexarm_in_contactoharm8372);
levelcomplexarm238=this.levelcomplexarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelcomplexarm.add(levelcomplexarm238.getTree());
// AST REWRITE
// elements: levelcomplexarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2245:6: -> ^( CNTCTOHARM levelcomplexarm )
{
// Ham4Parser.g:2245:9: ^( CNTCTOHARM levelcomplexarm )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CNTCTOHARM, "CNTCTOHARM"), root_1);
this.adaptor.addChild(root_1, stream_levelcomplexarm.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: contactoharm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
lochand_return: (function() {
Ham4Parser.lochand_return = function(){};
org.antlr.lang.extend(Ham4Parser.lochand_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2248:1: lochand : ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? ) ;
// $ANTLR start "lochand"
lochand: function() {
var retval = new Ham4Parser.lochand_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handpart239 = null;
var fingerpart240 = null;
var digit241 = null;
var digit242 = null;
var fingerpart243 = null;
this.trace("ANTLR Parse: lochand starts "+this.state.backtracking);
try {
// Ham4Parser.g:2271:5: ( ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? ) )
// Ham4Parser.g:2272:5: ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? )
root_0 = this.adaptor.nil();
// Ham4Parser.g:2272:5: ( handpart | fingerpart ( digit )* | ( digit )+ ( fingerpart )? )
var alt91=3;
switch ( this.input.LA(1) ) {
case HamWristback:
case HamWristpulse:
case HamThumbball:
case HamPalm:
case HamHandback:
case HamThumbside:
case HamPinkyside:
alt91=1;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt91=2;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt91=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 91, 0, this.input);
throw nvae;
}
switch (alt91) {
case 1 :
// Ham4Parser.g:2273:9: handpart
this.pushFollow(Ham4Parser.FOLLOW_handpart_in_lochand8435);
handpart239=this.handpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, handpart239.getTree());
break;
case 2 :
// Ham4Parser.g:2275:9: fingerpart ( digit )*
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_lochand8451);
fingerpart240=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerpart240.getTree());
// Ham4Parser.g:2276:9: ( digit )*
loop88:
do {
var alt88=2;
var LA88_0 = this.input.LA(1);
if ( ((LA88_0>=HamThumb && LA88_0<=HamPinky)) ) {
alt88=1;
}
switch (alt88) {
case 1 :
// Ham4Parser.g:2276:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_lochand8463);
digit241=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit241.getTree());
break;
default :
break loop88;
}
} while (true);
break;
case 3 :
// Ham4Parser.g:2278:9: ( digit )+ ( fingerpart )?
// Ham4Parser.g:2278:9: ( digit )+
var cnt89=0;
loop89:
do {
var alt89=2;
var LA89_0 = this.input.LA(1);
if ( ((LA89_0>=HamThumb && LA89_0<=HamPinky)) ) {
alt89=1;
}
switch (alt89) {
case 1 :
// Ham4Parser.g:2278:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_lochand8484);
digit242=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, digit242.getTree());
break;
default :
if ( cnt89 >= 1 ) {
break loop89;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(89, this.input);
throw eee;
}
cnt89++;
} while (true);
// Ham4Parser.g:2279:9: ( fingerpart )?
var alt90=2;
var LA90_0 = this.input.LA(1);
if ( ((LA90_0>=HamFingertip && LA90_0<=HamFingerside)) ) {
alt90=1;
}
switch (alt90) {
case 1 :
// Ham4Parser.g:2279:11: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_lochand8499);
fingerpart243=this.fingerpart();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, fingerpart243.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: lochand finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a2tstar_return: (function() {
Ham4Parser.a2tstar_return = function(){};
org.antlr.lang.extend(Ham4Parser.a2tstar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2286:1: a2tstar : a2tlist -> ^( A2TLIST ( a2tlist )? ) ;
// $ANTLR start "a2tstar"
a2tstar: function() {
var retval = new Ham4Parser.a2tstar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var a2tlist244 = null;
var stream_a2tlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a2tlist");
this.trace("ANTLR Parse: a2tstar starts "+this.state.backtracking);
try {
// Ham4Parser.g:2302:5: ( a2tlist -> ^( A2TLIST ( a2tlist )? ) )
// Ham4Parser.g:2302:9: a2tlist
this.pushFollow(Ham4Parser.FOLLOW_a2tlist_in_a2tstar8540);
a2tlist244=this.a2tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a2tlist.add(a2tlist244.getTree());
// AST REWRITE
// elements: a2tlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2304:6: -> ^( A2TLIST ( a2tlist )? )
{
// Ham4Parser.g:2304:9: ^( A2TLIST ( a2tlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(A2TLIST, "A2TLIST"), root_1);
// Ham4Parser.g:2304:19: ( a2tlist )?
if ( stream_a2tlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_a2tlist.nextTree());
}
stream_a2tlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a2tstar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a1tstar_return: (function() {
Ham4Parser.a1tstar_return = function(){};
org.antlr.lang.extend(Ham4Parser.a1tstar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2307:1: a1tstar : a1tlist -> ^( A1TLIST ( a1tlist )? ) ;
// $ANTLR start "a1tstar"
a1tstar: function() {
var retval = new Ham4Parser.a1tstar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var a1tlist245 = null;
var stream_a1tlist=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule a1tlist");
this.trace("ANTLR Parse: a1tstar starts "+this.state.backtracking);
try {
// Ham4Parser.g:2323:5: ( a1tlist -> ^( A1TLIST ( a1tlist )? ) )
// Ham4Parser.g:2323:9: a1tlist
this.pushFollow(Ham4Parser.FOLLOW_a1tlist_in_a1tstar8592);
a1tlist245=this.a1tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_a1tlist.add(a1tlist245.getTree());
// AST REWRITE
// elements: a1tlist
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2325:6: -> ^( A1TLIST ( a1tlist )? )
{
// Ham4Parser.g:2325:9: ^( A1TLIST ( a1tlist )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(A1TLIST, "A1TLIST"), root_1);
// Ham4Parser.g:2325:19: ( a1tlist )?
if ( stream_a1tlist.hasNext() ) {
this.adaptor.addChild(root_1, stream_a1tlist.nextTree());
}
stream_a1tlist.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a1tstar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a2tlist_return: (function() {
Ham4Parser.a2tlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.a2tlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2328:1: a2tlist : ( action2t a2tlist )? ;
// $ANTLR start "a2tlist"
a2tlist: function() {
var retval = new Ham4Parser.a2tlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action2t246 = null;
var a2tlist247 = null;
this.trace("ANTLR Parse: a2tlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:2346:5: ( ( action2t a2tlist )? )
// Ham4Parser.g:2347:9: ( action2t a2tlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2347:9: ( action2t a2tlist )?
var alt92=2;
alt92 = this.dfa92.predict(this.input);
switch (alt92) {
case 1 :
// Ham4Parser.g:2348:13: action2t a2tlist
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_a2tlist8664);
action2t246=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action2t246.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a2tlist_in_a2tlist8678);
a2tlist247=this.a2tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, a2tlist247.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a2tlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
a1tlist_return: (function() {
Ham4Parser.a1tlist_return = function(){};
org.antlr.lang.extend(Ham4Parser.a1tlist_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2353:1: a1tlist : ( action1t a1tlist )? ;
// $ANTLR start "a1tlist"
a1tlist: function() {
var retval = new Ham4Parser.a1tlist_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1t248 = null;
var a1tlist249 = null;
this.trace("ANTLR Parse: a1tlist starts "+this.state.backtracking);
try {
// Ham4Parser.g:2371:5: ( ( action1t a1tlist )? )
// Ham4Parser.g:2372:9: ( action1t a1tlist )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2372:9: ( action1t a1tlist )?
var alt93=2;
alt93 = this.dfa93.predict(this.input);
switch (alt93) {
case 1 :
// Ham4Parser.g:2373:13: action1t a1tlist
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_a1tlist8738);
action1t248=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1t248.getTree());
this.pushFollow(Ham4Parser.FOLLOW_a1tlist_in_a1tlist8752);
a1tlist249=this.a1tlist();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, a1tlist249.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: a1tlist finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action2t_return: (function() {
Ham4Parser.action2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.action2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2378:1: action2t : ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) ) ;
// $ANTLR start "action2t"
action2t: function() {
var retval = new Ham4Parser.action2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1250 = null;
var location2not1251 = null;
var repetitionsoption252 = null;
var action1t253 = null;
var splitaction2loc2254 = null;
var splitaction2t255 = null;
var paraction2t256 = null;
var seqaction2t257 = null;
var seqfusedaction2t258 = null;
var repetitionsoption259 = null;
var stream_seqfusedaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction2t");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
var stream_seqaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqaction2t");
var stream_location2not1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2not1");
var stream_repetitionsoption=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetitionsoption");
var stream_splitaction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitaction2t");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
var stream_paraction2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction2t");
var stream_splitaction2loc2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitaction2loc2");
this.trace("ANTLR Parse: action2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2424:5: ( ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) ) )
// Ham4Parser.g:2425:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )
// Ham4Parser.g:2425:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )
var alt95=3;
alt95 = this.dfa95.predict(this.input);
switch (alt95) {
case 1 :
// Ham4Parser.g:2426:9: ( action1 location2not1 )=> action1 location2not1 repetitionsoption
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action2t8830);
action1250=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1250.getTree());
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_action2t8840);
location2not1251=this.location2not1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2not1.add(location2not1251.getTree());
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action2t8850);
repetitionsoption252=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption252.getTree());
// AST REWRITE
// elements: action1, repetitionsoption, location2not1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2431:6: -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? )
{
// Ham4Parser.g:2431:9: ^( ACTION2T action1 location2not1 ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
this.adaptor.addChild(root_1, stream_action1.nextTree());
this.adaptor.addChild(root_1, stream_location2not1.nextTree());
// Ham4Parser.g:2431:42: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2433:9: ( action1t )=> action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_action2t8908);
action1t253=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t253.getTree());
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2436:6: -> ^( ACTION2T action1t )
{
// Ham4Parser.g:2436:9: ^( ACTION2T action1t )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
this.adaptor.addChild(root_1, stream_action1t.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2438:9: ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption
// Ham4Parser.g:2438:9: ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t )
var alt94=5;
switch ( this.input.LA(1) ) {
case HamParbegin:
var LA94_1 = this.input.LA(2);
if ( (this.synpred29_Ham4Parser()) ) {
alt94=1;
}
else if ( (this.synpred30_Ham4Parser()) ) {
alt94=2;
}
else if ( (true) ) {
alt94=3;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 1, this.input);
throw nvae;
}
break;
case HamSeqbegin:
alt94=4;
break;
case HamFusionbegin:
alt94=5;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 0, this.input);
throw nvae;
}
switch (alt94) {
case 1 :
// Ham4Parser.g:2439:13: ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2
this.pushFollow(Ham4Parser.FOLLOW_splitaction2loc2_in_action2t9017);
splitaction2loc2254=this.splitaction2loc2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitaction2loc2.add(splitaction2loc2254.getTree());
break;
case 2 :
// Ham4Parser.g:2444:13: ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t
this.pushFollow(Ham4Parser.FOLLOW_splitaction2t_in_action2t9082);
splitaction2t255=this.splitaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitaction2t.add(splitaction2t255.getTree());
break;
case 3 :
// Ham4Parser.g:2448:13: paraction2t
this.pushFollow(Ham4Parser.FOLLOW_paraction2t_in_action2t9106);
paraction2t256=this.paraction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction2t.add(paraction2t256.getTree());
break;
case 4 :
// Ham4Parser.g:2450:13: seqaction2t
this.pushFollow(Ham4Parser.FOLLOW_seqaction2t_in_action2t9130);
seqaction2t257=this.seqaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqaction2t.add(seqaction2t257.getTree());
break;
case 5 :
// Ham4Parser.g:2452:13: seqfusedaction2t
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction2t_in_action2t9154);
seqfusedaction2t258=this.seqfusedaction2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction2t.add(seqfusedaction2t258.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action2t9174);
repetitionsoption259=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption259.getTree());
// AST REWRITE
// elements: paraction2t, splitaction2loc2, seqaction2t, repetitionsoption, seqfusedaction2t, splitaction2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2455:6: -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? )
{
// Ham4Parser.g:2455:9: ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION2T, "ACTION2T"), root_1);
// Ham4Parser.g:2455:20: ( splitaction2loc2 )?
if ( stream_splitaction2loc2.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitaction2loc2.nextTree());
}
stream_splitaction2loc2.reset();
// Ham4Parser.g:2455:38: ( splitaction2t )?
if ( stream_splitaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitaction2t.nextTree());
}
stream_splitaction2t.reset();
// Ham4Parser.g:2455:53: ( paraction2t )?
if ( stream_paraction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_paraction2t.nextTree());
}
stream_paraction2t.reset();
// Ham4Parser.g:2455:66: ( seqaction2t )?
if ( stream_seqaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqaction2t.nextTree());
}
stream_seqaction2t.reset();
// Ham4Parser.g:2455:79: ( seqfusedaction2t )?
if ( stream_seqfusedaction2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqfusedaction2t.nextTree());
}
stream_seqfusedaction2t.reset();
// Ham4Parser.g:2455:97: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1t_return: (function() {
Ham4Parser.action1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2459:1: action1t : ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? ) ;
// $ANTLR start "action1t"
action1t: function() {
var retval = new Ham4Parser.action1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamLargemod263 = null;
var action1260 = null;
var handconstellation261 = null;
var location1262 = null;
var paraction1t264 = null;
var seqnmoraction1t265 = null;
var seqfusedaction1t266 = null;
var repetitionsoption267 = null;
var HamLargemod263_tree=null;
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_seqfusedaction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction1t");
var stream_repetitionsoption=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetitionsoption");
var stream_location1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location1");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
var stream_seqnmoraction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqnmoraction1t");
var stream_handconstellation=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handconstellation");
var stream_paraction1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction1t");
this.trace("ANTLR Parse: action1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2502:5: ( ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? ) )
// Ham4Parser.g:2503:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t ) repetitionsoption
// Ham4Parser.g:2503:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t )
var alt98=4;
alt98 = this.dfa98.predict(this.input);
switch (alt98) {
case 1 :
// Ham4Parser.g:2504:13: ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? )
// Ham4Parser.g:2506:13: ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? )
// Ham4Parser.g:2507:17: action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action1t9308);
action1260=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1260.getTree());
// Ham4Parser.g:2508:17: ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?
var alt97=3;
alt97 = this.dfa97.predict(this.input);
switch (alt97) {
case 1 :
// Ham4Parser.g:2509:21: ( handconstellation )=> handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_action1t9396);
handconstellation261=this.handconstellation();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handconstellation.add(handconstellation261.getTree());
break;
case 2 :
// Ham4Parser.g:2513:21: location1 ( HamLargemod )?
this.pushFollow(Ham4Parser.FOLLOW_location1_in_action1t9436);
location1262=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location1.add(location1262.getTree());
// Ham4Parser.g:2514:21: ( HamLargemod )?
var alt96=2;
alt96 = this.dfa96.predict(this.input);
switch (alt96) {
case 1 :
// Ham4Parser.g:2514:23: HamLargemod
HamLargemod263=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_action1t9460); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod263);
break;
}
break;
}
break;
case 2 :
// Ham4Parser.g:2518:13: paraction1t
this.pushFollow(Ham4Parser.FOLLOW_paraction1t_in_action1t9520);
paraction1t264=this.paraction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction1t.add(paraction1t264.getTree());
break;
case 3 :
// Ham4Parser.g:2520:13: seqnmoraction1t
this.pushFollow(Ham4Parser.FOLLOW_seqnmoraction1t_in_action1t9544);
seqnmoraction1t265=this.seqnmoraction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqnmoraction1t.add(seqnmoraction1t265.getTree());
break;
case 4 :
// Ham4Parser.g:2522:13: seqfusedaction1t
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction1t_in_action1t9569);
seqfusedaction1t266=this.seqfusedaction1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction1t.add(seqfusedaction1t266.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetitionsoption_in_action1t9589);
repetitionsoption267=this.repetitionsoption();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetitionsoption.add(repetitionsoption267.getTree());
// AST REWRITE
// elements: handconstellation, seqfusedaction1t, repetitionsoption, paraction1t, action1, HamLargemod, location1, seqnmoraction1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2526:6: -> ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? )
{
// Ham4Parser.g:2526:9: ^( ACTION1T ( action1 )? ( handconstellation )? ( location1 )? ( HamLargemod )? ( paraction1t )? ( seqnmoraction1t )? ( seqfusedaction1t )? ( repetitionsoption )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1T, "ACTION1T"), root_1);
// Ham4Parser.g:2527:9: ( action1 )?
if ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
// Ham4Parser.g:2527:18: ( handconstellation )?
if ( stream_handconstellation.hasNext() ) {
this.adaptor.addChild(root_1, stream_handconstellation.nextTree());
}
stream_handconstellation.reset();
// Ham4Parser.g:2527:37: ( location1 )?
if ( stream_location1.hasNext() ) {
this.adaptor.addChild(root_1, stream_location1.nextTree());
}
stream_location1.reset();
// Ham4Parser.g:2527:48: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
// Ham4Parser.g:2528:9: ( paraction1t )?
if ( stream_paraction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_paraction1t.nextTree());
}
stream_paraction1t.reset();
// Ham4Parser.g:2529:21: ( seqnmoraction1t )?
if ( stream_seqnmoraction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqnmoraction1t.nextTree());
}
stream_seqnmoraction1t.reset();
// Ham4Parser.g:2530:9: ( seqfusedaction1t )?
if ( stream_seqfusedaction1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_seqfusedaction1t.nextTree());
}
stream_seqfusedaction1t.reset();
// Ham4Parser.g:2531:8: ( repetitionsoption )?
if ( stream_repetitionsoption.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetitionsoption.nextTree());
}
stream_repetitionsoption.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1_return: (function() {
Ham4Parser.action1_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2534:1: action1 : ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) ) ;
// $ANTLR start "action1"
action1: function() {
var retval = new Ham4Parser.action1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamNomotion268 = null;
var HamLargemod271 = null;
var simplemovement269 = null;
var modifier270 = null;
var specialfingerplaymovement272 = null;
var paraction1273 = null;
var seqaction1274 = null;
var seqfusedaction1275 = null;
var HamNomotion268_tree=null;
var HamLargemod271_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamLargemod=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamLargemod");
var stream_specialfingerplaymovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule specialfingerplaymovement");
var stream_modifier=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule modifier");
var stream_seqaction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqaction1");
var stream_simplemovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule simplemovement");
var stream_paraction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule paraction1");
var stream_seqfusedaction1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule seqfusedaction1");
this.trace("ANTLR Parse: action1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2573:5: ( ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) ) )
// Ham4Parser.g:2574:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )
// Ham4Parser.g:2574:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )
var alt102=6;
alt102 = this.dfa102.predict(this.input);
switch (alt102) {
case 1 :
// Ham4Parser.g:2575:9: HamNomotion
HamNomotion268=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_action19725); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion268);
// AST REWRITE
// elements: HamNomotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2576:6: -> ^( ACTION1 HamNomotion )
{
// Ham4Parser.g:2576:9: ^( ACTION1 HamNomotion )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_HamNomotion.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2578:9: simplemovement ( ( modifier )+ ( HamLargemod )? )?
this.pushFollow(Ham4Parser.FOLLOW_simplemovement_in_action19754);
simplemovement269=this.simplemovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_simplemovement.add(simplemovement269.getTree());
// Ham4Parser.g:2579:9: ( ( modifier )+ ( HamLargemod )? )?
var alt101=2;
var LA101_0 = this.input.LA(1);
if ( ((LA101_0>=HamFast && LA101_0<=HamHalt)) ) {
alt101=1;
}
switch (alt101) {
case 1 :
// Ham4Parser.g:2580:13: ( modifier )+ ( HamLargemod )?
// Ham4Parser.g:2580:13: ( modifier )+
var cnt99=0;
loop99:
do {
var alt99=2;
var LA99_0 = this.input.LA(1);
if ( ((LA99_0>=HamFast && LA99_0<=HamHalt)) ) {
alt99=1;
}
switch (alt99) {
case 1 :
// Ham4Parser.g:2580:15: modifier
this.pushFollow(Ham4Parser.FOLLOW_modifier_in_action19780);
modifier270=this.modifier();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_modifier.add(modifier270.getTree());
break;
default :
if ( cnt99 >= 1 ) {
break loop99;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(99, this.input);
throw eee;
}
cnt99++;
} while (true);
// Ham4Parser.g:2581:13: ( HamLargemod )?
var alt100=2;
var LA100_0 = this.input.LA(1);
if ( (LA100_0==HamLargemod) ) {
alt100=1;
}
switch (alt100) {
case 1 :
// Ham4Parser.g:2581:15: HamLargemod
HamLargemod271=this.match(this.input,HamLargemod,Ham4Parser.FOLLOW_HamLargemod_in_action19799); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamLargemod.add(HamLargemod271);
break;
}
break;
}
// AST REWRITE
// elements: simplemovement, HamLargemod, modifier
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2583:6: -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? )
{
// Ham4Parser.g:2583:9: ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_simplemovement.nextTree());
// Ham4Parser.g:2583:34: ( modifier )*
while ( stream_modifier.hasNext() ) {
this.adaptor.addChild(root_1, stream_modifier.nextTree());
}
stream_modifier.reset();
// Ham4Parser.g:2583:44: ( HamLargemod )?
if ( stream_HamLargemod.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamLargemod.nextNode());
}
stream_HamLargemod.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:2585:9: ( HamSeqbegin digit )=> specialfingerplaymovement
this.pushFollow(Ham4Parser.FOLLOW_specialfingerplaymovement_in_action19874);
specialfingerplaymovement272=this.specialfingerplaymovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_specialfingerplaymovement.add(specialfingerplaymovement272.getTree());
// AST REWRITE
// elements: specialfingerplaymovement
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2588:6: -> ^( ACTION1 specialfingerplaymovement )
{
// Ham4Parser.g:2588:9: ^( ACTION1 specialfingerplaymovement )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_specialfingerplaymovement.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:2590:9: paraction1
this.pushFollow(Ham4Parser.FOLLOW_paraction1_in_action19903);
paraction1273=this.paraction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_paraction1.add(paraction1273.getTree());
// AST REWRITE
// elements: paraction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2591:6: -> ^( ACTION1 paraction1 )
{
// Ham4Parser.g:2591:9: ^( ACTION1 paraction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_paraction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 5 :
// Ham4Parser.g:2593:9: seqaction1
this.pushFollow(Ham4Parser.FOLLOW_seqaction1_in_action19932);
seqaction1274=this.seqaction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqaction1.add(seqaction1274.getTree());
// AST REWRITE
// elements: seqaction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2594:6: -> ^( ACTION1 seqaction1 )
{
// Ham4Parser.g:2594:9: ^( ACTION1 seqaction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_seqaction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 6 :
// Ham4Parser.g:2596:9: seqfusedaction1
this.pushFollow(Ham4Parser.FOLLOW_seqfusedaction1_in_action19961);
seqfusedaction1275=this.seqfusedaction1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_seqfusedaction1.add(seqfusedaction1275.getTree());
// AST REWRITE
// elements: seqfusedaction1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2597:6: -> ^( ACTION1 seqfusedaction1 )
{
// Ham4Parser.g:2597:9: ^( ACTION1 seqfusedaction1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(ACTION1, "ACTION1"), root_1);
this.adaptor.addChild(root_1, stream_seqfusedaction1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: action1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1seq_return: (function() {
Ham4Parser.action1seq_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1seq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2604:1: action1seq : ( action1 )+ ;
// $ANTLR start "action1seq"
action1seq: function() {
var retval = new Ham4Parser.action1seq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1276 = null;
try {
// Ham4Parser.g:2605:2: ( ( action1 )+ )
// Ham4Parser.g:2605:4: ( action1 )+
root_0 = this.adaptor.nil();
// Ham4Parser.g:2605:4: ( action1 )+
var cnt103=0;
loop103:
do {
var alt103=2;
alt103 = this.dfa103.predict(this.input);
switch (alt103) {
case 1 :
// Ham4Parser.g:2605:4: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_action1seq9997);
action1276=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1276.getTree());
break;
default :
if ( cnt103 >= 1 ) {
break loop103;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(103, this.input);
throw eee;
}
cnt103++;
} while (true);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
action1tseq_return: (function() {
Ham4Parser.action1tseq_return = function(){};
org.antlr.lang.extend(Ham4Parser.action1tseq_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2608:1: action1tseq : ( action1t )+ ;
// $ANTLR start "action1tseq"
action1tseq: function() {
var retval = new Ham4Parser.action1tseq_return();
retval.start = this.input.LT(1);
var root_0 = null;
var action1t277 = null;
try {
// Ham4Parser.g:2609:2: ( ( action1t )+ )
// Ham4Parser.g:2609:4: ( action1t )+
root_0 = this.adaptor.nil();
// Ham4Parser.g:2609:4: ( action1t )+
var cnt104=0;
loop104:
do {
var alt104=2;
alt104 = this.dfa104.predict(this.input);
switch (alt104) {
case 1 :
// Ham4Parser.g:2609:4: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_action1tseq10009);
action1t277=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, action1t277.getTree());
break;
default :
if ( cnt104 >= 1 ) {
break loop104;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(104, this.input);
throw eee;
}
cnt104++;
} while (true);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction2t_return: (function() {
Ham4Parser.paraction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2612:1: paraction2t : HamParbegin ( action2t )+ HamParend -> ^( PARACT2T ( action2t )* ) ;
// $ANTLR start "paraction2t"
paraction2t: function() {
var retval = new Ham4Parser.paraction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin278 = null;
var HamParend280 = null;
var action2t279 = null;
var HamParbegin278_tree=null;
var HamParend280_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: paraction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2630:5: ( HamParbegin ( action2t )+ HamParend -> ^( PARACT2T ( action2t )* ) )
// Ham4Parser.g:2630:9: HamParbegin ( action2t )+ HamParend
HamParbegin278=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction2t10036); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin278);
// Ham4Parser.g:2631:9: ( action2t )+
var cnt105=0;
loop105:
do {
var alt105=2;
alt105 = this.dfa105.predict(this.input);
switch (alt105) {
case 1 :
// Ham4Parser.g:2631:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_paraction2t10049);
action2t279=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t279.getTree());
break;
default :
if ( cnt105 >= 1 ) {
break loop105;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(105, this.input);
throw eee;
}
cnt105++;
} while (true);
HamParend280=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction2t10062); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend280);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2634:6: -> ^( PARACT2T ( action2t )* )
{
// Ham4Parser.g:2634:9: ^( PARACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT2T, "PARACT2T"), root_1);
// Ham4Parser.g:2634:20: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqaction2t_return: (function() {
Ham4Parser.seqaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2637:1: seqaction2t : HamSeqbegin ( action2t )+ HamSeqend -> ^( SEQACT2T ( action2t )* ) ;
// $ANTLR start "seqaction2t"
seqaction2t: function() {
var retval = new Ham4Parser.seqaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin281 = null;
var HamSeqend283 = null;
var action2t282 = null;
var HamSeqbegin281_tree=null;
var HamSeqend283_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: seqaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2655:5: ( HamSeqbegin ( action2t )+ HamSeqend -> ^( SEQACT2T ( action2t )* ) )
// Ham4Parser.g:2655:9: HamSeqbegin ( action2t )+ HamSeqend
HamSeqbegin281=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqaction2t10115); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin281);
// Ham4Parser.g:2656:9: ( action2t )+
var cnt106=0;
loop106:
do {
var alt106=2;
alt106 = this.dfa106.predict(this.input);
switch (alt106) {
case 1 :
// Ham4Parser.g:2656:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_seqaction2t10128);
action2t282=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t282.getTree());
break;
default :
if ( cnt106 >= 1 ) {
break loop106;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(106, this.input);
throw eee;
}
cnt106++;
} while (true);
HamSeqend283=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqaction2t10141); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend283);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2659:6: -> ^( SEQACT2T ( action2t )* )
{
// Ham4Parser.g:2659:9: ^( SEQACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT2T, "SEQACT2T"), root_1);
// Ham4Parser.g:2659:20: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction2t_return: (function() {
Ham4Parser.seqfusedaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2662:1: seqfusedaction2t : HamFusionbegin ( action2t )+ HamFusionend -> ^( SEQFUSEDACT2T ( action2t )* ) ;
// $ANTLR start "seqfusedaction2t"
seqfusedaction2t: function() {
var retval = new Ham4Parser.seqfusedaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin284 = null;
var HamFusionend286 = null;
var action2t285 = null;
var HamFusionbegin284_tree=null;
var HamFusionend286_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action2t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action2t");
this.trace("ANTLR Parse: seqfusedaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2680:5: ( HamFusionbegin ( action2t )+ HamFusionend -> ^( SEQFUSEDACT2T ( action2t )* ) )
// Ham4Parser.g:2680:9: HamFusionbegin ( action2t )+ HamFusionend
HamFusionbegin284=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction2t10194); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin284);
// Ham4Parser.g:2681:9: ( action2t )+
var cnt107=0;
loop107:
do {
var alt107=2;
alt107 = this.dfa107.predict(this.input);
switch (alt107) {
case 1 :
// Ham4Parser.g:2681:11: action2t
this.pushFollow(Ham4Parser.FOLLOW_action2t_in_seqfusedaction2t10207);
action2t285=this.action2t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action2t.add(action2t285.getTree());
break;
default :
if ( cnt107 >= 1 ) {
break loop107;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(107, this.input);
throw eee;
}
cnt107++;
} while (true);
HamFusionend286=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction2t10220); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend286);
// AST REWRITE
// elements: action2t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2684:6: -> ^( SEQFUSEDACT2T ( action2t )* )
{
// Ham4Parser.g:2684:9: ^( SEQFUSEDACT2T ( action2t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT2T, "SEQFUSEDACT2T"), root_1);
// Ham4Parser.g:2684:25: ( action2t )*
while ( stream_action2t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action2t.nextTree());
}
stream_action2t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitaction2loc2_return: (function() {
Ham4Parser.splitaction2loc2_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitaction2loc2_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2687:1: splitaction2loc2 : HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2 -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 ) ;
// $ANTLR start "splitaction2loc2"
splitaction2loc2: function() {
var retval = new Ham4Parser.splitaction2loc2_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin287 = null;
var HamPlus288 = null;
var HamParend289 = null;
var acta = null;
var actb = null;
var location2290 = null;
var HamParbegin287_tree=null;
var HamPlus288_tree=null;
var HamParend289_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1seq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1seq");
var stream_location2=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule location2");
this.trace("ANTLR Parse: splitaction2loc2 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2708:5: ( HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2 -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 ) )
// Ham4Parser.g:2708:9: HamParbegin acta= action1seq HamPlus actb= action1seq HamParend location2
HamParbegin287=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitaction2loc210273); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin287);
this.pushFollow(Ham4Parser.FOLLOW_action1seq_in_splitaction2loc210286);
acta=this.action1seq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1seq.add(acta.getTree());
HamPlus288=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitaction2loc210296); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus288);
this.pushFollow(Ham4Parser.FOLLOW_action1seq_in_splitaction2loc210308);
actb=this.action1seq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1seq.add(actb.getTree());
HamParend289=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitaction2loc210318); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend289);
this.pushFollow(Ham4Parser.FOLLOW_location2_in_splitaction2loc210329);
location2290=this.location2();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_location2.add(location2290.getTree());
// AST REWRITE
// elements: HamPlus, acta, location2, actb
// token labels: 
// rule labels: acta, actb, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_acta=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token acta",acta!=null?acta.tree:null);
var stream_actb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token actb",actb!=null?actb.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2715:6: -> ^( SPLITACT2LOC2 $acta HamPlus $actb location2 )
{
// Ham4Parser.g:2715:9: ^( SPLITACT2LOC2 $acta HamPlus $actb location2 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITACT2LOC2, "SPLITACT2LOC2"), root_1);
this.adaptor.addChild(root_1, stream_acta.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_actb.nextTree());
this.adaptor.addChild(root_1, stream_location2.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitaction2loc2 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitaction2t_return: (function() {
Ham4Parser.splitaction2t_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitaction2t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2718:1: splitaction2t : HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend -> ^( SPLITACT2T $acta HamPlus $actb) ;
// $ANTLR start "splitaction2t"
splitaction2t: function() {
var retval = new Ham4Parser.splitaction2t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin291 = null;
var HamPlus292 = null;
var HamParend293 = null;
var acta = null;
var actb = null;
var HamParbegin291_tree=null;
var HamPlus292_tree=null;
var HamParend293_tree=null;
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1tseq=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1tseq");
this.trace("ANTLR Parse: splitaction2t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2738:5: ( HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend -> ^( SPLITACT2T $acta HamPlus $actb) )
// Ham4Parser.g:2738:9: HamParbegin acta= action1tseq HamPlus actb= action1tseq HamParend
HamParbegin291=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitaction2t10388); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin291);
this.pushFollow(Ham4Parser.FOLLOW_action1tseq_in_splitaction2t10401);
acta=this.action1tseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1tseq.add(acta.getTree());
HamPlus292=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitaction2t10411); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus292);
this.pushFollow(Ham4Parser.FOLLOW_action1tseq_in_splitaction2t10423);
actb=this.action1tseq();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1tseq.add(actb.getTree());
HamParend293=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitaction2t10433); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend293);
// AST REWRITE
// elements: HamPlus, acta, actb
// token labels: 
// rule labels: acta, actb, retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_acta=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token acta",acta!=null?acta.tree:null);
var stream_actb=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token actb",actb!=null?actb.tree:null);
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2744:6: -> ^( SPLITACT2T $acta HamPlus $actb)
{
// Ham4Parser.g:2744:9: ^( SPLITACT2T $acta HamPlus $actb)
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITACT2T, "SPLITACT2T"), root_1);
this.adaptor.addChild(root_1, stream_acta.nextTree());
this.adaptor.addChild(root_1, stream_HamPlus.nextNode());
this.adaptor.addChild(root_1, stream_actb.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitaction2t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction1t_return: (function() {
Ham4Parser.paraction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2747:1: paraction1t : HamParbegin ( action1t )+ HamParend -> ^( PARACT1T ( action1t )* ) ;
// $ANTLR start "paraction1t"
paraction1t: function() {
var retval = new Ham4Parser.paraction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin294 = null;
var HamParend296 = null;
var action1t295 = null;
var HamParbegin294_tree=null;
var HamParend296_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
this.trace("ANTLR Parse: paraction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2766:5: ( HamParbegin ( action1t )+ HamParend -> ^( PARACT1T ( action1t )* ) )
// Ham4Parser.g:2767:9: HamParbegin ( action1t )+ HamParend
HamParbegin294=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction1t10497); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin294);
// Ham4Parser.g:2768:9: ( action1t )+
var cnt108=0;
loop108:
do {
var alt108=2;
alt108 = this.dfa108.predict(this.input);
switch (alt108) {
case 1 :
// Ham4Parser.g:2768:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_paraction1t10510);
action1t295=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t295.getTree());
break;
default :
if ( cnt108 >= 1 ) {
break loop108;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(108, this.input);
throw eee;
}
cnt108++;
} while (true);
HamParend296=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction1t10523); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend296);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2771:6: -> ^( PARACT1T ( action1t )* )
{
// Ham4Parser.g:2771:9: ^( PARACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT1T, "PARACT1T"), root_1);
// Ham4Parser.g:2771:20: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqnmoraction1t_return: (function() {
Ham4Parser.seqnmoraction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqnmoraction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2774:1: seqnmoraction1t : HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend ;
// $ANTLR start "seqnmoraction1t"
seqnmoraction1t: function() {
var retval = new Ham4Parser.seqnmoraction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin297 = null;
var HamSeqend302 = null;
var levelbody298 = null;
var levelarm299 = null;
var action1t300 = null;
var action1t301 = null;
var HamSeqbegin297_tree=null;
var HamSeqend302_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
var stream_levelbody=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelbody");
var stream_levelarm=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule levelarm");
this.trace("ANTLR Parse: seqnmoraction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2803:5: ( HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend )
// Ham4Parser.g:2804:9: HamSeqbegin ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) ) HamSeqend
HamSeqbegin297=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqnmoraction1t10582); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin297);
// Ham4Parser.g:2805:9: ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) )
var alt111=2;
alt111 = this.dfa111.predict(this.input);
switch (alt111) {
case 1 :
// Ham4Parser.g:2806:4: ( ( levelbody )=> levelbody | levelarm ) action1t
// Ham4Parser.g:2806:4: ( ( levelbody )=> levelbody | levelarm )
var alt109=2;
alt109 = this.dfa109.predict(this.input);
switch (alt109) {
case 1 :
// Ham4Parser.g:2807:6: ( levelbody )=> levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_seqnmoraction1t10613);
levelbody298=this.levelbody();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelbody.add(levelbody298.getTree());
break;
case 2 :
// Ham4Parser.g:2809:6: levelarm
this.pushFollow(Ham4Parser.FOLLOW_levelarm_in_seqnmoraction1t10625);
levelarm299=this.levelarm();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_levelarm.add(levelarm299.getTree());
break;
}
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqnmoraction1t10635);
action1t300=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t300.getTree());
// AST REWRITE
// elements: action1t, levelbody, levelarm
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2812:6: -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t )
{
// Ham4Parser.g:2812:9: ^( NMACT1T ( levelbody )* ( levelarm )* action1t )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(NMACT1T, "NMACT1T"), root_1);
// Ham4Parser.g:2812:19: ( levelbody )*
while ( stream_levelbody.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelbody.nextTree());
}
stream_levelbody.reset();
// Ham4Parser.g:2812:30: ( levelarm )*
while ( stream_levelarm.hasNext() ) {
this.adaptor.addChild(root_1, stream_levelarm.nextTree());
}
stream_levelarm.reset();
this.adaptor.addChild(root_1, stream_action1t.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:2814:10: ( action1t )+
// Ham4Parser.g:2814:10: ( action1t )+
var cnt110=0;
loop110:
do {
var alt110=2;
alt110 = this.dfa110.predict(this.input);
switch (alt110) {
case 1 :
// Ham4Parser.g:2814:12: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqnmoraction1t10671);
action1t301=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t301.getTree());
break;
default :
if ( cnt110 >= 1 ) {
break loop110;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(110, this.input);
throw eee;
}
cnt110++;
} while (true);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2815:6: -> ^( SEQACT1T ( action1t )* )
{
// Ham4Parser.g:2815:9: ^( SEQACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT1T, "SEQACT1T"), root_1);
// Ham4Parser.g:2815:20: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
HamSeqend302=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqnmoraction1t10708); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend302);
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqnmoraction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction1t_return: (function() {
Ham4Parser.seqfusedaction1t_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction1t_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2821:1: seqfusedaction1t : HamFusionbegin ( action1t )+ HamFusionend -> ^( SEQFUSEDACT1T ( action1t )* ) ;
// $ANTLR start "seqfusedaction1t"
seqfusedaction1t: function() {
var retval = new Ham4Parser.seqfusedaction1t_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin303 = null;
var HamFusionend305 = null;
var action1t304 = null;
var HamFusionbegin303_tree=null;
var HamFusionend305_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action1t=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1t");
this.trace("ANTLR Parse: seqfusedaction1t starts "+this.state.backtracking);
try {
// Ham4Parser.g:2840:5: ( HamFusionbegin ( action1t )+ HamFusionend -> ^( SEQFUSEDACT1T ( action1t )* ) )
// Ham4Parser.g:2841:9: HamFusionbegin ( action1t )+ HamFusionend
HamFusionbegin303=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction1t10753); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin303);
// Ham4Parser.g:2842:9: ( action1t )+
var cnt112=0;
loop112:
do {
var alt112=2;
alt112 = this.dfa112.predict(this.input);
switch (alt112) {
case 1 :
// Ham4Parser.g:2842:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_seqfusedaction1t10766);
action1t304=this.action1t();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1t.add(action1t304.getTree());
break;
default :
if ( cnt112 >= 1 ) {
break loop112;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(112, this.input);
throw eee;
}
cnt112++;
} while (true);
HamFusionend305=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction1t10779); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend305);
// AST REWRITE
// elements: action1t
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2845:5: -> ^( SEQFUSEDACT1T ( action1t )* )
{
// Ham4Parser.g:2845:8: ^( SEQFUSEDACT1T ( action1t )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT1T, "SEQFUSEDACT1T"), root_1);
// Ham4Parser.g:2845:24: ( action1t )*
while ( stream_action1t.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1t.nextTree());
}
stream_action1t.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction1t finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
paraction1_return: (function() {
Ham4Parser.paraction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.paraction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2848:1: paraction1 : HamParbegin ( action1 )+ HamParend -> ^( PARACT1 ( action1 )* ) ;
// $ANTLR start "paraction1"
paraction1: function() {
var retval = new Ham4Parser.paraction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin306 = null;
var HamParend308 = null;
var action1307 = null;
var HamParbegin306_tree=null;
var HamParend308_tree=null;
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: paraction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2867:5: ( HamParbegin ( action1 )+ HamParend -> ^( PARACT1 ( action1 )* ) )
// Ham4Parser.g:2868:9: HamParbegin ( action1 )+ HamParend
HamParbegin306=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_paraction110837); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin306);
// Ham4Parser.g:2869:9: ( action1 )+
var cnt113=0;
loop113:
do {
var alt113=2;
alt113 = this.dfa113.predict(this.input);
switch (alt113) {
case 1 :
// Ham4Parser.g:2869:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_paraction110850);
action1307=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1307.getTree());
break;
default :
if ( cnt113 >= 1 ) {
break loop113;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(113, this.input);
throw eee;
}
cnt113++;
} while (true);
HamParend308=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_paraction110863); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend308);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2872:5: -> ^( PARACT1 ( action1 )* )
{
// Ham4Parser.g:2872:8: ^( PARACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(PARACT1, "PARACT1"), root_1);
// Ham4Parser.g:2872:18: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: paraction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqaction1_return: (function() {
Ham4Parser.seqaction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqaction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2875:1: seqaction1 : HamSeqbegin ( action1 )+ HamSeqend -> ^( SEQACT1 ( action1 )* ) ;
// $ANTLR start "seqaction1"
seqaction1: function() {
var retval = new Ham4Parser.seqaction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin309 = null;
var HamSeqend311 = null;
var action1310 = null;
var HamSeqbegin309_tree=null;
var HamSeqend311_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: seqaction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2894:5: ( HamSeqbegin ( action1 )+ HamSeqend -> ^( SEQACT1 ( action1 )* ) )
// Ham4Parser.g:2895:9: HamSeqbegin ( action1 )+ HamSeqend
HamSeqbegin309=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_seqaction110921); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin309);
// Ham4Parser.g:2896:9: ( action1 )+
var cnt114=0;
loop114:
do {
var alt114=2;
alt114 = this.dfa114.predict(this.input);
switch (alt114) {
case 1 :
// Ham4Parser.g:2896:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_seqaction110934);
action1310=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1310.getTree());
break;
default :
if ( cnt114 >= 1 ) {
break loop114;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(114, this.input);
throw eee;
}
cnt114++;
} while (true);
HamSeqend311=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_seqaction110947); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend311);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2899:5: -> ^( SEQACT1 ( action1 )* )
{
// Ham4Parser.g:2899:8: ^( SEQACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQACT1, "SEQACT1"), root_1);
// Ham4Parser.g:2899:18: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqaction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
seqfusedaction1_return: (function() {
Ham4Parser.seqfusedaction1_return = function(){};
org.antlr.lang.extend(Ham4Parser.seqfusedaction1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2902:1: seqfusedaction1 : HamFusionbegin ( action1 )+ HamFusionend -> ^( SEQFUSEDACT1 ( action1 )* ) ;
// $ANTLR start "seqfusedaction1"
seqfusedaction1: function() {
var retval = new Ham4Parser.seqfusedaction1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFusionbegin312 = null;
var HamFusionend314 = null;
var action1313 = null;
var HamFusionbegin312_tree=null;
var HamFusionend314_tree=null;
var stream_HamFusionbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionbegin");
var stream_HamFusionend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFusionend");
var stream_action1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule action1");
this.trace("ANTLR Parse: seqfusedaction1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:2921:5: ( HamFusionbegin ( action1 )+ HamFusionend -> ^( SEQFUSEDACT1 ( action1 )* ) )
// Ham4Parser.g:2922:9: HamFusionbegin ( action1 )+ HamFusionend
HamFusionbegin312=this.match(this.input,HamFusionbegin,Ham4Parser.FOLLOW_HamFusionbegin_in_seqfusedaction111005); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionbegin.add(HamFusionbegin312);
// Ham4Parser.g:2923:9: ( action1 )+
var cnt115=0;
loop115:
do {
var alt115=2;
alt115 = this.dfa115.predict(this.input);
switch (alt115) {
case 1 :
// Ham4Parser.g:2923:11: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_seqfusedaction111018);
action1313=this.action1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_action1.add(action1313.getTree());
break;
default :
if ( cnt115 >= 1 ) {
break loop115;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(115, this.input);
throw eee;
}
cnt115++;
} while (true);
HamFusionend314=this.match(this.input,HamFusionend,Ham4Parser.FOLLOW_HamFusionend_in_seqfusedaction111031); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFusionend.add(HamFusionend314);
// AST REWRITE
// elements: action1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 2926:5: -> ^( SEQFUSEDACT1 ( action1 )* )
{
// Ham4Parser.g:2926:8: ^( SEQFUSEDACT1 ( action1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SEQFUSEDACT1, "SEQFUSEDACT1"), root_1);
// Ham4Parser.g:2926:23: ( action1 )*
while ( stream_action1.hasNext() ) {
this.adaptor.addChild(root_1, stream_action1.nextTree());
}
stream_action1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: seqfusedaction1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetitionsoption_return: (function() {
Ham4Parser.repetitionsoption_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetitionsoption_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2929:1: repetitionsoption : ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )? ;
// $ANTLR start "repetitionsoption"
repetitionsoption: function() {
var retval = new Ham4Parser.repetitionsoption_return();
retval.start = this.input.LT(1);
var root_0 = null;
var repetitions315 = null;
this.trace("ANTLR Parse: repetitionsoption starts "+this.state.backtracking);
try {
// Ham4Parser.g:2948:5: ( ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )? )
// Ham4Parser.g:2949:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?
root_0 = this.adaptor.nil();
// Ham4Parser.g:2949:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?
var alt116=2;
alt116 = this.dfa116.predict(this.input);
switch (alt116) {
case 1 :
// Ham4Parser.g:2950:13: ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions
this.pushFollow(Ham4Parser.FOLLOW_repetitions_in_repetitionsoption11146);
repetitions315=this.repetitions();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, repetitions315.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetitionsoption finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetitions_return: (function() {
Ham4Parser.repetitions_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetitions_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:2956:1: repetitions : ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) ) ;
// $ANTLR start "repetitions"
repetitions: function() {
var retval = new Ham4Parser.repetitions_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin316 = null;
var HamRepeatfromstartseveral317 = null;
var HamEtc318 = null;
var HamSeqend320 = null;
var HamEtc322 = null;
var HamAlternatingmotion326 = null;
var HamAlternatingmotion327 = null;
var HamAlternatingmotion328 = null;
var HamAlternatingmotion329 = null;
var ellipsedirection319 = null;
var repetition321 = null;
var repetition323 = null;
var movingrepetition324 = null;
var sizechangenonlinear325 = null;
var HamSeqbegin316_tree=null;
var HamRepeatfromstartseveral317_tree=null;
var HamEtc318_tree=null;
var HamSeqend320_tree=null;
var HamEtc322_tree=null;
var HamAlternatingmotion326_tree=null;
var HamAlternatingmotion327_tree=null;
var HamAlternatingmotion328_tree=null;
var HamAlternatingmotion329_tree=null;
var stream_HamAlternatingmotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamAlternatingmotion");
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamEtc=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamEtc");
var stream_HamRepeatfromstartseveral=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamRepeatfromstartseveral");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_movingrepetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movingrepetition");
var stream_ellipsedirection=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ellipsedirection");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_repetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetition");
this.trace("ANTLR Parse: repetitions starts "+this.state.backtracking);
try {
// Ham4Parser.g:3001:5: ( ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) ) )
// Ham4Parser.g:3002:5: ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) )
// Ham4Parser.g:3002:5: ( ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection ) | ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* ) | HamAlternatingmotion ( HamAlternatingmotion )? -> ^( REPETITIONS ( HamAlternatingmotion )* ) )
var alt123=3;
switch ( this.input.LA(1) ) {
case HamSeqbegin:
var LA123_1 = this.input.LA(2);
if ( (this.synpred36_Ham4Parser()) ) {
alt123=1;
}
else if ( (true) ) {
alt123=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 123, 1, this.input);
throw nvae;
}
break;
case HamRepeatfromstart:
case HamRepeatfromstartseveral:
case HamRepeatcontinue:
case HamRepeatcontinueseveral:
case HamRepeatreverse:
alt123=2;
break;
case HamAlternatingmotion:
alt123=3;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 123, 0, this.input);
throw nvae;
}
switch (alt123) {
case 1 :
// Ham4Parser.g:3003:9: ( HamSeqbegin HamRepeatfromstartseveral HamEtc )=> HamSeqbegin HamRepeatfromstartseveral HamEtc ellipsedirection HamSeqend
HamSeqbegin316=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_repetitions11226); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin316);
HamRepeatfromstartseveral317=this.match(this.input,HamRepeatfromstartseveral,Ham4Parser.FOLLOW_HamRepeatfromstartseveral_in_repetitions11237); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamRepeatfromstartseveral.add(HamRepeatfromstartseveral317);
HamEtc318=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_repetitions11247); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc318);
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_repetitions11257);
ellipsedirection319=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ellipsedirection.add(ellipsedirection319.getTree());
HamSeqend320=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_repetitions11267); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend320);
// AST REWRITE
// elements: HamRepeatfromstartseveral, ellipsedirection, HamEtc
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3010:5: -> ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection )
{
// Ham4Parser.g:3010:8: ^( REPETITIONS HamRepeatfromstartseveral HamEtc ellipsedirection )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
this.adaptor.addChild(root_1, stream_HamRepeatfromstartseveral.nextNode());
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
this.adaptor.addChild(root_1, stream_ellipsedirection.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:3012:9: ( repetition ( HamEtc | repetition )? | movingrepetition ) ( sizechangenonlinear )? ( HamAlternatingmotion ( HamAlternatingmotion )? )?
// Ham4Parser.g:3012:9: ( repetition ( HamEtc | repetition )? | movingrepetition )
var alt118=2;
var LA118_0 = this.input.LA(1);
if ( ((LA118_0>=HamRepeatfromstart && LA118_0<=HamRepeatcontinueseveral)||LA118_0==HamRepeatreverse) ) {
alt118=1;
}
else if ( (LA118_0==HamSeqbegin) ) {
alt118=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 118, 0, this.input);
throw nvae;
}
switch (alt118) {
case 1 :
// Ham4Parser.g:3013:13: repetition ( HamEtc | repetition )?
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_repetitions11314);
repetition321=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition321.getTree());
// Ham4Parser.g:3014:13: ( HamEtc | repetition )?
var alt117=3;
var LA117_0 = this.input.LA(1);
if ( (LA117_0==HamEtc) ) {
alt117=1;
}
else if ( ((LA117_0>=HamRepeatfromstart && LA117_0<=HamRepeatcontinueseveral)||LA117_0==HamRepeatreverse) ) {
alt117=2;
}
switch (alt117) {
case 1 :
// Ham4Parser.g:3015:17: HamEtc
HamEtc322=this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_repetitions11346); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamEtc.add(HamEtc322);
break;
case 2 :
// Ham4Parser.g:3017:17: repetition
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_repetitions11378);
repetition323=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition323.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3020:13: movingrepetition
this.pushFollow(Ham4Parser.FOLLOW_movingrepetition_in_repetitions11417);
movingrepetition324=this.movingrepetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movingrepetition.add(movingrepetition324.getTree());
break;
}
// Ham4Parser.g:3022:9: ( sizechangenonlinear )?
var alt119=2;
var LA119_0 = this.input.LA(1);
if ( ((LA119_0>=HamIncreasing && LA119_0<=HamDecreasing)) ) {
alt119=1;
}
switch (alt119) {
case 1 :
// Ham4Parser.g:3022:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_repetitions11439);
sizechangenonlinear325=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear325.getTree());
break;
}
// Ham4Parser.g:3023:9: ( HamAlternatingmotion ( HamAlternatingmotion )? )?
var alt121=2;
var LA121_0 = this.input.LA(1);
if ( (LA121_0==HamAlternatingmotion) ) {
alt121=1;
}
switch (alt121) {
case 1 :
// Ham4Parser.g:3024:13: HamAlternatingmotion ( HamAlternatingmotion )?
HamAlternatingmotion326=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11466); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion326);
// Ham4Parser.g:3025:13: ( HamAlternatingmotion )?
var alt120=2;
var LA120_0 = this.input.LA(1);
if ( (LA120_0==HamAlternatingmotion) ) {
alt120=1;
}
switch (alt120) {
case 1 :
// Ham4Parser.g:3025:15: HamAlternatingmotion
HamAlternatingmotion327=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11482); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion327);
break;
}
break;
}
// AST REWRITE
// elements: HamEtc, repetition, movingrepetition, HamAlternatingmotion, sizechangenonlinear
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3027:5: -> ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* )
{
// Ham4Parser.g:3027:8: ^( REPETITIONS ( repetition )* ( HamEtc )? ( movingrepetition )? ( sizechangenonlinear )? ( HamAlternatingmotion )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
// Ham4Parser.g:3027:22: ( repetition )*
while ( stream_repetition.hasNext() ) {
this.adaptor.addChild(root_1, stream_repetition.nextTree());
}
stream_repetition.reset();
// Ham4Parser.g:3027:34: ( HamEtc )?
if ( stream_HamEtc.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamEtc.nextNode());
}
stream_HamEtc.reset();
// Ham4Parser.g:3027:42: ( movingrepetition )?
if ( stream_movingrepetition.hasNext() ) {
this.adaptor.addChild(root_1, stream_movingrepetition.nextTree());
}
stream_movingrepetition.reset();
// Ham4Parser.g:3027:60: ( sizechangenonlinear )?
if ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
// Ham4Parser.g:3027:81: ( HamAlternatingmotion )*
while ( stream_HamAlternatingmotion.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamAlternatingmotion.nextNode());
}
stream_HamAlternatingmotion.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:3029:9: HamAlternatingmotion ( HamAlternatingmotion )?
HamAlternatingmotion328=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11537); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion328);
// Ham4Parser.g:3030:9: ( HamAlternatingmotion )?
var alt122=2;
var LA122_0 = this.input.LA(1);
if ( (LA122_0==HamAlternatingmotion) ) {
alt122=1;
}
switch (alt122) {
case 1 :
// Ham4Parser.g:3030:11: HamAlternatingmotion
HamAlternatingmotion329=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_repetitions11549); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamAlternatingmotion.add(HamAlternatingmotion329);
break;
}
// AST REWRITE
// elements: HamAlternatingmotion
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3031:5: -> ^( REPETITIONS ( HamAlternatingmotion )* )
{
// Ham4Parser.g:3031:8: ^( REPETITIONS ( HamAlternatingmotion )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPETITIONS, "REPETITIONS"), root_1);
// Ham4Parser.g:3031:22: ( HamAlternatingmotion )*
while ( stream_HamAlternatingmotion.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamAlternatingmotion.nextNode());
}
stream_HamAlternatingmotion.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetitions finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
alternations_return: (function() {
Ham4Parser.alternations_return = function(){};
org.antlr.lang.extend(Ham4Parser.alternations_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3035:1: alternations : HamAlternatingmotion ( HamAlternatingmotion )? ;
// $ANTLR start "alternations"
alternations: function() {
var retval = new Ham4Parser.alternations_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamAlternatingmotion330 = null;
var HamAlternatingmotion331 = null;
var HamAlternatingmotion330_tree=null;
var HamAlternatingmotion331_tree=null;
this.trace("ANTLR Parse: alternations starts "+this.state.backtracking);
try {
// Ham4Parser.g:3050:5: ( HamAlternatingmotion ( HamAlternatingmotion )? )
// Ham4Parser.g:3050:9: HamAlternatingmotion ( HamAlternatingmotion )?
root_0 = this.adaptor.nil();
HamAlternatingmotion330=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_alternations11600); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion330_tree = this.adaptor.create(HamAlternatingmotion330);
this.adaptor.addChild(root_0, HamAlternatingmotion330_tree);
}
// Ham4Parser.g:3051:9: ( HamAlternatingmotion )?
var alt124=2;
var LA124_0 = this.input.LA(1);
if ( (LA124_0==HamAlternatingmotion) ) {
alt124=1;
}
switch (alt124) {
case 1 :
// Ham4Parser.g:3051:11: HamAlternatingmotion
HamAlternatingmotion331=this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_alternations11612); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamAlternatingmotion331_tree = this.adaptor.create(HamAlternatingmotion331);
this.adaptor.addChild(root_0, HamAlternatingmotion331_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: alternations finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movingrepetition_return: (function() {
Ham4Parser.movingrepetition_return = function(){};
org.antlr.lang.extend(Ham4Parser.movingrepetition_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3054:1: movingrepetition : HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* ) ;
// $ANTLR start "movingrepetition"
movingrepetition: function() {
var retval = new Ham4Parser.movingrepetition_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin332 = null;
var HamSeqend337 = null;
var repetition333 = null;
var movementarrow334 = null;
var size335 = null;
var sizechangenonlinear336 = null;
var HamSeqbegin332_tree=null;
var HamSeqend337_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_movementarrow=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementarrow");
var stream_size=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule size");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_repetition=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule repetition");
this.trace("ANTLR Parse: movingrepetition starts "+this.state.backtracking);
try {
// Ham4Parser.g:3076:5: ( HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* ) )
// Ham4Parser.g:3077:9: HamSeqbegin repetition movementarrow ( size )? ( sizechangenonlinear )? HamSeqend
HamSeqbegin332=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_movingrepetition11650); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin332);
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_movingrepetition11661);
repetition333=this.repetition();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_repetition.add(repetition333.getTree());
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_movingrepetition11671);
movementarrow334=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow334.getTree());
// Ham4Parser.g:3080:9: ( size )?
var alt125=2;
var LA125_0 = this.input.LA(1);
if ( ((LA125_0>=HamSmallmod && LA125_0<=HamLargemod)) ) {
alt125=1;
}
switch (alt125) {
case 1 :
// Ham4Parser.g:3080:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_movingrepetition11683);
size335=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size335.getTree());
break;
}
// Ham4Parser.g:3081:9: ( sizechangenonlinear )?
var alt126=2;
var LA126_0 = this.input.LA(1);
if ( ((LA126_0>=HamIncreasing && LA126_0<=HamDecreasing)) ) {
alt126=1;
}
switch (alt126) {
case 1 :
// Ham4Parser.g:3081:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_movingrepetition11698);
sizechangenonlinear336=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear336.getTree());
break;
}
HamSeqend337=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_movingrepetition11711); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend337);
// AST REWRITE
// elements: sizechangenonlinear, movementarrow, repetition, size
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3084:4: -> ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* )
{
// Ham4Parser.g:3084:7: ^( MOVINGREPETITION repetition movementarrow ( size )* ( sizechangenonlinear )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(MOVINGREPETITION, "MOVINGREPETITION"), root_1);
this.adaptor.addChild(root_1, stream_repetition.nextTree());
this.adaptor.addChild(root_1, stream_movementarrow.nextTree());
// Ham4Parser.g:3084:51: ( size )*
while ( stream_size.hasNext() ) {
this.adaptor.addChild(root_1, stream_size.nextTree());
}
stream_size.reset();
// Ham4Parser.g:3084:57: ( sizechangenonlinear )*
while ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movingrepetition finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
simplemovement_return: (function() {
Ham4Parser.simplemovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.simplemovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3090:1: simplemovement : ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )? -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? ) ;
// $ANTLR start "simplemovement"
simplemovement: function() {
var retval = new Ham4Parser.simplemovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamFingerplay352 = null;
var straightmovement338 = null;
var size339 = null;
var arckind340 = null;
var zigzag341 = null;
var circularmovement342 = null;
var size343 = null;
var revolutions344 = null;
var ellipse345 = null;
var sizechangenonlinear346 = null;
var movementcross347 = null;
var size348 = null;
var wristmovement349 = null;
var size350 = null;
var replacement351 = null;
var brushingcontact353 = null;
var locationindexdefine354 = null;
var HamFingerplay352_tree=null;
var stream_HamFingerplay=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFingerplay");
var stream_locationindexdefine=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locationindexdefine");
var stream_movementcross=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementcross");
var stream_brushingcontact=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule brushingcontact");
var stream_sizechangenonlinear=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechangenonlinear");
var stream_arckind=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule arckind");
var stream_straightmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule straightmovement");
var stream_zigzag=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule zigzag");
var stream_circularmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule circularmovement");
var stream_revolutions=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule revolutions");
var stream_size=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule size");
var stream_ellipse=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule ellipse");
var stream_wristmovement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule wristmovement");
var stream_replacement=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule replacement");
this.trace("ANTLR Parse: simplemovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3145:5: ( ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )? -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? ) )
// Ham4Parser.g:3146:9: ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay ) ( ( HamSeqbegin HamBrushing )=> brushingcontact )? ( ( locationindexdefine )=> locationindexdefine )?
// Ham4Parser.g:3146:9: ( straightmovement ( size )? ( arckind | zigzag )? | circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? | movementcross ( size )? | wristmovement ( size )? | replacement | HamFingerplay )
var alt135=6;
switch ( this.input.LA(1) ) {
case HamMoveu:
case HamMoveur:
case HamMover:
case HamMovedr:
case HamMoved:
case HamMovedl:
case HamMovel:
case HamMoveul:
case HamMoveol:
case HamMoveo:
case HamMoveor:
case HamMoveil:
case HamMovei:
case HamMoveir:
case HamMoveui:
case HamMovedi:
case HamMovedo:
case HamMoveuo:
alt135=1;
break;
case HamCircleo:
case HamCirclei:
case HamCircled:
case HamCircleu:
case HamCirclel:
case HamCircler:
case HamCircleul:
case HamCircledr:
case HamCircleur:
case HamCircledl:
case HamCircleol:
case HamCircleir:
case HamCircleor:
case HamCircleil:
case HamCircledo:
case HamCircleui:
case HamCircledi:
case HamCircleuo:
alt135=2;
break;
case HamMovecross:
case HamMovex:
alt135=3;
break;
case HamNodding:
case HamSwinging:
case HamTwisting:
case HamStircw:
case HamStirccw:
alt135=4;
break;
case HamReplace:
alt135=5;
break;
case HamFingerplay:
alt135=6;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);
throw nvae;
}
switch (alt135) {
case 1 :
// Ham4Parser.g:3147:13: straightmovement ( size )? ( arckind | zigzag )?
this.pushFollow(Ham4Parser.FOLLOW_straightmovement_in_simplemovement11792);
straightmovement338=this.straightmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_straightmovement.add(straightmovement338.getTree());
// Ham4Parser.g:3148:13: ( size )?
var alt127=2;
alt127 = this.dfa127.predict(this.input);
switch (alt127) {
case 1 :
// Ham4Parser.g:3148:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement11808);
size339=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size339.getTree());
break;
}
// Ham4Parser.g:3149:13: ( arckind | zigzag )?
var alt128=3;
alt128 = this.dfa128.predict(this.input);
switch (alt128) {
case 1 :
// Ham4Parser.g:3150:17: arckind
this.pushFollow(Ham4Parser.FOLLOW_arckind_in_simplemovement11843);
arckind340=this.arckind();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_arckind.add(arckind340.getTree());
break;
case 2 :
// Ham4Parser.g:3152:17: zigzag
this.pushFollow(Ham4Parser.FOLLOW_zigzag_in_simplemovement11875);
zigzag341=this.zigzag();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_zigzag.add(zigzag341.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3155:13: circularmovement ( size )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )?
this.pushFollow(Ham4Parser.FOLLOW_circularmovement_in_simplemovement11914);
circularmovement342=this.circularmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_circularmovement.add(circularmovement342.getTree());
// Ham4Parser.g:3156:13: ( size )?
var alt129=2;
alt129 = this.dfa129.predict(this.input);
switch (alt129) {
case 1 :
// Ham4Parser.g:3156:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement11930);
size343=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size343.getTree());
break;
}
// Ham4Parser.g:3157:13: ( revolutions )?
var alt130=2;
alt130 = this.dfa130.predict(this.input);
switch (alt130) {
case 1 :
// Ham4Parser.g:3157:15: revolutions
this.pushFollow(Ham4Parser.FOLLOW_revolutions_in_simplemovement11949);
revolutions344=this.revolutions();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_revolutions.add(revolutions344.getTree());
break;
}
// Ham4Parser.g:3158:13: ( ellipse )?
var alt131=2;
alt131 = this.dfa131.predict(this.input);
switch (alt131) {
case 1 :
// Ham4Parser.g:3158:15: ellipse
this.pushFollow(Ham4Parser.FOLLOW_ellipse_in_simplemovement11968);
ellipse345=this.ellipse();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_ellipse.add(ellipse345.getTree());
break;
}
// Ham4Parser.g:3159:13: ( sizechangenonlinear )?
var alt132=2;
alt132 = this.dfa132.predict(this.input);
switch (alt132) {
case 1 :
// Ham4Parser.g:3159:15: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_simplemovement11987);
sizechangenonlinear346=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechangenonlinear.add(sizechangenonlinear346.getTree());
break;
}
break;
case 3 :
// Ham4Parser.g:3161:13: movementcross ( size )?
this.pushFollow(Ham4Parser.FOLLOW_movementcross_in_simplemovement12014);
movementcross347=this.movementcross();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcross.add(movementcross347.getTree());
// Ham4Parser.g:3162:13: ( size )?
var alt133=2;
alt133 = this.dfa133.predict(this.input);
switch (alt133) {
case 1 :
// Ham4Parser.g:3162:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement12030);
size348=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size348.getTree());
break;
}
break;
case 4 :
// Ham4Parser.g:3164:13: wristmovement ( size )?
this.pushFollow(Ham4Parser.FOLLOW_wristmovement_in_simplemovement12057);
wristmovement349=this.wristmovement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_wristmovement.add(wristmovement349.getTree());
// Ham4Parser.g:3165:13: ( size )?
var alt134=2;
alt134 = this.dfa134.predict(this.input);
switch (alt134) {
case 1 :
// Ham4Parser.g:3165:15: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_simplemovement12073);
size350=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_size.add(size350.getTree());
break;
}
break;
case 5 :
// Ham4Parser.g:3167:13: replacement
this.pushFollow(Ham4Parser.FOLLOW_replacement_in_simplemovement12100);
replacement351=this.replacement();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacement.add(replacement351.getTree());
break;
case 6 :
// Ham4Parser.g:3169:13: HamFingerplay
HamFingerplay352=this.match(this.input,HamFingerplay,Ham4Parser.FOLLOW_HamFingerplay_in_simplemovement12124); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFingerplay.add(HamFingerplay352);
break;
}
// Ham4Parser.g:3171:9: ( ( HamSeqbegin HamBrushing )=> brushingcontact )?
var alt136=2;
alt136 = this.dfa136.predict(this.input);
switch (alt136) {
case 1 :
// Ham4Parser.g:3172:11: ( HamSeqbegin HamBrushing )=> brushingcontact
this.pushFollow(Ham4Parser.FOLLOW_brushingcontact_in_simplemovement12186);
brushingcontact353=this.brushingcontact();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_brushingcontact.add(brushingcontact353.getTree());
break;
}
// Ham4Parser.g:3176:9: ( ( locationindexdefine )=> locationindexdefine )?
var alt137=2;
alt137 = this.dfa137.predict(this.input);
switch (alt137) {
case 1 :
// Ham4Parser.g:3177:11: ( locationindexdefine )=> locationindexdefine
this.pushFollow(Ham4Parser.FOLLOW_locationindexdefine_in_simplemovement12281);
locationindexdefine354=this.locationindexdefine();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locationindexdefine.add(locationindexdefine354.getTree());
break;
}
// AST REWRITE
// elements: arckind, brushingcontact, HamFingerplay, movementcross, zigzag, wristmovement, circularmovement, locationindexdefine, ellipse, sizechangenonlinear, revolutions, size, straightmovement, replacement
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3182:4: -> ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? )
{
// Ham4Parser.g:3182:7: ^( SIMPLEMVMT ( straightmovement )? ( circularmovement )? ( movementcross )? ( wristmovement )? ( size )? ( arckind )? ( zigzag )? ( revolutions )? ( ellipse )? ( sizechangenonlinear )? ( replacement )? ( HamFingerplay )? ( brushingcontact )? ( locationindexdefine )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIMPLEMVMT, "SIMPLEMVMT"), root_1);
// Ham4Parser.g:3182:20: ( straightmovement )?
if ( stream_straightmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_straightmovement.nextTree());
}
stream_straightmovement.reset();
// Ham4Parser.g:3182:38: ( circularmovement )?
if ( stream_circularmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_circularmovement.nextTree());
}
stream_circularmovement.reset();
// Ham4Parser.g:3182:56: ( movementcross )?
if ( stream_movementcross.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementcross.nextTree());
}
stream_movementcross.reset();
// Ham4Parser.g:3182:71: ( wristmovement )?
if ( stream_wristmovement.hasNext() ) {
this.adaptor.addChild(root_1, stream_wristmovement.nextTree());
}
stream_wristmovement.reset();
// Ham4Parser.g:3182:86: ( size )?
if ( stream_size.hasNext() ) {
this.adaptor.addChild(root_1, stream_size.nextTree());
}
stream_size.reset();
// Ham4Parser.g:3183:6: ( arckind )?
if ( stream_arckind.hasNext() ) {
this.adaptor.addChild(root_1, stream_arckind.nextTree());
}
stream_arckind.reset();
// Ham4Parser.g:3183:15: ( zigzag )?
if ( stream_zigzag.hasNext() ) {
this.adaptor.addChild(root_1, stream_zigzag.nextTree());
}
stream_zigzag.reset();
// Ham4Parser.g:3184:6: ( revolutions )?
if ( stream_revolutions.hasNext() ) {
this.adaptor.addChild(root_1, stream_revolutions.nextTree());
}
stream_revolutions.reset();
// Ham4Parser.g:3184:19: ( ellipse )?
if ( stream_ellipse.hasNext() ) {
this.adaptor.addChild(root_1, stream_ellipse.nextTree());
}
stream_ellipse.reset();
// Ham4Parser.g:3184:28: ( sizechangenonlinear )?
if ( stream_sizechangenonlinear.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechangenonlinear.nextTree());
}
stream_sizechangenonlinear.reset();
// Ham4Parser.g:3185:6: ( replacement )?
if ( stream_replacement.hasNext() ) {
this.adaptor.addChild(root_1, stream_replacement.nextTree());
}
stream_replacement.reset();
// Ham4Parser.g:3185:19: ( HamFingerplay )?
if ( stream_HamFingerplay.hasNext() ) {
this.adaptor.addChild(root_1, stream_HamFingerplay.nextNode());
}
stream_HamFingerplay.reset();
// Ham4Parser.g:3186:6: ( brushingcontact )?
if ( stream_brushingcontact.hasNext() ) {
this.adaptor.addChild(root_1, stream_brushingcontact.nextTree());
}
stream_brushingcontact.reset();
// Ham4Parser.g:3186:23: ( locationindexdefine )?
if ( stream_locationindexdefine.hasNext() ) {
this.adaptor.addChild(root_1, stream_locationindexdefine.nextTree());
}
stream_locationindexdefine.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: simplemovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
specialfingerplaymovement_return: (function() {
Ham4Parser.specialfingerplaymovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.specialfingerplaymovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3189:1: specialfingerplaymovement : HamSeqbegin ( digit )+ HamFingerplay HamSeqend -> ^( SIMPLEMVMT ( digit )* HamFingerplay ) ;
// $ANTLR start "specialfingerplaymovement"
specialfingerplaymovement: function() {
var retval = new Ham4Parser.specialfingerplaymovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin355 = null;
var HamFingerplay357 = null;
var HamSeqend358 = null;
var digit356 = null;
var HamSeqbegin355_tree=null;
var HamFingerplay357_tree=null;
var HamSeqend358_tree=null;
var stream_HamSeqbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqbegin");
var stream_HamFingerplay=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamFingerplay");
var stream_HamSeqend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamSeqend");
var stream_digit=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule digit");
this.trace("ANTLR Parse: specialfingerplaymovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3208:5: ( HamSeqbegin ( digit )+ HamFingerplay HamSeqend -> ^( SIMPLEMVMT ( digit )* HamFingerplay ) )
// Ham4Parser.g:3209:9: HamSeqbegin ( digit )+ HamFingerplay HamSeqend
HamSeqbegin355=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_specialfingerplaymovement12441); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqbegin.add(HamSeqbegin355);
// Ham4Parser.g:3210:9: ( digit )+
var cnt138=0;
loop138:
do {
var alt138=2;
var LA138_0 = this.input.LA(1);
if ( ((LA138_0>=HamThumb && LA138_0<=HamPinky)) ) {
alt138=1;
}
switch (alt138) {
case 1 :
// Ham4Parser.g:3210:11: digit
this.pushFollow(Ham4Parser.FOLLOW_digit_in_specialfingerplaymovement12454);
digit356=this.digit();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_digit.add(digit356.getTree());
break;
default :
if ( cnt138 >= 1 ) {
break loop138;
}
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var eee = new org.antlr.runtime.EarlyExitException(138, this.input);
throw eee;
}
cnt138++;
} while (true);
HamFingerplay357=this.match(this.input,HamFingerplay,Ham4Parser.FOLLOW_HamFingerplay_in_specialfingerplaymovement12467); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamFingerplay.add(HamFingerplay357);
HamSeqend358=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_specialfingerplaymovement12477); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamSeqend.add(HamSeqend358);
// AST REWRITE
// elements: digit, HamFingerplay
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3213:5: -> ^( SIMPLEMVMT ( digit )* HamFingerplay )
{
// Ham4Parser.g:3213:8: ^( SIMPLEMVMT ( digit )* HamFingerplay )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SIMPLEMVMT, "SIMPLEMVMT"), root_1);
// Ham4Parser.g:3213:21: ( digit )*
while ( stream_digit.hasNext() ) {
this.adaptor.addChild(root_1, stream_digit.nextTree());
}
stream_digit.reset();
this.adaptor.addChild(root_1, stream_HamFingerplay.nextNode());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: specialfingerplaymovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
straightmovement_return: (function() {
Ham4Parser.straightmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.straightmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3216:1: straightmovement : movementarrow ( HamBetween movementarrow )? -> ^( STRGHTMVMT ( movementarrow )* ) ;
// $ANTLR start "straightmovement"
straightmovement: function() {
var retval = new Ham4Parser.straightmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween360 = null;
var movementarrow359 = null;
var movementarrow361 = null;
var HamBetween360_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_movementarrow=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementarrow");
this.trace("ANTLR Parse: straightmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3235:5: ( movementarrow ( HamBetween movementarrow )? -> ^( STRGHTMVMT ( movementarrow )* ) )
// Ham4Parser.g:3235:9: movementarrow ( HamBetween movementarrow )?
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_straightmovement12522);
movementarrow359=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow359.getTree());
// Ham4Parser.g:3236:9: ( HamBetween movementarrow )?
var alt139=2;
var LA139_0 = this.input.LA(1);
if ( (LA139_0==HamBetween) ) {
alt139=1;
}
switch (alt139) {
case 1 :
// Ham4Parser.g:3237:13: HamBetween movementarrow
HamBetween360=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_straightmovement12546); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween360);
this.pushFollow(Ham4Parser.FOLLOW_movementarrow_in_straightmovement12561);
movementarrow361=this.movementarrow();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementarrow.add(movementarrow361.getTree());
break;
}
// AST REWRITE
// elements: movementarrow
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3240:5: -> ^( STRGHTMVMT ( movementarrow )* )
{
// Ham4Parser.g:3240:8: ^( STRGHTMVMT ( movementarrow )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(STRGHTMVMT, "STRGHTMVMT"), root_1);
// Ham4Parser.g:3240:21: ( movementarrow )*
while ( stream_movementarrow.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementarrow.nextTree());
}
stream_movementarrow.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: straightmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
circularmovement_return: (function() {
Ham4Parser.circularmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.circularmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3243:1: circularmovement : movementcircle ( HamBetween movementcircle )? -> ^( CRCLRMVMT ( movementcircle )* ) ;
// $ANTLR start "circularmovement"
circularmovement: function() {
var retval = new Ham4Parser.circularmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamBetween363 = null;
var movementcircle362 = null;
var movementcircle364 = null;
var HamBetween363_tree=null;
var stream_HamBetween=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamBetween");
var stream_movementcircle=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule movementcircle");
this.trace("ANTLR Parse: circularmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3262:5: ( movementcircle ( HamBetween movementcircle )? -> ^( CRCLRMVMT ( movementcircle )* ) )
// Ham4Parser.g:3262:9: movementcircle ( HamBetween movementcircle )?
this.pushFollow(Ham4Parser.FOLLOW_movementcircle_in_circularmovement12614);
movementcircle362=this.movementcircle();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcircle.add(movementcircle362.getTree());
// Ham4Parser.g:3263:9: ( HamBetween movementcircle )?
var alt140=2;
var LA140_0 = this.input.LA(1);
if ( (LA140_0==HamBetween) ) {
alt140=1;
}
switch (alt140) {
case 1 :
// Ham4Parser.g:3264:13: HamBetween movementcircle
HamBetween363=this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_circularmovement12638); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamBetween.add(HamBetween363);
this.pushFollow(Ham4Parser.FOLLOW_movementcircle_in_circularmovement12653);
movementcircle364=this.movementcircle();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_movementcircle.add(movementcircle364.getTree());
break;
}
// AST REWRITE
// elements: movementcircle
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3267:5: -> ^( CRCLRMVMT ( movementcircle )* )
{
// Ham4Parser.g:3267:8: ^( CRCLRMVMT ( movementcircle )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(CRCLRMVMT, "CRCLRMVMT"), root_1);
// Ham4Parser.g:3267:20: ( movementcircle )*
while ( stream_movementcircle.hasNext() ) {
this.adaptor.addChild(root_1, stream_movementcircle.nextTree());
}
stream_movementcircle.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: circularmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
arckind_return: (function() {
Ham4Parser.arckind_return = function(){};
org.antlr.lang.extend(Ham4Parser.arckind_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3270:1: arckind : arc ( arc )? ( size )? ;
// $ANTLR start "arckind"
arckind: function() {
var retval = new Ham4Parser.arckind_return();
retval.start = this.input.LT(1);
var root_0 = null;
var arc365 = null;
var arc366 = null;
var size367 = null;
this.trace("ANTLR Parse: arckind starts "+this.state.backtracking);
try {
// Ham4Parser.g:3286:5: ( arc ( arc )? ( size )? )
// Ham4Parser.g:3286:9: arc ( arc )? ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_arc_in_arckind12706);
arc365=this.arc();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arc365.getTree());
// Ham4Parser.g:3287:9: ( arc )?
var alt141=2;
var LA141_0 = this.input.LA(1);
if ( ((LA141_0>=HamArcl && LA141_0<=HamArcd)) ) {
alt141=1;
}
switch (alt141) {
case 1 :
// Ham4Parser.g:3287:11: arc
this.pushFollow(Ham4Parser.FOLLOW_arc_in_arckind12718);
arc366=this.arc();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, arc366.getTree());
break;
}
// Ham4Parser.g:3288:9: ( size )?
var alt142=2;
var LA142_0 = this.input.LA(1);
if ( ((LA142_0>=HamSmallmod && LA142_0<=HamLargemod)) ) {
alt142=1;
}
switch (alt142) {
case 1 :
// Ham4Parser.g:3288:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_arckind12733);
size367=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size367.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: arckind finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
zigzag_return: (function() {
Ham4Parser.zigzag_return = function(){};
org.antlr.lang.extend(Ham4Parser.zigzag_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3291:1: zigzag : ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )? ;
// $ANTLR start "zigzag"
zigzag: function() {
var retval = new Ham4Parser.zigzag_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set368 = null;
var size369 = null;
var ellipsedirection370 = null;
var sizechangenonlinear371 = null;
var set368_tree=null;
this.trace("ANTLR Parse: zigzag starts "+this.state.backtracking);
try {
// Ham4Parser.g:3312:5: ( ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )? )
// Ham4Parser.g:3312:9: ( HamZigzag | HamWavy ) ( size )? ( ellipsedirection )? ( sizechangenonlinear )?
root_0 = this.adaptor.nil();
set368=this.input.LT(1);
if ( (this.input.LA(1)>=HamWavy && this.input.LA(1)<=HamZigzag) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set368));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:3317:9: ( size )?
var alt143=2;
var LA143_0 = this.input.LA(1);
if ( ((LA143_0>=HamSmallmod && LA143_0<=HamLargemod)) ) {
alt143=1;
}
switch (alt143) {
case 1 :
// Ham4Parser.g:3317:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_zigzag12825);
size369=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size369.getTree());
break;
}
// Ham4Parser.g:3318:9: ( ellipsedirection )?
var alt144=2;
var LA144_0 = this.input.LA(1);
if ( ((LA144_0>=HamEllipseh && LA144_0<=HamEllipseul)) ) {
alt144=1;
}
switch (alt144) {
case 1 :
// Ham4Parser.g:3318:11: ellipsedirection
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_zigzag12840);
ellipsedirection370=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ellipsedirection370.getTree());
break;
}
// Ham4Parser.g:3319:9: ( sizechangenonlinear )?
var alt145=2;
var LA145_0 = this.input.LA(1);
if ( ((LA145_0>=HamIncreasing && LA145_0<=HamDecreasing)) ) {
alt145=1;
}
switch (alt145) {
case 1 :
// Ham4Parser.g:3319:11: sizechangenonlinear
this.pushFollow(Ham4Parser.FOLLOW_sizechangenonlinear_in_zigzag12855);
sizechangenonlinear371=this.sizechangenonlinear();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sizechangenonlinear371.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: zigzag finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sizechangenonlinear_return: (function() {
Ham4Parser.sizechangenonlinear_return = function(){};
org.antlr.lang.extend(Ham4Parser.sizechangenonlinear_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3322:1: sizechangenonlinear : sizechange ( size )? ;
// $ANTLR start "sizechangenonlinear"
sizechangenonlinear: function() {
var retval = new Ham4Parser.sizechangenonlinear_return();
retval.start = this.input.LT(1);
var root_0 = null;
var sizechange372 = null;
var size373 = null;
this.trace("ANTLR Parse: sizechangenonlinear starts "+this.state.backtracking);
try {
// Ham4Parser.g:3337:5: ( sizechange ( size )? )
// Ham4Parser.g:3337:9: sizechange ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_sizechange_in_sizechangenonlinear12887);
sizechange372=this.sizechange();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, sizechange372.getTree());
// Ham4Parser.g:3338:9: ( size )?
var alt146=2;
var LA146_0 = this.input.LA(1);
if ( ((LA146_0>=HamSmallmod && LA146_0<=HamLargemod)) ) {
alt146=1;
}
switch (alt146) {
case 1 :
// Ham4Parser.g:3338:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_sizechangenonlinear12899);
size373=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size373.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sizechangenonlinear finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ellipse_return: (function() {
Ham4Parser.ellipse_return = function(){};
org.antlr.lang.extend(Ham4Parser.ellipse_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3341:1: ellipse : ellipsedirection ( size )? ;
// $ANTLR start "ellipse"
ellipse: function() {
var retval = new Ham4Parser.ellipse_return();
retval.start = this.input.LT(1);
var root_0 = null;
var ellipsedirection374 = null;
var size375 = null;
this.trace("ANTLR Parse: ellipse starts "+this.state.backtracking);
try {
// Ham4Parser.g:3356:5: ( ellipsedirection ( size )? )
// Ham4Parser.g:3356:9: ellipsedirection ( size )?
root_0 = this.adaptor.nil();
this.pushFollow(Ham4Parser.FOLLOW_ellipsedirection_in_ellipse12931);
ellipsedirection374=this.ellipsedirection();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, ellipsedirection374.getTree());
// Ham4Parser.g:3357:9: ( size )?
var alt147=2;
var LA147_0 = this.input.LA(1);
if ( ((LA147_0>=HamSmallmod && LA147_0<=HamLargemod)) ) {
alt147=1;
}
switch (alt147) {
case 1 :
// Ham4Parser.g:3357:11: size
this.pushFollow(Ham4Parser.FOLLOW_size_in_ellipse12943);
size375=this.size();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, size375.getTree());
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ellipse finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
revolutions_return: (function() {
Ham4Parser.revolutions_return = function(){};
org.antlr.lang.extend(Ham4Parser.revolutions_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3360:1: revolutions : ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? ) ;
// $ANTLR start "revolutions"
revolutions: function() {
var retval = new Ham4Parser.revolutions_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamClockfull377 = null;
var HamClockfull378 = null;
var HamClockfull380 = null;
var HamClockfull381 = null;
var clock376 = null;
var clock379 = null;
var clock382 = null;
var HamClockfull377_tree=null;
var HamClockfull378_tree=null;
var HamClockfull380_tree=null;
var HamClockfull381_tree=null;
this.trace("ANTLR Parse: revolutions starts "+this.state.backtracking);
try {
// Ham4Parser.g:3386:5: ( ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? ) )
// Ham4Parser.g:3387:5: ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3387:5: ( clock ( HamClockfull ( HamClockfull )? )? ( clock )? | HamClockfull ( HamClockfull )? ( clock )? )
var alt153=2;
var LA153_0 = this.input.LA(1);
if ( ((LA153_0>=HamClocku && LA153_0<=HamClockur)) ) {
alt153=1;
}
else if ( (LA153_0==HamClockfull) ) {
alt153=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 153, 0, this.input);
throw nvae;
}
switch (alt153) {
case 1 :
// Ham4Parser.g:3388:9: clock ( HamClockfull ( HamClockfull )? )? ( clock )?
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions12987);
clock376=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock376.getTree());
// Ham4Parser.g:3389:9: ( HamClockfull ( HamClockfull )? )?
var alt149=2;
var LA149_0 = this.input.LA(1);
if ( (LA149_0==HamClockfull) ) {
alt149=1;
}
switch (alt149) {
case 1 :
// Ham4Parser.g:3390:13: HamClockfull ( HamClockfull )?
HamClockfull377=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13011); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull377_tree = this.adaptor.create(HamClockfull377);
this.adaptor.addChild(root_0, HamClockfull377_tree);
}
// Ham4Parser.g:3391:13: ( HamClockfull )?
var alt148=2;
var LA148_0 = this.input.LA(1);
if ( (LA148_0==HamClockfull) ) {
alt148=1;
}
switch (alt148) {
case 1 :
// Ham4Parser.g:3391:15: HamClockfull
HamClockfull378=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13027); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull378_tree = this.adaptor.create(HamClockfull378);
this.adaptor.addChild(root_0, HamClockfull378_tree);
}
break;
}
break;
}
// Ham4Parser.g:3393:9: ( clock )?
var alt150=2;
var LA150_0 = this.input.LA(1);
if ( ((LA150_0>=HamClocku && LA150_0<=HamClockur)) ) {
alt150=1;
}
switch (alt150) {
case 1 :
// Ham4Parser.g:3393:11: clock
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions13053);
clock379=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock379.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3395:9: HamClockfull ( HamClockfull )? ( clock )?
HamClockfull380=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13072); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull380_tree = this.adaptor.create(HamClockfull380);
this.adaptor.addChild(root_0, HamClockfull380_tree);
}
// Ham4Parser.g:3396:9: ( HamClockfull )?
var alt151=2;
var LA151_0 = this.input.LA(1);
if ( (LA151_0==HamClockfull) ) {
alt151=1;
}
switch (alt151) {
case 1 :
// Ham4Parser.g:3396:11: HamClockfull
HamClockfull381=this.match(this.input,HamClockfull,Ham4Parser.FOLLOW_HamClockfull_in_revolutions13084); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamClockfull381_tree = this.adaptor.create(HamClockfull381);
this.adaptor.addChild(root_0, HamClockfull381_tree);
}
break;
}
// Ham4Parser.g:3397:9: ( clock )?
var alt152=2;
var LA152_0 = this.input.LA(1);
if ( ((LA152_0>=HamClocku && LA152_0<=HamClockur)) ) {
alt152=1;
}
switch (alt152) {
case 1 :
// Ham4Parser.g:3397:11: clock
this.pushFollow(Ham4Parser.FOLLOW_clock_in_revolutions13099);
clock382=this.clock();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, clock382.getTree());
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: revolutions finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
replacement_return: (function() {
Ham4Parser.replacement_return = function(){};
org.antlr.lang.extend(Ham4Parser.replacement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3401:1: replacement : HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) ) ;
// $ANTLR start "replacement"
replacement: function() {
var retval = new Ham4Parser.replacement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamReplace383 = null;
var sizechange384 = null;
var handshape1385 = null;
var splitreplacetail386 = null;
var extfidir1387 = null;
var palmor1388 = null;
var splitreplacetail389 = null;
var extfidir1390 = null;
var palmor1391 = null;
var palmor1392 = null;
var HamReplace383_tree=null;
var stream_HamReplace=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamReplace");
var stream_handshape1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshape1");
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_sizechange=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule sizechange");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
var stream_splitreplacetail=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule splitreplacetail");
this.trace("ANTLR Parse: replacement starts "+this.state.backtracking);
try {
// Ham4Parser.g:3438:5: ( HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) ) )
// Ham4Parser.g:3438:9: HamReplace ( sizechange )? ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) )
HamReplace383=this.match(this.input,HamReplace,Ham4Parser.FOLLOW_HamReplace_in_replacement13137); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamReplace.add(HamReplace383);
// Ham4Parser.g:3439:9: ( sizechange )?
var alt154=2;
var LA154_0 = this.input.LA(1);
if ( ((LA154_0>=HamIncreasing && LA154_0<=HamDecreasing)) ) {
alt154=1;
}
switch (alt154) {
case 1 :
// Ham4Parser.g:3439:11: sizechange
this.pushFollow(Ham4Parser.FOLLOW_sizechange_in_replacement13150);
sizechange384=this.sizechange();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_sizechange.add(sizechange384.getTree());
break;
}
// Ham4Parser.g:3440:9: ( handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? ) -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* ) | splitreplacetail -> ^( REPLACE ( sizechange )* splitreplacetail ) | extfidir1 ( palmor1 )? -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* ) | palmor1 -> ^( REPLACE ( sizechange )* palmor1 ) )
var alt159=4;
switch ( this.input.LA(1) ) {
case HamFist:
case HamFlathand:
case HamFinger2:
case HamFinger23:
case HamFinger23spread:
case HamFinger2345:
case HamPinch12:
case HamPinchall:
case HamPinch12open:
case HamCee12:
case HamCeeall:
case HamCee12open:
case HamNondominant:
alt159=1;
break;
case HamParbegin:
alt159=2;
break;
case HamExtfingeru:
case HamExtfingerur:
case HamExtfingerr:
case HamExtfingerdr:
case HamExtfingerd:
case HamExtfingerdl:
case HamExtfingerl:
case HamExtfingerul:
case HamExtfingerol:
case HamExtfingero:
case HamExtfingeror:
case HamExtfingeril:
case HamExtfingeri:
case HamExtfingerir:
case HamExtfingerui:
case HamExtfingerdi:
case HamExtfingerdo:
case HamExtfingeruo:
alt159=3;
break;
case HamPalmu:
case HamPalmur:
case HamPalmr:
case HamPalmdr:
case HamPalmd:
case HamPalmdl:
case HamPalml:
case HamPalmul:
alt159=4;
break;
default:
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 159, 0, this.input);
throw nvae;
}
switch (alt159) {
case 1 :
// Ham4Parser.g:3441:13: handshape1 ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )
this.pushFollow(Ham4Parser.FOLLOW_handshape1_in_replacement13177);
handshape1385=this.handshape1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshape1.add(handshape1385.getTree());
// Ham4Parser.g:3442:13: ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )
var alt157=2;
alt157 = this.dfa157.predict(this.input);
switch (alt157) {
case 1 :
// Ham4Parser.g:3443:17: ( splitreplacetail )=> splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_replacement13249);
splitreplacetail386=this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitreplacetail.add(splitreplacetail386.getTree());
break;
case 2 :
// Ham4Parser.g:3447:17: ( extfidir1 )? ( palmor1 )?
// Ham4Parser.g:3447:17: ( extfidir1 )?
var alt155=2;
var LA155_0 = this.input.LA(1);
if ( ((LA155_0>=HamExtfingeru && LA155_0<=HamExtfingeruo)) ) {
alt155=1;
}
switch (alt155) {
case 1 :
// Ham4Parser.g:3447:19: extfidir1
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacement13283);
extfidir1387=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1387.getTree());
break;
}
// Ham4Parser.g:3448:17: ( palmor1 )?
var alt156=2;
var LA156_0 = this.input.LA(1);
if ( ((LA156_0>=HamPalmu && LA156_0<=HamPalmul)) ) {
alt156=1;
}
switch (alt156) {
case 1 :
// Ham4Parser.g:3448:19: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13306);
palmor1388=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1388.getTree());
break;
}
break;
}
// AST REWRITE
// elements: handshape1, extfidir1, sizechange, splitreplacetail, palmor1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3450:6: -> ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* )
{
// Ham4Parser.g:3450:9: ^( REPLACE ( sizechange )* handshape1 ( splitreplacetail )* ( extfidir1 )* ( palmor1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3450:19: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_handshape1.nextTree());
// Ham4Parser.g:3450:42: ( splitreplacetail )*
while ( stream_splitreplacetail.hasNext() ) {
this.adaptor.addChild(root_1, stream_splitreplacetail.nextTree());
}
stream_splitreplacetail.reset();
// Ham4Parser.g:3450:60: ( extfidir1 )*
while ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:3450:71: ( palmor1 )*
while ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 2 :
// Ham4Parser.g:3452:13: splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_replacement13372);
splitreplacetail389=this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_splitreplacetail.add(splitreplacetail389.getTree());
// AST REWRITE
// elements: splitreplacetail, sizechange
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3453:5: -> ^( REPLACE ( sizechange )* splitreplacetail )
{
// Ham4Parser.g:3453:8: ^( REPLACE ( sizechange )* splitreplacetail )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3453:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_splitreplacetail.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 3 :
// Ham4Parser.g:3455:13: extfidir1 ( palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacement13411);
extfidir1390=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1390.getTree());
// Ham4Parser.g:3456:13: ( palmor1 )?
var alt158=2;
var LA158_0 = this.input.LA(1);
if ( ((LA158_0>=HamPalmu && LA158_0<=HamPalmul)) ) {
alt158=1;
}
switch (alt158) {
case 1 :
// Ham4Parser.g:3456:15: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13427);
palmor1391=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1391.getTree());
break;
}
// AST REWRITE
// elements: extfidir1, sizechange, palmor1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3457:5: -> ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* )
{
// Ham4Parser.g:3457:8: ^( REPLACE ( sizechange )* extfidir1 ( palmor1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3457:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
// Ham4Parser.g:3457:40: ( palmor1 )*
while ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
case 4 :
// Ham4Parser.g:3459:13: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacement13472);
palmor1392=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1392.getTree());
// AST REWRITE
// elements: palmor1, sizechange
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3460:5: -> ^( REPLACE ( sizechange )* palmor1 )
{
// Ham4Parser.g:3460:8: ^( REPLACE ( sizechange )* palmor1 )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACE, "REPLACE"), root_1);
// Ham4Parser.g:3460:18: ( sizechange )*
while ( stream_sizechange.hasNext() ) {
this.adaptor.addChild(root_1, stream_sizechange.nextTree());
}
stream_sizechange.reset();
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: replacement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
splitreplacetail_return: (function() {
Ham4Parser.splitreplacetail_return = function(){};
org.antlr.lang.extend(Ham4Parser.splitreplacetail_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3464:1: splitreplacetail : HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend -> ^( SPLITREPLACETL ( replacetail1 )* ) ;
// $ANTLR start "splitreplacetail"
splitreplacetail: function() {
var retval = new Ham4Parser.splitreplacetail_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamParbegin393 = null;
var HamPlus395 = null;
var HamNomotion396 = null;
var HamParend398 = null;
var replacetail1394 = null;
var replacetail1397 = null;
var HamParbegin393_tree=null;
var HamPlus395_tree=null;
var HamNomotion396_tree=null;
var HamParend398_tree=null;
var stream_HamNomotion=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamNomotion");
var stream_HamPlus=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamPlus");
var stream_HamParend=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParend");
var stream_HamParbegin=new org.antlr.runtime.tree.RewriteRuleTokenStream(this.adaptor,"token HamParbegin");
var stream_replacetail1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule replacetail1");
this.trace("ANTLR Parse: splitreplacetail starts "+this.state.backtracking);
try {
// Ham4Parser.g:3488:5: ( HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend -> ^( SPLITREPLACETL ( replacetail1 )* ) )
// Ham4Parser.g:3488:9: HamParbegin replacetail1 HamPlus ( HamNomotion | replacetail1 ) HamParend
HamParbegin393=this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_splitreplacetail13526); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParbegin.add(HamParbegin393);
this.pushFollow(Ham4Parser.FOLLOW_replacetail1_in_splitreplacetail13537);
replacetail1394=this.replacetail1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacetail1.add(replacetail1394.getTree());
HamPlus395=this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_splitreplacetail13547); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamPlus.add(HamPlus395);
// Ham4Parser.g:3491:9: ( HamNomotion | replacetail1 )
var alt160=2;
var LA160_0 = this.input.LA(1);
if ( (LA160_0==HamNomotion) ) {
alt160=1;
}
else if ( ((LA160_0>=HamExtfingeru && LA160_0<=HamExtfingeruo)||(LA160_0>=HamPalmu && LA160_0<=HamPalmul)) ) {
alt160=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 160, 0, this.input);
throw nvae;
}
switch (alt160) {
case 1 :
// Ham4Parser.g:3492:13: HamNomotion
HamNomotion396=this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_splitreplacetail13572); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamNomotion.add(HamNomotion396);
break;
case 2 :
// Ham4Parser.g:3494:13: replacetail1
this.pushFollow(Ham4Parser.FOLLOW_replacetail1_in_splitreplacetail13597);
replacetail1397=this.replacetail1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_replacetail1.add(replacetail1397.getTree());
break;
}
HamParend398=this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_splitreplacetail13617); if (this.state.failed) return retval; 
if ( this.state.backtracking===0 ) stream_HamParend.add(HamParend398);
// AST REWRITE
// elements: replacetail1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3498:5: -> ^( SPLITREPLACETL ( replacetail1 )* )
{
// Ham4Parser.g:3498:8: ^( SPLITREPLACETL ( replacetail1 )* )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(SPLITREPLACETL, "SPLITREPLACETL"), root_1);
// Ham4Parser.g:3498:25: ( replacetail1 )*
while ( stream_replacetail1.hasNext() ) {
this.adaptor.addChild(root_1, stream_replacetail1.nextTree());
}
stream_replacetail1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: splitreplacetail finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
replacetail1_return: (function() {
Ham4Parser.replacetail1_return = function(){};
org.antlr.lang.extend(Ham4Parser.replacetail1_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3501:1: replacetail1 : ( extfidir1 ( palmor1 )? | palmor1 ) -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? ) ;
// $ANTLR start "replacetail1"
replacetail1: function() {
var retval = new Ham4Parser.replacetail1_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidir1399 = null;
var palmor1400 = null;
var palmor1401 = null;
var stream_palmor1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule palmor1");
var stream_extfidir1=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidir1");
this.trace("ANTLR Parse: replacetail1 starts "+this.state.backtracking);
try {
// Ham4Parser.g:3522:5: ( ( extfidir1 ( palmor1 )? | palmor1 ) -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? ) )
// Ham4Parser.g:3523:5: ( extfidir1 ( palmor1 )? | palmor1 )
// Ham4Parser.g:3523:5: ( extfidir1 ( palmor1 )? | palmor1 )
var alt162=2;
var LA162_0 = this.input.LA(1);
if ( ((LA162_0>=HamExtfingeru && LA162_0<=HamExtfingeruo)) ) {
alt162=1;
}
else if ( ((LA162_0>=HamPalmu && LA162_0<=HamPalmul)) ) {
alt162=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 162, 0, this.input);
throw nvae;
}
switch (alt162) {
case 1 :
// Ham4Parser.g:3524:9: extfidir1 ( palmor1 )?
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_replacetail113681);
extfidir1399=this.extfidir1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidir1.add(extfidir1399.getTree());
// Ham4Parser.g:3525:9: ( palmor1 )?
var alt161=2;
var LA161_0 = this.input.LA(1);
if ( ((LA161_0>=HamPalmu && LA161_0<=HamPalmul)) ) {
alt161=1;
}
switch (alt161) {
case 1 :
// Ham4Parser.g:3525:11: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacetail113693);
palmor1400=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1400.getTree());
break;
}
break;
case 2 :
// Ham4Parser.g:3527:9: palmor1
this.pushFollow(Ham4Parser.FOLLOW_palmor1_in_replacetail113712);
palmor1401=this.palmor1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_palmor1.add(palmor1401.getTree());
break;
}
// AST REWRITE
// elements: extfidir1, palmor1
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3529:4: -> ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? )
{
// Ham4Parser.g:3529:7: ^( REPLACETAIL1 ( extfidir1 )? ( palmor1 )? )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(REPLACETAIL1, "REPLACETAIL1"), root_1);
// Ham4Parser.g:3529:22: ( extfidir1 )?
if ( stream_extfidir1.hasNext() ) {
this.adaptor.addChild(root_1, stream_extfidir1.nextTree());
}
stream_extfidir1.reset();
// Ham4Parser.g:3529:33: ( palmor1 )?
if ( stream_palmor1.hasNext() ) {
this.adaptor.addChild(root_1, stream_palmor1.nextTree());
}
stream_palmor1.reset();
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: replacetail1 finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
brushingcontact_return: (function() {
Ham4Parser.brushingcontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.brushingcontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3532:1: brushingcontact : HamSeqbegin HamBrushing location1 HamSeqend ;
// $ANTLR start "brushingcontact"
brushingcontact: function() {
var retval = new Ham4Parser.brushingcontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamSeqbegin402 = null;
var HamBrushing403 = null;
var HamSeqend405 = null;
var location1404 = null;
var HamSeqbegin402_tree=null;
var HamBrushing403_tree=null;
var HamSeqend405_tree=null;
this.trace("ANTLR Parse: brushingcontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:3550:5: ( HamSeqbegin HamBrushing location1 HamSeqend )
// Ham4Parser.g:3551:9: HamSeqbegin HamBrushing location1 HamSeqend
root_0 = this.adaptor.nil();
HamSeqbegin402=this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_brushingcontact13768); if (this.state.failed) return retval;
HamBrushing403=this.match(this.input,HamBrushing,Ham4Parser.FOLLOW_HamBrushing_in_brushingcontact13780); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamBrushing403_tree = this.adaptor.create(HamBrushing403);
this.adaptor.addChild(root_0, HamBrushing403_tree);
}
this.pushFollow(Ham4Parser.FOLLOW_location1_in_brushingcontact13790);
location1404=this.location1();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, location1404.getTree());
HamSeqend405=this.match(this.input,HamSeqend,Ham4Parser.FOLLOW_HamSeqend_in_brushingcontact13800); if (this.state.failed) return retval;
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: brushingcontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshapeclasstok_return: (function() {
Ham4Parser.handshapeclasstok_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshapeclasstok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3560:1: handshapeclasstok : ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ;
// $ANTLR start "handshapeclasstok"
handshapeclasstok: function() {
var retval = new Ham4Parser.handshapeclasstok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set406 = null;
var set406_tree=null;
this.trace("ANTLR Parse: handshapeclasstok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3589:5: ( ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) )
// Ham4Parser.g:3590:5: ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open )
root_0 = this.adaptor.nil();
set406=this.input.LT(1);
if ( (this.input.LA(1)>=HamFist && this.input.LA(1)<=HamFinger2345)||(this.input.LA(1)>=HamPinch12 && this.input.LA(1)<=HamCee12open) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set406));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handshapeclasstok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handshapeclass_return: (function() {
Ham4Parser.handshapeclass_return = function(){};
org.antlr.lang.extend(Ham4Parser.handshapeclass_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3607:1: handshapeclass : handshapeclasstok -> ^( HSCLASS handshapeclasstok ) ;
// $ANTLR start "handshapeclass"
handshapeclass: function() {
var retval = new Ham4Parser.handshapeclass_return();
retval.start = this.input.LT(1);
var root_0 = null;
var handshapeclasstok407 = null;
var stream_handshapeclasstok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule handshapeclasstok");
try {
// Ham4Parser.g:3608:2: ( handshapeclasstok -> ^( HSCLASS handshapeclasstok ) )
// Ham4Parser.g:3608:4: handshapeclasstok
this.pushFollow(Ham4Parser.FOLLOW_handshapeclasstok_in_handshapeclass13972);
handshapeclasstok407=this.handshapeclasstok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_handshapeclasstok.add(handshapeclasstok407.getTree());
// AST REWRITE
// elements: handshapeclasstok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3609:2: -> ^( HSCLASS handshapeclasstok )
{
// Ham4Parser.g:3609:5: ^( HSCLASS handshapeclasstok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(HSCLASS, "HSCLASS"), root_1);
this.adaptor.addChild(root_1, stream_handshapeclasstok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerbendingtok_return: (function() {
Ham4Parser.fingerbendingtok_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerbendingtok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3612:1: fingerbendingtok : ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ;
// $ANTLR start "fingerbendingtok"
fingerbendingtok: function() {
var retval = new Ham4Parser.fingerbendingtok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set408 = null;
var set408_tree=null;
this.trace("ANTLR Parse: fingerbendingtok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3632:5: ( ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) )
// Ham4Parser.g:3633:5: ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked )
root_0 = this.adaptor.nil();
set408=this.input.LT(1);
if ( (this.input.LA(1)>=HamFingerstraightmod && this.input.LA(1)<=HamFingerhookedmod)||(this.input.LA(1)>=HamDoublebent && this.input.LA(1)<=HamDoublehooked) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set408));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerbendingtok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerbending_return: (function() {
Ham4Parser.fingerbending_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerbending_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3641:1: fingerbending : fingerbendingtok -> ^( FIBENDING fingerbendingtok ) ;
// $ANTLR start "fingerbending"
fingerbending: function() {
var retval = new Ham4Parser.fingerbending_return();
retval.start = this.input.LT(1);
var root_0 = null;
var fingerbendingtok409 = null;
var stream_fingerbendingtok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule fingerbendingtok");
try {
// Ham4Parser.g:3642:2: ( fingerbendingtok -> ^( FIBENDING fingerbendingtok ) )
// Ham4Parser.g:3642:4: fingerbendingtok
this.pushFollow(Ham4Parser.FOLLOW_fingerbendingtok_in_fingerbending14073);
fingerbendingtok409=this.fingerbendingtok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_fingerbendingtok.add(fingerbendingtok409.getTree());
// AST REWRITE
// elements: fingerbendingtok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3643:4: -> ^( FIBENDING fingerbendingtok )
{
// Ham4Parser.g:3643:7: ^( FIBENDING fingerbendingtok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(FIBENDING, "FIBENDING"), root_1);
this.adaptor.addChild(root_1, stream_fingerbendingtok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbpostok_return: (function() {
Ham4Parser.thumbpostok_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbpostok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3646:1: thumbpostok : ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ;
// $ANTLR start "thumbpostok"
thumbpostok: function() {
var retval = new Ham4Parser.thumbpostok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set410 = null;
var set410_tree=null;
this.trace("ANTLR Parse: thumbpostok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3664:5: ( ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) )
// Ham4Parser.g:3665:5: ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod )
root_0 = this.adaptor.nil();
set410=this.input.LT(1);
if ( (this.input.LA(1)>=HamThumboutmod && this.input.LA(1)<=HamThumbacrossmod)||this.input.LA(1)==HamThumbopenmod ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set410));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumbpostok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumbpos_return: (function() {
Ham4Parser.thumbpos_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumbpos_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3671:1: thumbpos : thumbpostok -> ^( THUMBPOS thumbpostok ) ;
// $ANTLR start "thumbpos"
thumbpos: function() {
var retval = new Ham4Parser.thumbpos_return();
retval.start = this.input.LT(1);
var root_0 = null;
var thumbpostok411 = null;
var stream_thumbpostok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule thumbpostok");
try {
// Ham4Parser.g:3672:2: ( thumbpostok -> ^( THUMBPOS thumbpostok ) )
// Ham4Parser.g:3672:4: thumbpostok
this.pushFollow(Ham4Parser.FOLLOW_thumbpostok_in_thumbpos14159);
thumbpostok411=this.thumbpostok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_thumbpostok.add(thumbpostok411.getTree());
// AST REWRITE
// elements: thumbpostok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3673:4: -> ^( THUMBPOS thumbpostok )
{
// Ham4Parser.g:3673:7: ^( THUMBPOS thumbpostok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(THUMBPOS, "THUMBPOS"), root_1);
this.adaptor.addChild(root_1, stream_thumbpostok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
thumb_return: (function() {
Ham4Parser.thumb_return = function(){};
org.antlr.lang.extend(Ham4Parser.thumb_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3676:1: thumb : HamThumb ;
// $ANTLR start "thumb"
thumb: function() {
var retval = new Ham4Parser.thumb_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamThumb412 = null;
var HamThumb412_tree=null;
this.trace("ANTLR Parse: thumb starts "+this.state.backtracking);
try {
// Ham4Parser.g:3690:5: ( HamThumb )
// Ham4Parser.g:3690:9: HamThumb
root_0 = this.adaptor.nil();
HamThumb412=this.match(this.input,HamThumb,Ham4Parser.FOLLOW_HamThumb_in_thumb14199); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamThumb412_tree = this.adaptor.create(HamThumb412);
this.adaptor.addChild(root_0, HamThumb412_tree);
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: thumb finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
finger_return: (function() {
Ham4Parser.finger_return = function(){};
org.antlr.lang.extend(Ham4Parser.finger_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3693:1: finger : ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky );
// $ANTLR start "finger"
finger: function() {
var retval = new Ham4Parser.finger_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set413 = null;
var set413_tree=null;
this.trace("ANTLR Parse: finger starts "+this.state.backtracking);
try {
// Ham4Parser.g:3710:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set413=this.input.LT(1);
if ( (this.input.LA(1)>=HamIndexfinger && this.input.LA(1)<=HamPinky) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set413));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: finger finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
fingerpart_return: (function() {
Ham4Parser.fingerpart_return = function(){};
org.antlr.lang.extend(Ham4Parser.fingerpart_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3716:1: fingerpart : ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside );
// $ANTLR start "fingerpart"
fingerpart: function() {
var retval = new Ham4Parser.fingerpart_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set414 = null;
var set414_tree=null;
this.trace("ANTLR Parse: fingerpart starts "+this.state.backtracking);
try {
// Ham4Parser.g:3735:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set414=this.input.LT(1);
if ( (this.input.LA(1)>=HamFingertip && this.input.LA(1)<=HamFingerside) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set414));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: fingerpart finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidirtok_return: (function() {
Ham4Parser.extfidirtok_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidirtok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3743:1: extfidirtok : ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) ) ;
// $ANTLR start "extfidirtok"
extfidirtok: function() {
var retval = new Ham4Parser.extfidirtok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamExtfingeru415 = null;
var HamExtfingerur416 = null;
var HamExtfingerr417 = null;
var HamExtfingerdr418 = null;
var HamExtfingerd419 = null;
var HamExtfingerdl420 = null;
var HamExtfingerl421 = null;
var HamExtfingerul422 = null;
var HamExtfingerol423 = null;
var set424 = null;
var HamExtfingero425 = null;
var HamExtfingeror426 = null;
var set427 = null;
var HamExtfingeril428 = null;
var set429 = null;
var HamExtfingeri430 = null;
var HamExtfingerir431 = null;
var set432 = null;
var HamExtfingerui433 = null;
var set434 = null;
var HamExtfingerdi435 = null;
var set436 = null;
var HamExtfingerdo437 = null;
var set438 = null;
var HamExtfingeruo439 = null;
var set440 = null;
var HamExtfingeru415_tree=null;
var HamExtfingerur416_tree=null;
var HamExtfingerr417_tree=null;
var HamExtfingerdr418_tree=null;
var HamExtfingerd419_tree=null;
var HamExtfingerdl420_tree=null;
var HamExtfingerl421_tree=null;
var HamExtfingerul422_tree=null;
var HamExtfingerol423_tree=null;
var set424_tree=null;
var HamExtfingero425_tree=null;
var HamExtfingeror426_tree=null;
var set427_tree=null;
var HamExtfingeril428_tree=null;
var set429_tree=null;
var HamExtfingeri430_tree=null;
var HamExtfingerir431_tree=null;
var set432_tree=null;
var HamExtfingerui433_tree=null;
var set434_tree=null;
var HamExtfingerdi435_tree=null;
var set436_tree=null;
var HamExtfingerdo437_tree=null;
var set438_tree=null;
var HamExtfingeruo439_tree=null;
var set440_tree=null;
this.trace("ANTLR Parse: extfidirtok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3824:5: ( ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) ) )
// Ham4Parser.g:3825:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3825:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )
var alt171=18;
alt171 = this.dfa171.predict(this.input);
switch (alt171) {
case 1 :
// Ham4Parser.g:3825:9: HamExtfingeru
HamExtfingeru415=this.match(this.input,HamExtfingeru,Ham4Parser.FOLLOW_HamExtfingeru_in_extfidirtok14372); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeru415_tree = this.adaptor.create(HamExtfingeru415);
this.adaptor.addChild(root_0, HamExtfingeru415_tree);
}
break;
case 2 :
// Ham4Parser.g:3826:9: HamExtfingerur
HamExtfingerur416=this.match(this.input,HamExtfingerur,Ham4Parser.FOLLOW_HamExtfingerur_in_extfidirtok14382); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerur416_tree = this.adaptor.create(HamExtfingerur416);
this.adaptor.addChild(root_0, HamExtfingerur416_tree);
}
break;
case 3 :
// Ham4Parser.g:3827:9: HamExtfingerr
HamExtfingerr417=this.match(this.input,HamExtfingerr,Ham4Parser.FOLLOW_HamExtfingerr_in_extfidirtok14392); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerr417_tree = this.adaptor.create(HamExtfingerr417);
this.adaptor.addChild(root_0, HamExtfingerr417_tree);
}
break;
case 4 :
// Ham4Parser.g:3828:9: HamExtfingerdr
HamExtfingerdr418=this.match(this.input,HamExtfingerdr,Ham4Parser.FOLLOW_HamExtfingerdr_in_extfidirtok14402); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdr418_tree = this.adaptor.create(HamExtfingerdr418);
this.adaptor.addChild(root_0, HamExtfingerdr418_tree);
}
break;
case 5 :
// Ham4Parser.g:3829:9: HamExtfingerd
HamExtfingerd419=this.match(this.input,HamExtfingerd,Ham4Parser.FOLLOW_HamExtfingerd_in_extfidirtok14412); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerd419_tree = this.adaptor.create(HamExtfingerd419);
this.adaptor.addChild(root_0, HamExtfingerd419_tree);
}
break;
case 6 :
// Ham4Parser.g:3830:9: HamExtfingerdl
HamExtfingerdl420=this.match(this.input,HamExtfingerdl,Ham4Parser.FOLLOW_HamExtfingerdl_in_extfidirtok14422); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdl420_tree = this.adaptor.create(HamExtfingerdl420);
this.adaptor.addChild(root_0, HamExtfingerdl420_tree);
}
break;
case 7 :
// Ham4Parser.g:3831:9: HamExtfingerl
HamExtfingerl421=this.match(this.input,HamExtfingerl,Ham4Parser.FOLLOW_HamExtfingerl_in_extfidirtok14432); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerl421_tree = this.adaptor.create(HamExtfingerl421);
this.adaptor.addChild(root_0, HamExtfingerl421_tree);
}
break;
case 8 :
// Ham4Parser.g:3832:9: HamExtfingerul
HamExtfingerul422=this.match(this.input,HamExtfingerul,Ham4Parser.FOLLOW_HamExtfingerul_in_extfidirtok14442); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerul422_tree = this.adaptor.create(HamExtfingerul422);
this.adaptor.addChild(root_0, HamExtfingerul422_tree);
}
break;
case 9 :
// Ham4Parser.g:3833:9: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3833:9: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3834:13: HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )?
HamExtfingerol423=this.match(this.input,HamExtfingerol,Ham4Parser.FOLLOW_HamExtfingerol_in_extfidirtok14466); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerol423_tree = this.adaptor.create(HamExtfingerol423);
this.adaptor.addChild(root_0, HamExtfingerol423_tree);
}
// Ham4Parser.g:3835:13: ( HamExtfingeruo | HamExtfingerdo )?
var alt163=2;
var LA163_0 = this.input.LA(1);
if ( ((LA163_0>=HamExtfingerdo && LA163_0<=HamExtfingeruo)) ) {
alt163=1;
}
switch (alt163) {
case 1 :
// Ham4Parser.g:
set424=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerdo && this.input.LA(1)<=HamExtfingeruo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set424));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 10 :
// Ham4Parser.g:3840:9: HamExtfingero
HamExtfingero425=this.match(this.input,HamExtfingero,Ham4Parser.FOLLOW_HamExtfingero_in_extfidirtok14551); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingero425_tree = this.adaptor.create(HamExtfingero425);
this.adaptor.addChild(root_0, HamExtfingero425_tree);
}
break;
case 11 :
// Ham4Parser.g:3841:9: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3841:9: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4Parser.g:3842:13: HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )?
HamExtfingeror426=this.match(this.input,HamExtfingeror,Ham4Parser.FOLLOW_HamExtfingeror_in_extfidirtok14575); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeror426_tree = this.adaptor.create(HamExtfingeror426);
this.adaptor.addChild(root_0, HamExtfingeror426_tree);
}
// Ham4Parser.g:3843:13: ( HamExtfingeruo | HamExtfingerdo )?
var alt164=2;
var LA164_0 = this.input.LA(1);
if ( ((LA164_0>=HamExtfingerdo && LA164_0<=HamExtfingeruo)) ) {
alt164=1;
}
switch (alt164) {
case 1 :
// Ham4Parser.g:
set427=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerdo && this.input.LA(1)<=HamExtfingeruo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set427));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 12 :
// Ham4Parser.g:3848:9: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3848:9: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3849:13: HamExtfingeril ( HamExtfingerui | HamExtfingerdi )?
HamExtfingeril428=this.match(this.input,HamExtfingeril,Ham4Parser.FOLLOW_HamExtfingeril_in_extfidirtok14674); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeril428_tree = this.adaptor.create(HamExtfingeril428);
this.adaptor.addChild(root_0, HamExtfingeril428_tree);
}
// Ham4Parser.g:3850:13: ( HamExtfingerui | HamExtfingerdi )?
var alt165=2;
var LA165_0 = this.input.LA(1);
if ( ((LA165_0>=HamExtfingerui && LA165_0<=HamExtfingerdi)) ) {
alt165=1;
}
switch (alt165) {
case 1 :
// Ham4Parser.g:
set429=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerui && this.input.LA(1)<=HamExtfingerdi) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set429));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 13 :
// Ham4Parser.g:3855:9: HamExtfingeri
HamExtfingeri430=this.match(this.input,HamExtfingeri,Ham4Parser.FOLLOW_HamExtfingeri_in_extfidirtok14759); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeri430_tree = this.adaptor.create(HamExtfingeri430);
this.adaptor.addChild(root_0, HamExtfingeri430_tree);
}
break;
case 14 :
// Ham4Parser.g:3856:9: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3856:9: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4Parser.g:3857:13: HamExtfingerir ( HamExtfingerui | HamExtfingerdi )?
HamExtfingerir431=this.match(this.input,HamExtfingerir,Ham4Parser.FOLLOW_HamExtfingerir_in_extfidirtok14783); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerir431_tree = this.adaptor.create(HamExtfingerir431);
this.adaptor.addChild(root_0, HamExtfingerir431_tree);
}
// Ham4Parser.g:3858:13: ( HamExtfingerui | HamExtfingerdi )?
var alt166=2;
var LA166_0 = this.input.LA(1);
if ( ((LA166_0>=HamExtfingerui && LA166_0<=HamExtfingerdi)) ) {
alt166=1;
}
switch (alt166) {
case 1 :
// Ham4Parser.g:
set432=this.input.LT(1);
if ( (this.input.LA(1)>=HamExtfingerui && this.input.LA(1)<=HamExtfingerdi) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set432));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 15 :
// Ham4Parser.g:3863:9: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3863:9: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3864:13: HamExtfingerui ( HamExtfingeril | HamExtfingerir )?
HamExtfingerui433=this.match(this.input,HamExtfingerui,Ham4Parser.FOLLOW_HamExtfingerui_in_extfidirtok14882); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerui433_tree = this.adaptor.create(HamExtfingerui433);
this.adaptor.addChild(root_0, HamExtfingerui433_tree);
}
// Ham4Parser.g:3865:13: ( HamExtfingeril | HamExtfingerir )?
var alt167=2;
var LA167_0 = this.input.LA(1);
if ( (LA167_0==HamExtfingeril||LA167_0==HamExtfingerir) ) {
alt167=1;
}
switch (alt167) {
case 1 :
// Ham4Parser.g:
set434=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingeril||this.input.LA(1)==HamExtfingerir ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set434));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 16 :
// Ham4Parser.g:3870:9: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3870:9: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4Parser.g:3871:13: HamExtfingerdi ( HamExtfingeril | HamExtfingerir )?
HamExtfingerdi435=this.match(this.input,HamExtfingerdi,Ham4Parser.FOLLOW_HamExtfingerdi_in_extfidirtok14981); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdi435_tree = this.adaptor.create(HamExtfingerdi435);
this.adaptor.addChild(root_0, HamExtfingerdi435_tree);
}
// Ham4Parser.g:3872:13: ( HamExtfingeril | HamExtfingerir )?
var alt168=2;
var LA168_0 = this.input.LA(1);
if ( (LA168_0==HamExtfingeril||LA168_0==HamExtfingerir) ) {
alt168=1;
}
switch (alt168) {
case 1 :
// Ham4Parser.g:
set436=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingeril||this.input.LA(1)==HamExtfingerir ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set436));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 17 :
// Ham4Parser.g:3877:9: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3877:9: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3878:13: HamExtfingerdo ( HamExtfingerol | HamExtfingeror )?
HamExtfingerdo437=this.match(this.input,HamExtfingerdo,Ham4Parser.FOLLOW_HamExtfingerdo_in_extfidirtok15080); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingerdo437_tree = this.adaptor.create(HamExtfingerdo437);
this.adaptor.addChild(root_0, HamExtfingerdo437_tree);
}
// Ham4Parser.g:3879:13: ( HamExtfingerol | HamExtfingeror )?
var alt169=2;
var LA169_0 = this.input.LA(1);
if ( (LA169_0==HamExtfingerol||LA169_0==HamExtfingeror) ) {
alt169=1;
}
switch (alt169) {
case 1 :
// Ham4Parser.g:
set438=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingerol||this.input.LA(1)==HamExtfingeror ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set438));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 18 :
// Ham4Parser.g:3884:9: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3884:9: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4Parser.g:3885:13: HamExtfingeruo ( HamExtfingerol | HamExtfingeror )?
HamExtfingeruo439=this.match(this.input,HamExtfingeruo,Ham4Parser.FOLLOW_HamExtfingeruo_in_extfidirtok15179); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamExtfingeruo439_tree = this.adaptor.create(HamExtfingeruo439);
this.adaptor.addChild(root_0, HamExtfingeruo439_tree);
}
// Ham4Parser.g:3886:13: ( HamExtfingerol | HamExtfingeror )?
var alt170=2;
var LA170_0 = this.input.LA(1);
if ( (LA170_0==HamExtfingerol||LA170_0==HamExtfingeror) ) {
alt170=1;
}
switch (alt170) {
case 1 :
// Ham4Parser.g:
set440=this.input.LT(1);
if ( this.input.LA(1)==HamExtfingerol||this.input.LA(1)==HamExtfingeror ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set440));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: extfidirtok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
extfidir_return: (function() {
Ham4Parser.extfidir_return = function(){};
org.antlr.lang.extend(Ham4Parser.extfidir_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3894:1: extfidir : extfidirtok -> ^( EXTFIDIR extfidirtok ) ;
// $ANTLR start "extfidir"
extfidir: function() {
var retval = new Ham4Parser.extfidir_return();
retval.start = this.input.LT(1);
var root_0 = null;
var extfidirtok441 = null;
var stream_extfidirtok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule extfidirtok");
try {
// Ham4Parser.g:3895:2: ( extfidirtok -> ^( EXTFIDIR extfidirtok ) )
// Ham4Parser.g:3895:4: extfidirtok
this.pushFollow(Ham4Parser.FOLLOW_extfidirtok_in_extfidir15274);
extfidirtok441=this.extfidirtok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_extfidirtok.add(extfidirtok441.getTree());
// AST REWRITE
// elements: extfidirtok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 3896:2: -> ^( EXTFIDIR extfidirtok )
{
// Ham4Parser.g:3896:5: ^( EXTFIDIR extfidirtok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(EXTFIDIR, "EXTFIDIR"), root_1);
this.adaptor.addChild(root_1, stream_extfidirtok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
palmor_return: (function() {
Ham4Parser.palmor_return = function(){};
org.antlr.lang.extend(Ham4Parser.palmor_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3899:1: palmor : ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul );
// $ANTLR start "palmor"
palmor: function() {
var retval = new Ham4Parser.palmor_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set442 = null;
var set442_tree=null;
this.trace("ANTLR Parse: palmor starts "+this.state.backtracking);
try {
// Ham4Parser.g:3920:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set442=this.input.LT(1);
if ( (this.input.LA(1)>=HamPalmu && this.input.LA(1)<=HamPalmul) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set442));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: palmor finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locarm_return: (function() {
Ham4Parser.locarm_return = function(){};
org.antlr.lang.extend(Ham4Parser.locarm_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3933:1: locarm : ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm );
// $ANTLR start "locarm"
locarm: function() {
var retval = new Ham4Parser.locarm_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set443 = null;
var set443_tree=null;
this.trace("ANTLR Parse: locarm starts "+this.state.backtracking);
try {
// Ham4Parser.g:3950:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set443=this.input.LT(1);
if ( (this.input.LA(1)>=HamUpperarm && this.input.LA(1)<=HamLowerarm) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set443));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locarm finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locbodytok_return: (function() {
Ham4Parser.locbodytok_return = function(){};
org.antlr.lang.extend(Ham4Parser.locbodytok_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:3956:1: locbodytok : ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ;
// $ANTLR start "locbodytok"
locbodytok: function() {
var retval = new Ham4Parser.locbodytok_return();
retval.start = this.input.LT(1);
var root_0 = null;
var HamHead444 = null;
var HamHeadtop445 = null;
var HamForehead446 = null;
var HamEyebrows447 = null;
var HamNose448 = null;
var HamNostrils449 = null;
var HamTongue450 = null;
var set451 = null;
var set452 = null;
var HamChin453 = null;
var HamUnderchin454 = null;
var HamNeck455 = null;
var HamShouldertop456 = null;
var HamShoulders457 = null;
var HamChest458 = null;
var HamStomach459 = null;
var HamBelowstomach460 = null;
var HamHead444_tree=null;
var HamHeadtop445_tree=null;
var HamForehead446_tree=null;
var HamEyebrows447_tree=null;
var HamNose448_tree=null;
var HamNostrils449_tree=null;
var HamTongue450_tree=null;
var set451_tree=null;
var set452_tree=null;
var HamChin453_tree=null;
var HamUnderchin454_tree=null;
var HamNeck455_tree=null;
var HamShouldertop456_tree=null;
var HamShoulders457_tree=null;
var HamChest458_tree=null;
var HamStomach459_tree=null;
var HamBelowstomach460_tree=null;
this.trace("ANTLR Parse: locbodytok starts "+this.state.backtracking);
try {
// Ham4Parser.g:3997:5: ( ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) )
// Ham4Parser.g:3998:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
root_0 = this.adaptor.nil();
// Ham4Parser.g:3998:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
var alt173=16;
alt173 = this.dfa173.predict(this.input);
switch (alt173) {
case 1 :
// Ham4Parser.g:3998:9: HamHead
HamHead444=this.match(this.input,HamHead,Ham4Parser.FOLLOW_HamHead_in_locbodytok15476); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamHead444_tree = this.adaptor.create(HamHead444);
this.adaptor.addChild(root_0, HamHead444_tree);
}
break;
case 2 :
// Ham4Parser.g:3999:9: HamHeadtop
HamHeadtop445=this.match(this.input,HamHeadtop,Ham4Parser.FOLLOW_HamHeadtop_in_locbodytok15486); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamHeadtop445_tree = this.adaptor.create(HamHeadtop445);
this.adaptor.addChild(root_0, HamHeadtop445_tree);
}
break;
case 3 :
// Ham4Parser.g:4000:9: HamForehead
HamForehead446=this.match(this.input,HamForehead,Ham4Parser.FOLLOW_HamForehead_in_locbodytok15496); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamForehead446_tree = this.adaptor.create(HamForehead446);
this.adaptor.addChild(root_0, HamForehead446_tree);
}
break;
case 4 :
// Ham4Parser.g:4001:9: HamEyebrows
HamEyebrows447=this.match(this.input,HamEyebrows,Ham4Parser.FOLLOW_HamEyebrows_in_locbodytok15506); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamEyebrows447_tree = this.adaptor.create(HamEyebrows447);
this.adaptor.addChild(root_0, HamEyebrows447_tree);
}
break;
case 5 :
// Ham4Parser.g:4002:9: HamNose
HamNose448=this.match(this.input,HamNose,Ham4Parser.FOLLOW_HamNose_in_locbodytok15516); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNose448_tree = this.adaptor.create(HamNose448);
this.adaptor.addChild(root_0, HamNose448_tree);
}
break;
case 6 :
// Ham4Parser.g:4003:9: HamNostrils
HamNostrils449=this.match(this.input,HamNostrils,Ham4Parser.FOLLOW_HamNostrils_in_locbodytok15526); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNostrils449_tree = this.adaptor.create(HamNostrils449);
this.adaptor.addChild(root_0, HamNostrils449_tree);
}
break;
case 7 :
// Ham4Parser.g:4004:9: HamTongue
HamTongue450=this.match(this.input,HamTongue,Ham4Parser.FOLLOW_HamTongue_in_locbodytok15536); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamTongue450_tree = this.adaptor.create(HamTongue450);
this.adaptor.addChild(root_0, HamTongue450_tree);
}
break;
case 8 :
// Ham4Parser.g:4005:9: ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? )
// Ham4Parser.g:4005:9: ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? )
// Ham4Parser.g:4006:13: ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )?
set451=this.input.LT(1);
if ( this.input.LA(1)==HamTeeth||this.input.LA(1)==HamEyes||this.input.LA(1)==HamLips ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set451));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
// Ham4Parser.g:4011:13: ( HamDoublebent | HamDoublehooked )?
var alt172=2;
var LA172_0 = this.input.LA(1);
if ( ((LA172_0>=HamDoublebent && LA172_0<=HamDoublehooked)) ) {
alt172=1;
}
switch (alt172) {
case 1 :
// Ham4Parser.g:
set452=this.input.LT(1);
if ( (this.input.LA(1)>=HamDoublebent && this.input.LA(1)<=HamDoublehooked) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set452));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
break;
}
break;
case 9 :
// Ham4Parser.g:4016:9: HamChin
HamChin453=this.match(this.input,HamChin,Ham4Parser.FOLLOW_HamChin_in_locbodytok15713); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamChin453_tree = this.adaptor.create(HamChin453);
this.adaptor.addChild(root_0, HamChin453_tree);
}
break;
case 10 :
// Ham4Parser.g:4017:9: HamUnderchin
HamUnderchin454=this.match(this.input,HamUnderchin,Ham4Parser.FOLLOW_HamUnderchin_in_locbodytok15723); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamUnderchin454_tree = this.adaptor.create(HamUnderchin454);
this.adaptor.addChild(root_0, HamUnderchin454_tree);
}
break;
case 11 :
// Ham4Parser.g:4018:9: HamNeck
HamNeck455=this.match(this.input,HamNeck,Ham4Parser.FOLLOW_HamNeck_in_locbodytok15733); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamNeck455_tree = this.adaptor.create(HamNeck455);
this.adaptor.addChild(root_0, HamNeck455_tree);
}
break;
case 12 :
// Ham4Parser.g:4019:9: HamShouldertop
HamShouldertop456=this.match(this.input,HamShouldertop,Ham4Parser.FOLLOW_HamShouldertop_in_locbodytok15743); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamShouldertop456_tree = this.adaptor.create(HamShouldertop456);
this.adaptor.addChild(root_0, HamShouldertop456_tree);
}
break;
case 13 :
// Ham4Parser.g:4020:9: HamShoulders
HamShoulders457=this.match(this.input,HamShoulders,Ham4Parser.FOLLOW_HamShoulders_in_locbodytok15753); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamShoulders457_tree = this.adaptor.create(HamShoulders457);
this.adaptor.addChild(root_0, HamShoulders457_tree);
}
break;
case 14 :
// Ham4Parser.g:4021:9: HamChest
HamChest458=this.match(this.input,HamChest,Ham4Parser.FOLLOW_HamChest_in_locbodytok15763); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamChest458_tree = this.adaptor.create(HamChest458);
this.adaptor.addChild(root_0, HamChest458_tree);
}
break;
case 15 :
// Ham4Parser.g:4022:9: HamStomach
HamStomach459=this.match(this.input,HamStomach,Ham4Parser.FOLLOW_HamStomach_in_locbodytok15773); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamStomach459_tree = this.adaptor.create(HamStomach459);
this.adaptor.addChild(root_0, HamStomach459_tree);
}
break;
case 16 :
// Ham4Parser.g:4023:9: HamBelowstomach
HamBelowstomach460=this.match(this.input,HamBelowstomach,Ham4Parser.FOLLOW_HamBelowstomach_in_locbodytok15783); if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) {
HamBelowstomach460_tree = this.adaptor.create(HamBelowstomach460);
this.adaptor.addChild(root_0, HamBelowstomach460_tree);
}
break;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locbodytok finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locbody_return: (function() {
Ham4Parser.locbody_return = function(){};
org.antlr.lang.extend(Ham4Parser.locbody_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4027:1: locbody : locbodytok -> ^( LOCBODY locbodytok ) ;
// $ANTLR start "locbody"
locbody: function() {
var retval = new Ham4Parser.locbody_return();
retval.start = this.input.LT(1);
var root_0 = null;
var locbodytok461 = null;
var stream_locbodytok=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"rule locbodytok");
try {
// Ham4Parser.g:4028:2: ( locbodytok -> ^( LOCBODY locbodytok ) )
// Ham4Parser.g:4028:4: locbodytok
this.pushFollow(Ham4Parser.FOLLOW_locbodytok_in_locbody15803);
locbodytok461=this.locbodytok();
this.state._fsp--;
if (this.state.failed) return retval;
if ( this.state.backtracking===0 ) stream_locbodytok.add(locbodytok461.getTree());
// AST REWRITE
// elements: locbodytok
// token labels: 
// rule labels: retval
// token list labels: 
// rule list labels: 
if ( this.state.backtracking===0 ) {
retval.tree = root_0;
var stream_retval=new org.antlr.runtime.tree.RewriteRuleSubtreeStream(this.adaptor,"token retval",retval!=null?retval.tree:null);
root_0 = this.adaptor.nil();
// 4029:4: -> ^( LOCBODY locbodytok )
{
// Ham4Parser.g:4029:7: ^( LOCBODY locbodytok )
{
var root_1 = this.adaptor.nil();
root_1 = this.adaptor.becomeRoot(this.adaptor.create(LOCBODY, "LOCBODY"), root_1);
this.adaptor.addChild(root_1, stream_locbodytok.nextTree());
this.adaptor.addChild(root_0, root_1);
}
}
retval.tree = root_0;}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
locsided_return: (function() {
Ham4Parser.locsided_return = function(){};
org.antlr.lang.extend(Ham4Parser.locsided_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4032:1: locsided : ( HamEar | HamEarlobe | HamCheek );
// $ANTLR start "locsided"
locsided: function() {
var retval = new Ham4Parser.locsided_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set462 = null;
var set462_tree=null;
this.trace("ANTLR Parse: locsided starts "+this.state.backtracking);
try {
// Ham4Parser.g:4048:5: ( HamEar | HamEarlobe | HamCheek )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set462=this.input.LT(1);
if ( this.input.LA(1)==HamEarlobe||(this.input.LA(1)>=HamEar && this.input.LA(1)<=HamCheek) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set462));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: locsided finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
handpart_return: (function() {
Ham4Parser.handpart_return = function(){};
org.antlr.lang.extend(Ham4Parser.handpart_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4053:1: handpart : ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside );
// $ANTLR start "handpart"
handpart: function() {
var retval = new Ham4Parser.handpart_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set463 = null;
var set463_tree=null;
this.trace("ANTLR Parse: handpart starts "+this.state.backtracking);
try {
// Ham4Parser.g:4073:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set463=this.input.LT(1);
if ( (this.input.LA(1)>=HamWristback && this.input.LA(1)<=HamHandback)||(this.input.LA(1)>=HamThumbside && this.input.LA(1)<=HamPinkyside) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set463));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: handpart finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
side_return: (function() {
Ham4Parser.side_return = function(){};
org.antlr.lang.extend(Ham4Parser.side_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4082:1: side : ( HamLrbeside | HamLrat );
// $ANTLR start "side"
side: function() {
var retval = new Ham4Parser.side_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set464 = null;
var set464_tree=null;
this.trace("ANTLR Parse: side starts "+this.state.backtracking);
try {
// Ham4Parser.g:4097:5: ( HamLrbeside | HamLrat )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set464=this.input.LT(1);
if ( (this.input.LA(1)>=HamLrbeside && this.input.LA(1)<=HamLrat) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set464));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: side finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
dorsalorpalmar_return: (function() {
Ham4Parser.dorsalorpalmar_return = function(){};
org.antlr.lang.extend(Ham4Parser.dorsalorpalmar_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4101:1: dorsalorpalmar : ( HamHandback | HamPalm );
// $ANTLR start "dorsalorpalmar"
dorsalorpalmar: function() {
var retval = new Ham4Parser.dorsalorpalmar_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set465 = null;
var set465_tree=null;
this.trace("ANTLR Parse: dorsalorpalmar starts "+this.state.backtracking);
try {
// Ham4Parser.g:4116:5: ( HamHandback | HamPalm )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set465=this.input.LT(1);
if ( (this.input.LA(1)>=HamPalm && this.input.LA(1)<=HamHandback) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set465));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: dorsalorpalmar finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
pcontact_return: (function() {
Ham4Parser.pcontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.pcontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4120:1: pcontact : ( HamTouch | HamClose );
// $ANTLR start "pcontact"
pcontact: function() {
var retval = new Ham4Parser.pcontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set466 = null;
var set466_tree=null;
this.trace("ANTLR Parse: pcontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:4135:5: ( HamTouch | HamClose )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set466=this.input.LT(1);
if ( (this.input.LA(1)>=HamClose && this.input.LA(1)<=HamTouch) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set466));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: pcontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ccontact_return: (function() {
Ham4Parser.ccontact_return = function(){};
org.antlr.lang.extend(Ham4Parser.ccontact_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4139:1: ccontact : ( HamInterlock | HamCross );
// $ANTLR start "ccontact"
ccontact: function() {
var retval = new Ham4Parser.ccontact_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set467 = null;
var set467_tree=null;
this.trace("ANTLR Parse: ccontact starts "+this.state.backtracking);
try {
// Ham4Parser.g:4154:5: ( HamInterlock | HamCross )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set467=this.input.LT(1);
if ( (this.input.LA(1)>=HamInterlock && this.input.LA(1)<=HamCross) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set467));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ccontact finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
sizechange_return: (function() {
Ham4Parser.sizechange_return = function(){};
org.antlr.lang.extend(Ham4Parser.sizechange_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4161:1: sizechange : ( HamIncreasing | HamDecreasing );
// $ANTLR start "sizechange"
sizechange: function() {
var retval = new Ham4Parser.sizechange_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set468 = null;
var set468_tree=null;
this.trace("ANTLR Parse: sizechange starts "+this.state.backtracking);
try {
// Ham4Parser.g:4176:5: ( HamIncreasing | HamDecreasing )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set468=this.input.LT(1);
if ( (this.input.LA(1)>=HamIncreasing && this.input.LA(1)<=HamDecreasing) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set468));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: sizechange finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
repetition_return: (function() {
Ham4Parser.repetition_return = function(){};
org.antlr.lang.extend(Ham4Parser.repetition_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4180:1: repetition : ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse );
// $ANTLR start "repetition"
repetition: function() {
var retval = new Ham4Parser.repetition_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set469 = null;
var set469_tree=null;
this.trace("ANTLR Parse: repetition starts "+this.state.backtracking);
try {
// Ham4Parser.g:4198:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set469=this.input.LT(1);
if ( (this.input.LA(1)>=HamRepeatfromstart && this.input.LA(1)<=HamRepeatcontinueseveral)||this.input.LA(1)==HamRepeatreverse ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set469));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: repetition finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementarrow_return: (function() {
Ham4Parser.movementarrow_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementarrow_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4205:1: movementarrow : ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo );
// $ANTLR start "movementarrow"
movementarrow: function() {
var retval = new Ham4Parser.movementarrow_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set470 = null;
var set470_tree=null;
this.trace("ANTLR Parse: movementarrow starts "+this.state.backtracking);
try {
// Ham4Parser.g:4236:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set470=this.input.LT(1);
if ( (this.input.LA(1)>=HamMoveu && this.input.LA(1)<=HamMoveuo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set470));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementarrow finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementcross_return: (function() {
Ham4Parser.movementcross_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementcross_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4256:1: movementcross : ( HamMovecross | HamMovex );
// $ANTLR start "movementcross"
movementcross: function() {
var retval = new Ham4Parser.movementcross_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set471 = null;
var set471_tree=null;
this.trace("ANTLR Parse: movementcross starts "+this.state.backtracking);
try {
// Ham4Parser.g:4271:5: ( HamMovecross | HamMovex )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set471=this.input.LT(1);
if ( (this.input.LA(1)>=HamMovecross && this.input.LA(1)<=HamMovex) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set471));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementcross finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
wristmovement_return: (function() {
Ham4Parser.wristmovement_return = function(){};
org.antlr.lang.extend(Ham4Parser.wristmovement_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4275:1: wristmovement : ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw );
// $ANTLR start "wristmovement"
wristmovement: function() {
var retval = new Ham4Parser.wristmovement_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set472 = null;
var set472_tree=null;
this.trace("ANTLR Parse: wristmovement starts "+this.state.backtracking);
try {
// Ham4Parser.g:4293:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set472=this.input.LT(1);
if ( (this.input.LA(1)>=HamNodding && this.input.LA(1)<=HamStirccw) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set472));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: wristmovement finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
movementcircle_return: (function() {
Ham4Parser.movementcircle_return = function(){};
org.antlr.lang.extend(Ham4Parser.movementcircle_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4300:1: movementcircle : ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo );
// $ANTLR start "movementcircle"
movementcircle: function() {
var retval = new Ham4Parser.movementcircle_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set473 = null;
var set473_tree=null;
this.trace("ANTLR Parse: movementcircle starts "+this.state.backtracking);
try {
// Ham4Parser.g:4331:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set473=this.input.LT(1);
if ( (this.input.LA(1)>=HamCircleo && this.input.LA(1)<=HamCircler)||(this.input.LA(1)>=HamCircleul && this.input.LA(1)<=HamCircleuo) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set473));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: movementcircle finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
ellipsedirection_return: (function() {
Ham4Parser.ellipsedirection_return = function(){};
org.antlr.lang.extend(Ham4Parser.ellipsedirection_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4351:1: ellipsedirection : ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul );
// $ANTLR start "ellipsedirection"
ellipsedirection: function() {
var retval = new Ham4Parser.ellipsedirection_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set474 = null;
var set474_tree=null;
this.trace("ANTLR Parse: ellipsedirection starts "+this.state.backtracking);
try {
// Ham4Parser.g:4368:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set474=this.input.LT(1);
if ( (this.input.LA(1)>=HamEllipseh && this.input.LA(1)<=HamEllipseul) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set474));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: ellipsedirection finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
clock_return: (function() {
Ham4Parser.clock_return = function(){};
org.antlr.lang.extend(Ham4Parser.clock_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4374:1: clock : ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur );
// $ANTLR start "clock"
clock: function() {
var retval = new Ham4Parser.clock_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set475 = null;
var set475_tree=null;
this.trace("ANTLR Parse: clock starts "+this.state.backtracking);
try {
// Ham4Parser.g:4395:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set475=this.input.LT(1);
if ( (this.input.LA(1)>=HamClocku && this.input.LA(1)<=HamClockur) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set475));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: clock finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
modifier_return: (function() {
Ham4Parser.modifier_return = function(){};
org.antlr.lang.extend(Ham4Parser.modifier_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4405:1: modifier : ( HamFast | HamSlow | HamTense | HamRest | HamHalt );
// $ANTLR start "modifier"
modifier: function() {
var retval = new Ham4Parser.modifier_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set476 = null;
var set476_tree=null;
this.trace("ANTLR Parse: modifier starts "+this.state.backtracking);
try {
// Ham4Parser.g:4423:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set476=this.input.LT(1);
if ( (this.input.LA(1)>=HamFast && this.input.LA(1)<=HamHalt) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set476));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: modifier finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
arc_return: (function() {
Ham4Parser.arc_return = function(){};
org.antlr.lang.extend(Ham4Parser.arc_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4430:1: arc : ( HamArcl | HamArcu | HamArcr | HamArcd );
// $ANTLR start "arc"
arc: function() {
var retval = new Ham4Parser.arc_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set477 = null;
var set477_tree=null;
this.trace("ANTLR Parse: arc starts "+this.state.backtracking);
try {
// Ham4Parser.g:4447:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set477=this.input.LT(1);
if ( (this.input.LA(1)>=HamArcl && this.input.LA(1)<=HamArcd) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set477));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: arc finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// inline static return class
size_return: (function() {
Ham4Parser.size_return = function(){};
org.antlr.lang.extend(Ham4Parser.size_return,
org.antlr.runtime.ParserRuleReturnScope,
{
getTree: function() { return this.tree; }
});
return;
})(),
// Ham4Parser.g:4453:1: size : ( HamSmallmod | HamLargemod );
// $ANTLR start "size"
size: function() {
var retval = new Ham4Parser.size_return();
retval.start = this.input.LT(1);
var root_0 = null;
var set478 = null;
var set478_tree=null;
this.trace("ANTLR Parse: size starts "+this.state.backtracking);
try {
// Ham4Parser.g:4468:5: ( HamSmallmod | HamLargemod )
// Ham4Parser.g:
root_0 = this.adaptor.nil();
set478=this.input.LT(1);
if ( (this.input.LA(1)>=HamSmallmod && this.input.LA(1)<=HamLargemod) ) {
this.input.consume();
if ( this.state.backtracking===0 ) this.adaptor.addChild(root_0, this.adaptor.create(set478));
this.state.errorRecovery=false;this.state.failed=false;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return retval;}
var mse = new org.antlr.runtime.MismatchedSetException(null,this.input);
throw mse;
}
retval.stop = this.input.LT(-1);
if ( this.state.backtracking===0 ) {
retval.tree = this.adaptor.rulePostProcessing(root_0);
this.adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
}
if ( this.state.backtracking===0 ) {
this.trace("ANTLR Parse: size finish "+this.state.backtracking);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
retval.tree = this.adaptor.errorNode(this.input, retval.start, this.input.LT(-1), re);
} else {
throw re;
}
}
finally {
}
return retval;
},
// $ANTLR start "synpred1_Ham4Parser"
synpred1_Ham4Parser_fragment: function() {
// Ham4Parser.g:203:9: ( HamNondominant initialconfig1 )
// Ham4Parser.g:203:11: HamNondominant initialconfig1
this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_synpred1_Ham4Parser927); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_synpred1_Ham4Parser929);
this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred1_Ham4Parser",
// $ANTLR start "synpred2_Ham4Parser"
synpred2_Ham4Parser_fragment: function() {
// Ham4Parser.g:272:9: ( HamNomotion HamNondominant initialconfig1 )
// Ham4Parser.g:272:11: HamNomotion HamNondominant initialconfig1
this.match(this.input,HamNomotion,Ham4Parser.FOLLOW_HamNomotion_in_synpred2_Ham4Parser1111); if (this.state.failed) return ;
this.match(this.input,HamNondominant,Ham4Parser.FOLLOW_HamNondominant_in_synpred2_Ham4Parser1113); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_initialconfig1_in_synpred2_Ham4Parser1115);
this.initialconfig1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred2_Ham4Parser",
// $ANTLR start "synpred3_Ham4Parser"
synpred3_Ham4Parser_fragment: function() {
// Ham4Parser.g:454:11: ( levelbody )
// Ham4Parser.g:454:13: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred3_Ham4Parser1805);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred3_Ham4Parser",
// $ANTLR start "synpred4_Ham4Parser"
synpred4_Ham4Parser_fragment: function() {
// Ham4Parser.g:511:9: ( handconfig2 )
// Ham4Parser.g:511:11: handconfig2
this.pushFollow(Ham4Parser.FOLLOW_handconfig2_in_synpred4_Ham4Parser1939);
this.handconfig2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred4_Ham4Parser",
// $ANTLR start "synpred5_Ham4Parser"
synpred5_Ham4Parser_fragment: function() {
// Ham4Parser.g:515:13: ( location2 )
// Ham4Parser.g:515:15: location2
this.pushFollow(Ham4Parser.FOLLOW_location2_in_synpred5_Ham4Parser1987);
this.location2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred5_Ham4Parser",
// $ANTLR start "synpred6_Ham4Parser"
synpred6_Ham4Parser_fragment: function() {
// Ham4Parser.g:524:13: ( HamPlus )
// Ham4Parser.g:524:15: HamPlus
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred6_Ham4Parser2097); if (this.state.failed) return ;
},
// $ANTLR end "synpred6_Ham4Parser",
// $ANTLR start "synpred7_Ham4Parser"
synpred7_Ham4Parser_fragment: function() {
// Ham4Parser.g:601:9: ( handshape2 ( HamParbegin )? extfidir1 )
// Ham4Parser.g:601:11: handshape2 ( HamParbegin )? extfidir1
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_synpred7_Ham4Parser2410);
this.handshape2();
this.state._fsp--;
if (this.state.failed) return ;
// Ham4Parser.g:601:22: ( HamParbegin )?
var alt174=2;
var LA174_0 = this.input.LA(1);
if ( (LA174_0==HamParbegin) ) {
alt174=1;
}
switch (alt174) {
case 1 :
// Ham4Parser.g:601:24: HamParbegin
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred7_Ham4Parser2414); if (this.state.failed) return ;
break;
}
this.pushFollow(Ham4Parser.FOLLOW_extfidir1_in_synpred7_Ham4Parser2419);
this.extfidir1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred7_Ham4Parser",
// $ANTLR start "synpred8_Ham4Parser"
synpred8_Ham4Parser_fragment: function() {
// Ham4Parser.g:607:9: ( handshape2 )
// Ham4Parser.g:607:11: handshape2
this.pushFollow(Ham4Parser.FOLLOW_handshape2_in_synpred8_Ham4Parser2484);
this.handshape2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred8_Ham4Parser",
// $ANTLR start "synpred9_Ham4Parser"
synpred9_Ham4Parser_fragment: function() {
// Ham4Parser.g:710:9: ( extfidir2 )
// Ham4Parser.g:710:11: extfidir2
this.pushFollow(Ham4Parser.FOLLOW_extfidir2_in_synpred9_Ham4Parser2801);
this.extfidir2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred9_Ham4Parser",
// $ANTLR start "synpred10_Ham4Parser"
synpred10_Ham4Parser_fragment: function() {
// Ham4Parser.g:819:13: ( ( hsfingeritem )+ HamBetween finger )
// Ham4Parser.g:819:15: ( hsfingeritem )+ HamBetween finger
// Ham4Parser.g:819:15: ( hsfingeritem )+
var cnt175=0;
loop175:
do {
var alt175=2;
var LA175_0 = this.input.LA(1);
if ( ((LA175_0>=HamIndexfinger && LA175_0<=HamPinky)) ) {
alt175=1;
}
switch (alt175) {
case 1 :
// Ham4Parser.g:819:17: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred10_Ham4Parser3164);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt175 >= 1 ) {
break loop175;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(175, this.input);
throw eee;
}
cnt175++;
} while (true);
this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_synpred10_Ham4Parser3169); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_finger_in_synpred10_Ham4Parser3171);
this.finger();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred10_Ham4Parser",
// $ANTLR start "synpred11_Ham4Parser"
synpred11_Ham4Parser_fragment: function() {
// Ham4Parser.g:827:13: ( ( hsdigit )* ( fingerbending | fingerpart ) )
// Ham4Parser.g:827:15: ( hsdigit )* ( fingerbending | fingerpart )
// Ham4Parser.g:827:15: ( hsdigit )*
loop176:
do {
var alt176=2;
var LA176_0 = this.input.LA(1);
if ( ((LA176_0>=HamThumb && LA176_0<=HamPinky)) ) {
alt176=1;
}
switch (alt176) {
case 1 :
// Ham4Parser.g:827:17: hsdigit
this.pushFollow(Ham4Parser.FOLLOW_hsdigit_in_synpred11_Ham4Parser3278);
this.hsdigit();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
break loop176;
}
} while (true);
// Ham4Parser.g:827:28: ( fingerbending | fingerpart )
var alt177=2;
var LA177_0 = this.input.LA(1);
if ( ((LA177_0>=HamFingerstraightmod && LA177_0<=HamFingerhookedmod)||(LA177_0>=HamDoublebent && LA177_0<=HamDoublehooked)) ) {
alt177=1;
}
else if ( ((LA177_0>=HamFingertip && LA177_0<=HamFingerside)) ) {
alt177=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 177, 0, this.input);
throw nvae;
}
switch (alt177) {
case 1 :
// Ham4Parser.g:827:30: fingerbending
this.pushFollow(Ham4Parser.FOLLOW_fingerbending_in_synpred11_Ham4Parser3285);
this.fingerbending();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:827:46: fingerpart
this.pushFollow(Ham4Parser.FOLLOW_fingerpart_in_synpred11_Ham4Parser3289);
this.fingerpart();
this.state._fsp--;
if (this.state.failed) return ;
break;
}
},
// $ANTLR end "synpred11_Ham4Parser",
// $ANTLR start "synpred12_Ham4Parser"
synpred12_Ham4Parser_fragment: function() {
// Ham4Parser.g:832:15: ( thumbspecial )
// Ham4Parser.g:832:17: thumbspecial
this.pushFollow(Ham4Parser.FOLLOW_thumbspecial_in_synpred12_Ham4Parser3367);
this.thumbspecial();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred12_Ham4Parser",
// $ANTLR start "synpred13_Ham4Parser"
synpred13_Ham4Parser_fragment: function() {
// Ham4Parser.g:835:13: ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )
// Ham4Parser.g:835:15: ( hsfingeritem )* ( thumbbetweendefault | thumbextra )
// Ham4Parser.g:835:15: ( hsfingeritem )*
loop178:
do {
var alt178=2;
var LA178_0 = this.input.LA(1);
if ( ((LA178_0>=HamIndexfinger && LA178_0<=HamPinky)) ) {
alt178=1;
}
switch (alt178) {
case 1 :
// Ham4Parser.g:835:17: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred13_Ham4Parser3411);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
break loop178;
}
} while (true);
// Ham4Parser.g:835:33: ( thumbbetweendefault | thumbextra )
var alt179=2;
var LA179_0 = this.input.LA(1);
if ( (LA179_0==HamBetween) ) {
alt179=1;
}
else if ( (LA179_0==HamThumb||(LA179_0>=HamFingertip && LA179_0<=HamFingerside)) ) {
alt179=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 179, 0, this.input);
throw nvae;
}
switch (alt179) {
case 1 :
// Ham4Parser.g:835:35: thumbbetweendefault
this.pushFollow(Ham4Parser.FOLLOW_thumbbetweendefault_in_synpred13_Ham4Parser3418);
this.thumbbetweendefault();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:835:57: thumbextra
this.pushFollow(Ham4Parser.FOLLOW_thumbextra_in_synpred13_Ham4Parser3422);
this.thumbextra();
this.state._fsp--;
if (this.state.failed) return ;
break;
}
},
// $ANTLR end "synpred13_Ham4Parser",
// $ANTLR start "synpred14_Ham4Parser"
synpred14_Ham4Parser_fragment: function() {
// Ham4Parser.g:877:13: ( HamBetween handshapeclass )
// Ham4Parser.g:877:15: HamBetween handshapeclass
this.match(this.input,HamBetween,Ham4Parser.FOLLOW_HamBetween_in_synpred14_Ham4Parser3675); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_handshapeclass_in_synpred14_Ham4Parser3677);
this.handshapeclass();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred14_Ham4Parser",
// $ANTLR start "synpred15_Ham4Parser"
synpred15_Ham4Parser_fragment: function() {
// Ham4Parser.g:986:13: ( hsfingeritem )
// Ham4Parser.g:986:15: hsfingeritem
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred15_Ham4Parser4081);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred15_Ham4Parser",
// $ANTLR start "synpred16_Ham4Parser"
synpred16_Ham4Parser_fragment: function() {
// Ham4Parser.g:1034:13: ( hsfingeritem digit )
// Ham4Parser.g:1034:15: hsfingeritem digit
this.pushFollow(Ham4Parser.FOLLOW_hsfingeritem_in_synpred16_Ham4Parser4236);
this.hsfingeritem();
this.state._fsp--;
if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_digit_in_synpred16_Ham4Parser4238);
this.digit();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred16_Ham4Parser",
// $ANTLR start "synpred17_Ham4Parser"
synpred17_Ham4Parser_fragment: function() {
// Ham4Parser.g:1082:13: ( fingershape )
// Ham4Parser.g:1082:15: fingershape
this.pushFollow(Ham4Parser.FOLLOW_fingershape_in_synpred17_Ham4Parser4396);
this.fingershape();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred17_Ham4Parser",
// $ANTLR start "synpred18_Ham4Parser"
synpred18_Ham4Parser_fragment: function() {
// Ham4Parser.g:1130:13: ( fingercrossing )
// Ham4Parser.g:1130:15: fingercrossing
this.pushFollow(Ham4Parser.FOLLOW_fingercrossing_in_synpred18_Ham4Parser4551);
this.fingercrossing();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred18_Ham4Parser",
// $ANTLR start "synpred19_Ham4Parser"
synpred19_Ham4Parser_fragment: function() {
// Ham4Parser.g:1627:9: ( handconstellation )
// Ham4Parser.g:1627:11: handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_synpred19_Ham4Parser5984);
this.handconstellation();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred19_Ham4Parser",
// $ANTLR start "synpred20_Ham4Parser"
synpred20_Ham4Parser_fragment: function() {
// Ham4Parser.g:1675:9: ( locationindexuse )
// Ham4Parser.g:1675:11: locationindexuse
this.pushFollow(Ham4Parser.FOLLOW_locationindexuse_in_synpred20_Ham4Parser6226);
this.locationindexuse();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred20_Ham4Parser",
// $ANTLR start "synpred21_Ham4Parser"
synpred21_Ham4Parser_fragment: function() {
// Ham4Parser.g:1679:9: ( levelhand )
// Ham4Parser.g:1679:11: levelhand
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_synpred21_Ham4Parser6286);
this.levelhand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred21_Ham4Parser",
// $ANTLR start "synpred22_Ham4Parser"
synpred22_Ham4Parser_fragment: function() {
// Ham4Parser.g:1760:9: ( levelbody )
// Ham4Parser.g:1760:11: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred22_Ham4Parser6517);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred22_Ham4Parser",
// $ANTLR start "synpred23_Ham4Parser"
synpred23_Ham4Parser_fragment: function() {
// Ham4Parser.g:1789:11: ( contactbody )
// Ham4Parser.g:1789:13: contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_synpred23_Ham4Parser6638);
this.contactbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred23_Ham4Parser",
// $ANTLR start "synpred24_Ham4Parser"
synpred24_Ham4Parser_fragment: function() {
// Ham4Parser.g:1812:11: ( contacthand )
// Ham4Parser.g:1812:12: contacthand
this.pushFollow(Ham4Parser.FOLLOW_contacthand_in_synpred24_Ham4Parser6718);
this.contacthand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred24_Ham4Parser",
// $ANTLR start "synpred25_Ham4Parser"
synpred25_Ham4Parser_fragment: function() {
// Ham4Parser.g:1837:11: ( contactbody )
// Ham4Parser.g:1837:13: contactbody
this.pushFollow(Ham4Parser.FOLLOW_contactbody_in_synpred25_Ham4Parser6810);
this.contactbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred25_Ham4Parser",
// $ANTLR start "synpred26_Ham4Parser"
synpred26_Ham4Parser_fragment: function() {
// Ham4Parser.g:2195:13: ( levelhand )
// Ham4Parser.g:2195:15: levelhand
this.pushFollow(Ham4Parser.FOLLOW_levelhand_in_synpred26_Ham4Parser8185);
this.levelhand();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred26_Ham4Parser",
// $ANTLR start "synpred27_Ham4Parser"
synpred27_Ham4Parser_fragment: function() {
// Ham4Parser.g:2426:9: ( action1 location2not1 )
// Ham4Parser.g:2426:11: action1 location2not1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred27_Ham4Parser8806);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_location2not1_in_synpred27_Ham4Parser8808);
this.location2not1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred27_Ham4Parser",
// $ANTLR start "synpred28_Ham4Parser"
synpred28_Ham4Parser_fragment: function() {
// Ham4Parser.g:2433:9: ( action1t )
// Ham4Parser.g:2433:11: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_synpred28_Ham4Parser8886);
this.action1t();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred28_Ham4Parser",
// $ANTLR start "synpred29_Ham4Parser"
synpred29_Ham4Parser_fragment: function() {
// Ham4Parser.g:2439:13: ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )
// Ham4Parser.g:2439:15: HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred29_Ham4Parser8953); if (this.state.failed) return ;
// Ham4Parser.g:2439:27: ( action1 )+
var cnt180=0;
loop180:
do {
var alt180=2;
alt180 = this.dfa180.predict(this.input);
switch (alt180) {
case 1 :
// Ham4Parser.g:2439:29: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred29_Ham4Parser8957);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt180 >= 1 ) {
break loop180;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(180, this.input);
throw eee;
}
cnt180++;
} while (true);
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred29_Ham4Parser8962); if (this.state.failed) return ;
// Ham4Parser.g:2440:15: ( action1 )+
var cnt181=0;
loop181:
do {
var alt181=2;
alt181 = this.dfa181.predict(this.input);
switch (alt181) {
case 1 :
// Ham4Parser.g:2440:17: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred29_Ham4Parser8980);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt181 >= 1 ) {
break loop181;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(181, this.input);
throw eee;
}
cnt181++;
} while (true);
this.match(this.input,HamParend,Ham4Parser.FOLLOW_HamParend_in_synpred29_Ham4Parser8985); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_location2_in_synpred29_Ham4Parser8987);
this.location2();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred29_Ham4Parser",
// $ANTLR start "synpred30_Ham4Parser"
synpred30_Ham4Parser_fragment: function() {
// Ham4Parser.g:2444:13: ( HamParbegin ( action1t )+ HamPlus )
// Ham4Parser.g:2444:15: HamParbegin ( action1t )+ HamPlus
this.match(this.input,HamParbegin,Ham4Parser.FOLLOW_HamParbegin_in_synpred30_Ham4Parser9043); if (this.state.failed) return ;
// Ham4Parser.g:2444:27: ( action1t )+
var cnt182=0;
loop182:
do {
var alt182=2;
alt182 = this.dfa182.predict(this.input);
switch (alt182) {
case 1 :
// Ham4Parser.g:2444:29: action1t
this.pushFollow(Ham4Parser.FOLLOW_action1t_in_synpred30_Ham4Parser9047);
this.action1t();
this.state._fsp--;
if (this.state.failed) return ;
break;
default :
if ( cnt182 >= 1 ) {
break loop182;
}
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var eee = new org.antlr.runtime.EarlyExitException(182, this.input);
throw eee;
}
cnt182++;
} while (true);
this.match(this.input,HamPlus,Ham4Parser.FOLLOW_HamPlus_in_synpred30_Ham4Parser9052); if (this.state.failed) return ;
},
// $ANTLR end "synpred30_Ham4Parser",
// $ANTLR start "synpred31_Ham4Parser"
synpred31_Ham4Parser_fragment: function() {
// Ham4Parser.g:2504:13: ( action1 )
// Ham4Parser.g:2504:15: action1
this.pushFollow(Ham4Parser.FOLLOW_action1_in_synpred31_Ham4Parser9260);
this.action1();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred31_Ham4Parser",
// $ANTLR start "synpred32_Ham4Parser"
synpred32_Ham4Parser_fragment: function() {
// Ham4Parser.g:2509:21: ( handconstellation )
// Ham4Parser.g:2509:23: handconstellation
this.pushFollow(Ham4Parser.FOLLOW_handconstellation_in_synpred32_Ham4Parser9350);
this.handconstellation();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred32_Ham4Parser",
// $ANTLR start "synpred33_Ham4Parser"
synpred33_Ham4Parser_fragment: function() {
// Ham4Parser.g:2585:9: ( HamSeqbegin digit )
// Ham4Parser.g:2585:11: HamSeqbegin digit
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred33_Ham4Parser9850); if (this.state.failed) return ;
this.pushFollow(Ham4Parser.FOLLOW_digit_in_synpred33_Ham4Parser9852);
this.digit();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred33_Ham4Parser",
// $ANTLR start "synpred34_Ham4Parser"
synpred34_Ham4Parser_fragment: function() {
// Ham4Parser.g:2807:6: ( levelbody )
// Ham4Parser.g:2807:8: levelbody
this.pushFollow(Ham4Parser.FOLLOW_levelbody_in_synpred34_Ham4Parser10607);
this.levelbody();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred34_Ham4Parser",
// $ANTLR start "synpred35_Ham4Parser"
synpred35_Ham4Parser_fragment: function() {
// Ham4Parser.g:2950:13: ( ( HamSeqbegin )? repetition | HamAlternatingmotion )
var alt184=2;
var LA184_0 = this.input.LA(1);
if ( ((LA184_0>=HamRepeatfromstart && LA184_0<=HamSeqbegin)||LA184_0==HamRepeatreverse) ) {
alt184=1;
}
else if ( (LA184_0==HamAlternatingmotion) ) {
alt184=2;
}
else {
if (this.state.backtracking>0) {this.state.failed=true; return ;}
var nvae =
new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);
throw nvae;
}
switch (alt184) {
case 1 :
// Ham4Parser.g:2950:15: ( HamSeqbegin )? repetition
// Ham4Parser.g:2950:15: ( HamSeqbegin )?
var alt183=2;
var LA183_0 = this.input.LA(1);
if ( (LA183_0==HamSeqbegin) ) {
alt183=1;
}
switch (alt183) {
case 1 :
// Ham4Parser.g:2950:17: HamSeqbegin
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred35_Ham4Parser11107); if (this.state.failed) return ;
break;
}
this.pushFollow(Ham4Parser.FOLLOW_repetition_in_synpred35_Ham4Parser11112);
this.repetition();
this.state._fsp--;
if (this.state.failed) return ;
break;
case 2 :
// Ham4Parser.g:2950:45: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4Parser.FOLLOW_HamAlternatingmotion_in_synpred35_Ham4Parser11116); if (this.state.failed) return ;
break;
}},
// $ANTLR end "synpred35_Ham4Parser",
// $ANTLR start "synpred36_Ham4Parser"
synpred36_Ham4Parser_fragment: function() {
// Ham4Parser.g:3003:9: ( HamSeqbegin HamRepeatfromstartseveral HamEtc )
// Ham4Parser.g:3003:11: HamSeqbegin HamRepeatfromstartseveral HamEtc
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred36_Ham4Parser11200); if (this.state.failed) return ;
this.match(this.input,HamRepeatfromstartseveral,Ham4Parser.FOLLOW_HamRepeatfromstartseveral_in_synpred36_Ham4Parser11202); if (this.state.failed) return ;
this.match(this.input,HamEtc,Ham4Parser.FOLLOW_HamEtc_in_synpred36_Ham4Parser11204); if (this.state.failed) return ;
},
// $ANTLR end "synpred36_Ham4Parser",
// $ANTLR start "synpred37_Ham4Parser"
synpred37_Ham4Parser_fragment: function() {
// Ham4Parser.g:3172:11: ( HamSeqbegin HamBrushing )
// Ham4Parser.g:3172:13: HamSeqbegin HamBrushing
this.match(this.input,HamSeqbegin,Ham4Parser.FOLLOW_HamSeqbegin_in_synpred37_Ham4Parser12158); if (this.state.failed) return ;
this.match(this.input,HamBrushing,Ham4Parser.FOLLOW_HamBrushing_in_synpred37_Ham4Parser12160); if (this.state.failed) return ;
},
// $ANTLR end "synpred37_Ham4Parser",
// $ANTLR start "synpred38_Ham4Parser"
synpred38_Ham4Parser_fragment: function() {
// Ham4Parser.g:3177:11: ( locationindexdefine )
// Ham4Parser.g:3177:13: locationindexdefine
this.pushFollow(Ham4Parser.FOLLOW_locationindexdefine_in_synpred38_Ham4Parser12255);
this.locationindexdefine();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred38_Ham4Parser",
// $ANTLR start "synpred39_Ham4Parser"
synpred39_Ham4Parser_fragment: function() {
// Ham4Parser.g:3443:17: ( splitreplacetail )
// Ham4Parser.g:3443:19: splitreplacetail
this.pushFollow(Ham4Parser.FOLLOW_splitreplacetail_in_synpred39_Ham4Parser13211);
this.splitreplacetail();
this.state._fsp--;
if (this.state.failed) return ;
},
// $ANTLR end "synpred39_Ham4Parser"
// Delegated rules
synpred6_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred6_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred19_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred19_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred22_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred22_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred12_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred12_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred9_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred9_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred3_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred3_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred16_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred16_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred26_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred26_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred36_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred36_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred28_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred28_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred32_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred32_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred31_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred31_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred5_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred5_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred21_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred21_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred38_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred38_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred11_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred11_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred15_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred15_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred25_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred25_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred39_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred39_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred35_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred35_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred2_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred2_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred29_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred29_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred37_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred37_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred14_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred14_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred17_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred17_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred20_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred20_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred10_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred10_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred34_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred34_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred24_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred24_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred30_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred30_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred1_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred1_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred7_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred7_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred18_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred18_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred23_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred23_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred13_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred13_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred8_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred8_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred4_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred4_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred27_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred27_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
},
synpred33_Ham4Parser: function() {
this.state.backtracking++;
var start = this.input.mark();
try {
this.synpred33_Ham4Parser_fragment(); // can never throw exception
} catch (re) {
alert("impossible: "+re.toString());
}
var success = !this.state.failed;
this.input.rewind(start);
this.state.backtracking--;
this.state.failed=false;
return success;
}
}, true); // important to pass true to overwrite default implementations
org.antlr.lang.augmentObject(Ham4Parser, {
DFA13_eotS:
"\u0014\uffff",
DFA13_eofS:
"\u0014\uffff",
DFA13_minS:
"\u0001\u0043\u0011\uffff\u0001\u0000\u0001\uffff",
DFA13_maxS:
"\u0001\u006b\u0011\uffff\u0001\u0000\u0001\uffff",
DFA13_acceptS:
"\u0001\uffff\u0011\u0001\u0001\uffff\u0001\u0002",
DFA13_specialS:
"\u0001\u0000\u0011\uffff\u0001\u0001\u0001\uffff}>",
DFA13_transitionS: [
"\u0001\u0011\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007"+
"\u0001\u0008\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002"+
"\u0001\u0003\u0001\u0004\u0001\u0008\u0001\u0005\u0002\u0011"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d"+
"\u0001\u000e\u0001\u0010\u0002\u0012\u0004\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA13_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_eotS),
DFA13_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_eofS),
DFA13_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA13_minS),
DFA13_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA13_maxS),
DFA13_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_acceptS),
DFA13_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_specialS),
DFA13_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA13_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA13_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA13 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 13;
this.eot = Ham4Parser.DFA13_eot;
this.eof = Ham4Parser.DFA13_eof;
this.min = Ham4Parser.DFA13_min;
this.max = Ham4Parser.DFA13_max;
this.accept = Ham4Parser.DFA13_accept;
this.special = Ham4Parser.DFA13_special;
this.transition = Ham4Parser.DFA13_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA13, org.antlr.runtime.DFA, {
getDescription: function() {
return "453:9: ( ( levelbody )=> levelbody | levelarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA13_0 = input.LA(1);
var index13_0 = input.index();
input.rewind();
s = -1;
if ( (LA13_0==HamHead) && (this.synpred3_Ham4Parser())) {s = 1;}
else if ( (LA13_0==HamHeadtop) && (this.synpred3_Ham4Parser())) {s = 2;}
else if ( (LA13_0==HamForehead) && (this.synpred3_Ham4Parser())) {s = 3;}
else if ( (LA13_0==HamEyebrows) && (this.synpred3_Ham4Parser())) {s = 4;}
else if ( (LA13_0==HamNose) && (this.synpred3_Ham4Parser())) {s = 5;}
else if ( (LA13_0==HamNostrils) && (this.synpred3_Ham4Parser())) {s = 6;}
else if ( (LA13_0==HamTongue) && (this.synpred3_Ham4Parser())) {s = 7;}
else if ( (LA13_0==HamTeeth||LA13_0==HamEyes||LA13_0==HamLips) && (this.synpred3_Ham4Parser())) {s = 8;}
else if ( (LA13_0==HamChin) && (this.synpred3_Ham4Parser())) {s = 9;}
else if ( (LA13_0==HamUnderchin) && (this.synpred3_Ham4Parser())) {s = 10;}
else if ( (LA13_0==HamNeck) && (this.synpred3_Ham4Parser())) {s = 11;}
else if ( (LA13_0==HamShouldertop) && (this.synpred3_Ham4Parser())) {s = 12;}
else if ( (LA13_0==HamShoulders) && (this.synpred3_Ham4Parser())) {s = 13;}
else if ( (LA13_0==HamChest) && (this.synpred3_Ham4Parser())) {s = 14;}
else if ( (LA13_0==HamStomach) && (this.synpred3_Ham4Parser())) {s = 15;}
else if ( (LA13_0==HamBelowstomach) && (this.synpred3_Ham4Parser())) {s = 16;}
else if ( (LA13_0==HamEarlobe||(LA13_0>=HamEar && LA13_0<=HamCheek)) && (this.synpred3_Ham4Parser())) {s = 17;}
else if ( ((LA13_0>=HamLrbeside && LA13_0<=HamLrat)) ) {s = 18;}
else if ( ((LA13_0>=HamUpperarm && LA13_0<=HamLowerarm)) ) {s = 19;}
input.seek(index13_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA13_18 = input.LA(1);
var index13_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred3_Ham4Parser()) ) {s = 17;}
else if ( (true) ) {s = 19;}
input.seek(index13_18);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 13, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA14_eotS:
"\u0027\uffff",
DFA14_eofS:
"\u0001\u001d\u0026\uffff",
DFA14_minS:
"\u0001\u000f\u0018\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u000a"+
"\uffff",
DFA14_maxS:
"\u0001\u00d9\u0018\uffff\u0001\u0000\u0002\uffff\u0001\u0000\u000a"+
"\uffff",
DFA14_acceptS:
"\u0001\uffff\u0018\u0001\u0001\uffff\u0002\u0001\u0001\uffff\u0001"+
"\u0002\u0009\uffff",
DFA14_specialS:
"\u0001\u0000\u0018\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u000a"+
"\uffff}>",
DFA14_transitionS: [
"\u0001\u001d\u0033\uffff\u0001\u0017\u0001\u000c\u0001\u0012"+
"\u0008\uffff\u0001\u001d\u0004\uffff\u0001\u000d\u0001\u000e"+
"\u0001\u0015\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009"+
"\u0001\u000a\u0001\u000e\u0001\u000b\u0002\u0017\u0001\u000e"+
"\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0013\u0001\u0014"+
"\u0001\u0016\u0002\u0005\u0004\u0018\u0005\u0003\u0001\u0001"+
"\u0004\u0002\u0002\u0003\u0001\uffff\u0006\u0004\u0006\uffff"+
"\u0015\u001d\u0008\uffff\u0001\u001d\u0001\u0019\u0001\uffff"+
"\u0006\u001d\u0002\uffff\u0002\u001a\u0002\u001b\u0009\uffff"+
"\u0001\u001c\u000c\uffff\u0006\u001d\u0001\uffff\u000c\u001d",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA14_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_eotS),
DFA14_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_eofS),
DFA14_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA14_minS),
DFA14_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA14_maxS),
DFA14_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_acceptS),
DFA14_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_specialS),
DFA14_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA14_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA14_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA14 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 14;
this.eot = Ham4Parser.DFA14_eot;
this.eof = Ham4Parser.DFA14_eof;
this.min = Ham4Parser.DFA14_min;
this.max = Ham4Parser.DFA14_max;
this.accept = Ham4Parser.DFA14_accept;
this.special = Ham4Parser.DFA14_special;
this.transition = Ham4Parser.DFA14_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA14, org.antlr.runtime.DFA, {
getDescription: function() {
return "514:9: ( ( location2 )=> location2 )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA14_0 = input.LA(1);
var index14_0 = input.index();
input.rewind();
s = -1;
if ( (LA14_0==HamThumb) && (this.synpred5_Ham4Parser())) {s = 1;}
else if ( ((LA14_0>=HamIndexfinger && LA14_0<=HamPinky)) && (this.synpred5_Ham4Parser())) {s = 2;}
else if ( ((LA14_0>=HamWristback && LA14_0<=HamHandback)||(LA14_0>=HamThumbside && LA14_0<=HamPinkyside)) && (this.synpred5_Ham4Parser())) {s = 3;}
else if ( ((LA14_0>=HamFingertip && LA14_0<=HamFingerside)) && (this.synpred5_Ham4Parser())) {s = 4;}
else if ( ((LA14_0>=HamLrbeside && LA14_0<=HamLrat)) && (this.synpred5_Ham4Parser())) {s = 5;}
else if ( (LA14_0==HamNeutralspace) && (this.synpred5_Ham4Parser())) {s = 6;}
else if ( (LA14_0==HamHead) && (this.synpred5_Ham4Parser())) {s = 7;}
else if ( (LA14_0==HamHeadtop) && (this.synpred5_Ham4Parser())) {s = 8;}
else if ( (LA14_0==HamForehead) && (this.synpred5_Ham4Parser())) {s = 9;}
else if ( (LA14_0==HamEyebrows) && (this.synpred5_Ham4Parser())) {s = 10;}
else if ( (LA14_0==HamNose) && (this.synpred5_Ham4Parser())) {s = 11;}
else if ( (LA14_0==HamNostrils) && (this.synpred5_Ham4Parser())) {s = 12;}
else if ( (LA14_0==HamTongue) && (this.synpred5_Ham4Parser())) {s = 13;}
else if ( (LA14_0==HamTeeth||LA14_0==HamEyes||LA14_0==HamLips) && (this.synpred5_Ham4Parser())) {s = 14;}
else if ( (LA14_0==HamChin) && (this.synpred5_Ham4Parser())) {s = 15;}
else if ( (LA14_0==HamUnderchin) && (this.synpred5_Ham4Parser())) {s = 16;}
else if ( (LA14_0==HamNeck) && (this.synpred5_Ham4Parser())) {s = 17;}
else if ( (LA14_0==HamShouldertop) && (this.synpred5_Ham4Parser())) {s = 18;}
else if ( (LA14_0==HamShoulders) && (this.synpred5_Ham4Parser())) {s = 19;}
else if ( (LA14_0==HamChest) && (this.synpred5_Ham4Parser())) {s = 20;}
else if ( (LA14_0==HamStomach) && (this.synpred5_Ham4Parser())) {s = 21;}
else if ( (LA14_0==HamBelowstomach) && (this.synpred5_Ham4Parser())) {s = 22;}
else if ( (LA14_0==HamEarlobe||(LA14_0>=HamEar && LA14_0<=HamCheek)) && (this.synpred5_Ham4Parser())) {s = 23;}
else if ( ((LA14_0>=HamUpperarm && LA14_0<=HamLowerarm)) && (this.synpred5_Ham4Parser())) {s = 24;}
else if ( (LA14_0==HamParbegin) ) {s = 25;}
else if ( ((LA14_0>=HamClose && LA14_0<=HamTouch)) && (this.synpred5_Ham4Parser())) {s = 26;}
else if ( ((LA14_0>=HamInterlock && LA14_0<=HamCross)) && (this.synpred5_Ham4Parser())) {s = 27;}
else if ( (LA14_0==HamSeqbegin) ) {s = 28;}
else if ( (LA14_0==EOF||LA14_0==HamPlus||LA14_0==HamReplace||(LA14_0>=HamNomotion && LA14_0<=HamMovex)||LA14_0==HamFingerplay||(LA14_0>=HamCircleo && LA14_0<=HamCircler)||(LA14_0>=HamNodding && LA14_0<=HamFusionbegin)||(LA14_0>=HamCircleul && LA14_0<=HamCircleuo)) ) {s = 29;}
input.seek(index14_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA14_25 = input.LA(1);
var index14_25 = input.index();
input.rewind();
s = -1;
if ( (this.synpred5_Ham4Parser()) ) {s = 27;}
else if ( (true) ) {s = 29;}
input.seek(index14_25);
if ( s>=0 ) return s;
break;
case 2 : 
var LA14_28 = input.LA(1);
var index14_28 = input.index();
input.rewind();
s = -1;
if ( (this.synpred5_Ham4Parser()) ) {s = 27;}
else if ( (true) ) {s = 29;}
input.seek(index14_28);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 14, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA16_eotS:
"\u001a\uffff",
DFA16_eofS:
"\u001a\uffff",
DFA16_minS:
"\u0001\u000f\u0019\uffff",
DFA16_maxS:
"\u0001\u007e\u0019\uffff",
DFA16_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0017\uffff",
DFA16_specialS:
"\u0001\u0000\u0019\uffff}>",
DFA16_transitionS: [
"\u0001\u0001\u0033\uffff\u0003\u0002\u000d\uffff\u0025\u0002"+
"\u0001\uffff\u0006\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA16_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_eotS),
DFA16_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_eofS),
DFA16_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA16_minS),
DFA16_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA16_maxS),
DFA16_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_acceptS),
DFA16_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_specialS),
DFA16_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA16_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA16_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA16 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 16;
this.eot = Ham4Parser.DFA16_eot;
this.eof = Ham4Parser.DFA16_eof;
this.min = Ham4Parser.DFA16_min;
this.max = Ham4Parser.DFA16_max;
this.accept = Ham4Parser.DFA16_accept;
this.special = Ham4Parser.DFA16_special;
this.transition = Ham4Parser.DFA16_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA16, org.antlr.runtime.DFA, {
getDescription: function() {
return "523:9: ( ( HamPlus )=> HamPlus location1 HamParend -> ^( MICFG2 handconfig1 HamPlus location1 ) | loc= location1 HamPlus (ploc= location1 )? HamParend -> ^( MICFG2 handconfig1 $loc HamPlus ( $ploc)? ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA16_0 = input.LA(1);
var index16_0 = input.index();
input.rewind();
s = -1;
if ( (LA16_0==HamPlus) && (this.synpred6_Ham4Parser())) {s = 1;}
else if ( ((LA16_0>=HamEarlobe && LA16_0<=HamShouldertop)||(LA16_0>=HamTongue && LA16_0<=HamPinkyside)||(LA16_0>=HamFingertip && LA16_0<=HamFingerside)) ) {s = 2;}
input.seek(index16_0);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 16, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA15_eotS:
"\u001a\uffff",
DFA15_eofS:
"\u001a\uffff",
DFA15_minS:
"\u0001\u0043\u0019\uffff",
DFA15_maxS:
"\u0001\u00a4\u0019\uffff",
DFA15_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002",
DFA15_specialS:
"\u001a\uffff}>",
DFA15_transitionS: [
"\u0003\u0001\u000d\uffff\u0025\u0001\u0001\uffff\u0006\u0001"+
"\u0025\uffff\u0001\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA15_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_eotS),
DFA15_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_eofS),
DFA15_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA15_minS),
DFA15_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA15_maxS),
DFA15_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_acceptS),
DFA15_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_specialS),
DFA15_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA15_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA15_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA15 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 15;
this.eot = Ham4Parser.DFA15_eot;
this.eof = Ham4Parser.DFA15_eof;
this.min = Ham4Parser.DFA15_min;
this.max = Ham4Parser.DFA15_max;
this.accept = Ham4Parser.DFA15_accept;
this.special = Ham4Parser.DFA15_special;
this.transition = Ham4Parser.DFA15_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA15, org.antlr.runtime.DFA, {
getDescription: function() {
return "535:13: (ploc= location1 )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA18_eotS:
"\u0025\uffff",
DFA18_eofS:
"\u0001\u0019\u0024\uffff",
DFA18_minS:
"\u0001\u000f\u0024\uffff",
DFA18_maxS:
"\u0001\u00d9\u0024\uffff",
DFA18_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002\u000b\uffff",
DFA18_specialS:
"\u0025\uffff}>",
DFA18_transitionS: [
"\u0001\u0019\u0033\uffff\u0003\u0001\u0008\uffff\u0001\u0019"+
"\u0004\uffff\u0025\u0001\u0001\uffff\u0006\u0001\u0006\uffff"+
"\u0015\u0019\u0008\uffff\u0002\u0019\u0001\uffff\u0006\u0019"+
"\u000f\uffff\u0001\u0019\u000c\uffff\u0006\u0019\u0001\uffff"+
"\u000c\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA18_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_eotS),
DFA18_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_eofS),
DFA18_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA18_minS),
DFA18_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA18_maxS),
DFA18_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_acceptS),
DFA18_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_specialS),
DFA18_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA18_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA18_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA18 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 18;
this.eot = Ham4Parser.DFA18_eot;
this.eof = Ham4Parser.DFA18_eof;
this.min = Ham4Parser.DFA18_min;
this.max = Ham4Parser.DFA18_max;
this.accept = Ham4Parser.DFA18_accept;
this.special = Ham4Parser.DFA18_special;
this.transition = Ham4Parser.DFA18_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA18, org.antlr.runtime.DFA, {
getDescription: function() {
return "562:9: ( location1 )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA21_eotS:
"\u0015\uffff",
DFA21_eofS:
"\u0015\uffff",
DFA21_minS:
"\u0001\u0031\u0012\uffff\u0001\u0000\u0001\uffff",
DFA21_maxS:
"\u0001\u00a3\u0012\uffff\u0001\u0000\u0001\uffff",
DFA21_acceptS:
"\u0001\uffff\u0012\u0001\u0001\uffff\u0001\u0002",
DFA21_specialS:
"\u0001\u0000\u0012\uffff\u0001\u0001\u0001\uffff}>",
DFA21_transitionS: [
"\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005"+
"\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a"+
"\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f"+
"\u0001\u0010\u0001\u0011\u0001\u0012\u0060\uffff\u0001\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA21_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_eotS),
DFA21_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_eofS),
DFA21_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA21_minS),
DFA21_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA21_maxS),
DFA21_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_acceptS),
DFA21_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_specialS),
DFA21_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA21_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA21_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA21 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 21;
this.eot = Ham4Parser.DFA21_eot;
this.eof = Ham4Parser.DFA21_eof;
this.min = Ham4Parser.DFA21_min;
this.max = Ham4Parser.DFA21_max;
this.accept = Ham4Parser.DFA21_accept;
this.special = Ham4Parser.DFA21_special;
this.transition = Ham4Parser.DFA21_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA21, org.antlr.runtime.DFA, {
getDescription: function() {
return "709:5: ( ( extfidir2 )=> extfidir2 palmor2 -> ^( HDCFGTAIL2 extfidir2 palmor2 ) | HamParbegin efd1= extfidir1 por1= palmor1 HamPlus efd2= extfidir1 por2= palmor1 HamParend -> ^( HDCFGTAIL2 $efd1 $por1 $efd2 $por2) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA21_0 = input.LA(1);
var index21_0 = input.index();
input.rewind();
s = -1;
if ( (LA21_0==HamExtfingeru) && (this.synpred9_Ham4Parser())) {s = 1;}
else if ( (LA21_0==HamExtfingerur) && (this.synpred9_Ham4Parser())) {s = 2;}
else if ( (LA21_0==HamExtfingerr) && (this.synpred9_Ham4Parser())) {s = 3;}
else if ( (LA21_0==HamExtfingerdr) && (this.synpred9_Ham4Parser())) {s = 4;}
else if ( (LA21_0==HamExtfingerd) && (this.synpred9_Ham4Parser())) {s = 5;}
else if ( (LA21_0==HamExtfingerdl) && (this.synpred9_Ham4Parser())) {s = 6;}
else if ( (LA21_0==HamExtfingerl) && (this.synpred9_Ham4Parser())) {s = 7;}
else if ( (LA21_0==HamExtfingerul) && (this.synpred9_Ham4Parser())) {s = 8;}
else if ( (LA21_0==HamExtfingerol) && (this.synpred9_Ham4Parser())) {s = 9;}
else if ( (LA21_0==HamExtfingero) && (this.synpred9_Ham4Parser())) {s = 10;}
else if ( (LA21_0==HamExtfingeror) && (this.synpred9_Ham4Parser())) {s = 11;}
else if ( (LA21_0==HamExtfingeril) && (this.synpred9_Ham4Parser())) {s = 12;}
else if ( (LA21_0==HamExtfingeri) && (this.synpred9_Ham4Parser())) {s = 13;}
else if ( (LA21_0==HamExtfingerir) && (this.synpred9_Ham4Parser())) {s = 14;}
else if ( (LA21_0==HamExtfingerui) && (this.synpred9_Ham4Parser())) {s = 15;}
else if ( (LA21_0==HamExtfingerdi) && (this.synpred9_Ham4Parser())) {s = 16;}
else if ( (LA21_0==HamExtfingerdo) && (this.synpred9_Ham4Parser())) {s = 17;}
else if ( (LA21_0==HamExtfingeruo) && (this.synpred9_Ham4Parser())) {s = 18;}
else if ( (LA21_0==HamParbegin) ) {s = 19;}
input.seek(index21_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA21_19 = input.LA(1);
var index21_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred9_Ham4Parser()) ) {s = 18;}
else if ( (true) ) {s = 20;}
input.seek(index21_19);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 21, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA25_eotS:
"\u0045\uffff",
DFA25_eofS:
"\u0001\u0037\u0044\uffff",
DFA25_minS:
"\u0001\u000f\u0040\u0000\u0004\uffff",
DFA25_maxS:
"\u0001\u00d9\u0040\u0000\u0004\uffff",
DFA25_acceptS:
"\u0041\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004",
DFA25_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
"\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001"+
"\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001"+
"\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001"+
"\u0016\u0001\u0017\u0001\u0018\u0001\u0019\u0001\u001a\u0001\u001b\u0001"+
"\u001c\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021\u0001"+
"\u0022\u0001\u0023\u0001\u0024\u0001\u0025\u0001\u0026\u0001\u0027\u0001"+
"\u0028\u0001\u0029\u0001\u002a\u0001\u002b\u0001\u002c\u0001\u002d\u0001"+
"\u002e\u0001\u002f\u0001\u0030\u0001\u0031\u0001\u0032\u0001\u0033\u0001"+
"\u0034\u0001\u0035\u0001\u0036\u0001\u0037\u0001\u0038\u0001\u0039\u0001"+
"\u003a\u0001\u003b\u0001\u003c\u0001\u003d\u0001\u003e\u0001\u003f\u0004"+
"\uffff}>",
DFA25_transitionS: [
"\u0001\u0017\u0021\uffff\u0001\u0005\u0001\u0006\u0001\u0007"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c"+
"\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011"+
"\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016"+
"\u0001\u002b\u0001\u0020\u0001\u0026\u0008\u003b\u0001\u0032"+
"\u0004\uffff\u0001\u0021\u0001\u0022\u0001\u0029\u0001\u001a"+
"\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u0022"+
"\u0001\u001f\u0002\u002b\u0001\u0022\u0001\u0023\u0001\u0024"+
"\u0001\u0025\u0001\u0027\u0001\u0028\u0001\u002a\u0002\u0019"+
"\u0004\u002c\u0005\u0018\u0001\u0002\u0004\u0001\u0002\u0018"+
"\u0001\u0003\u0006\u0004\u0006\uffff\u0001\u002d\u0012\u002e"+
"\u0002\u0030\u0008\uffff\u0001\u0033\u0001\u0035\u0001\u0038"+
"\u0006\u002f\u0002\uffff\u0002\u0039\u0002\u003a\u0005\u003c"+
"\u0004\u003e\u0001\u0034\u0001\u003d\u0001\u003f\u0001\u003e"+
"\u0009\uffff\u0005\u0031\u0001\u0036\u0001\u0040\u000c\u002f",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA25_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_eotS),
DFA25_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_eofS),
DFA25_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA25_minS),
DFA25_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA25_maxS),
DFA25_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_acceptS),
DFA25_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_specialS),
DFA25_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA25_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA25_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA25 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 25;
this.eot = Ham4Parser.DFA25_eot;
this.eof = Ham4Parser.DFA25_eof;
this.min = Ham4Parser.DFA25_min;
this.max = Ham4Parser.DFA25_max;
this.accept = Ham4Parser.DFA25_accept;
this.special = Ham4Parser.DFA25_special;
this.transition = Ham4Parser.DFA25_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA25, org.antlr.runtime.DFA, {
getDescription: function() {
return "818:9: ( ( ( hsfingeritem )+ HamBetween finger )=> cautiousfingerlist fingershapelist fingercrossinglist thumbbetweenexplicit | ( ( hsdigit )* ( fingerbending | fingerpart ) )=> cautiousfingerlist fingershapelist fingercrossinglist ( ( thumbspecial )=> thumbspecial )? | ( ( hsfingeritem )* ( thumbbetweendefault | thumbextra ) )=> fingerlist fingershapelist fingercrossinglist ( thumbbetweendefault | thumbextra ) | fingerlist fingershapelist fingercrossinglist )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA25_1 = input.LA(1);
var index25_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred10_Ham4Parser()) ) {s = 65;}
else if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA25_2 = input.LA(1);
var index25_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred10_Ham4Parser()) ) {s = 65;}
else if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_2);
if ( s>=0 ) return s;
break;
case 2 : 
var LA25_3 = input.LA(1);
var index25_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
input.seek(index25_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA25_4 = input.LA(1);
var index25_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (this.synpred13_Ham4Parser()) ) {s = 67;}
else if ( (true) ) {s = 68;}
input.seek(index25_4);
if ( s>=0 ) return s;
break;
case 4 : 
var LA25_5 = input.LA(1);
var index25_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_5);
if ( s>=0 ) return s;
break;
case 5 : 
var LA25_6 = input.LA(1);
var index25_6 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_6);
if ( s>=0 ) return s;
break;
case 6 : 
var LA25_7 = input.LA(1);
var index25_7 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_7);
if ( s>=0 ) return s;
break;
case 7 : 
var LA25_8 = input.LA(1);
var index25_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_8);
if ( s>=0 ) return s;
break;
case 8 : 
var LA25_9 = input.LA(1);
var index25_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_9);
if ( s>=0 ) return s;
break;
case 9 : 
var LA25_10 = input.LA(1);
var index25_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_10);
if ( s>=0 ) return s;
break;
case 10 : 
var LA25_11 = input.LA(1);
var index25_11 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_11);
if ( s>=0 ) return s;
break;
case 11 : 
var LA25_12 = input.LA(1);
var index25_12 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_12);
if ( s>=0 ) return s;
break;
case 12 : 
var LA25_13 = input.LA(1);
var index25_13 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_13);
if ( s>=0 ) return s;
break;
case 13 : 
var LA25_14 = input.LA(1);
var index25_14 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_14);
if ( s>=0 ) return s;
break;
case 14 : 
var LA25_15 = input.LA(1);
var index25_15 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_15);
if ( s>=0 ) return s;
break;
case 15 : 
var LA25_16 = input.LA(1);
var index25_16 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_16);
if ( s>=0 ) return s;
break;
case 16 : 
var LA25_17 = input.LA(1);
var index25_17 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_17);
if ( s>=0 ) return s;
break;
case 17 : 
var LA25_18 = input.LA(1);
var index25_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_18);
if ( s>=0 ) return s;
break;
case 18 : 
var LA25_19 = input.LA(1);
var index25_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_19);
if ( s>=0 ) return s;
break;
case 19 : 
var LA25_20 = input.LA(1);
var index25_20 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_20);
if ( s>=0 ) return s;
break;
case 20 : 
var LA25_21 = input.LA(1);
var index25_21 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_21);
if ( s>=0 ) return s;
break;
case 21 : 
var LA25_22 = input.LA(1);
var index25_22 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_22);
if ( s>=0 ) return s;
break;
case 22 : 
var LA25_23 = input.LA(1);
var index25_23 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_23);
if ( s>=0 ) return s;
break;
case 23 : 
var LA25_24 = input.LA(1);
var index25_24 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_24);
if ( s>=0 ) return s;
break;
case 24 : 
var LA25_25 = input.LA(1);
var index25_25 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_25);
if ( s>=0 ) return s;
break;
case 25 : 
var LA25_26 = input.LA(1);
var index25_26 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_26);
if ( s>=0 ) return s;
break;
case 26 : 
var LA25_27 = input.LA(1);
var index25_27 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_27);
if ( s>=0 ) return s;
break;
case 27 : 
var LA25_28 = input.LA(1);
var index25_28 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_28);
if ( s>=0 ) return s;
break;
case 28 : 
var LA25_29 = input.LA(1);
var index25_29 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_29);
if ( s>=0 ) return s;
break;
case 29 : 
var LA25_30 = input.LA(1);
var index25_30 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_30);
if ( s>=0 ) return s;
break;
case 30 : 
var LA25_31 = input.LA(1);
var index25_31 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_31);
if ( s>=0 ) return s;
break;
case 31 : 
var LA25_32 = input.LA(1);
var index25_32 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_32);
if ( s>=0 ) return s;
break;
case 32 : 
var LA25_33 = input.LA(1);
var index25_33 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_33);
if ( s>=0 ) return s;
break;
case 33 : 
var LA25_34 = input.LA(1);
var index25_34 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_34);
if ( s>=0 ) return s;
break;
case 34 : 
var LA25_35 = input.LA(1);
var index25_35 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_35);
if ( s>=0 ) return s;
break;
case 35 : 
var LA25_36 = input.LA(1);
var index25_36 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_36);
if ( s>=0 ) return s;
break;
case 36 : 
var LA25_37 = input.LA(1);
var index25_37 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_37);
if ( s>=0 ) return s;
break;
case 37 : 
var LA25_38 = input.LA(1);
var index25_38 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_38);
if ( s>=0 ) return s;
break;
case 38 : 
var LA25_39 = input.LA(1);
var index25_39 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_39);
if ( s>=0 ) return s;
break;
case 39 : 
var LA25_40 = input.LA(1);
var index25_40 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_40);
if ( s>=0 ) return s;
break;
case 40 : 
var LA25_41 = input.LA(1);
var index25_41 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_41);
if ( s>=0 ) return s;
break;
case 41 : 
var LA25_42 = input.LA(1);
var index25_42 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_42);
if ( s>=0 ) return s;
break;
case 42 : 
var LA25_43 = input.LA(1);
var index25_43 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_43);
if ( s>=0 ) return s;
break;
case 43 : 
var LA25_44 = input.LA(1);
var index25_44 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_44);
if ( s>=0 ) return s;
break;
case 44 : 
var LA25_45 = input.LA(1);
var index25_45 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_45);
if ( s>=0 ) return s;
break;
case 45 : 
var LA25_46 = input.LA(1);
var index25_46 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_46);
if ( s>=0 ) return s;
break;
case 46 : 
var LA25_47 = input.LA(1);
var index25_47 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_47);
if ( s>=0 ) return s;
break;
case 47 : 
var LA25_48 = input.LA(1);
var index25_48 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_48);
if ( s>=0 ) return s;
break;
case 48 : 
var LA25_49 = input.LA(1);
var index25_49 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_49);
if ( s>=0 ) return s;
break;
case 49 : 
var LA25_50 = input.LA(1);
var index25_50 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_50);
if ( s>=0 ) return s;
break;
case 50 : 
var LA25_51 = input.LA(1);
var index25_51 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_51);
if ( s>=0 ) return s;
break;
case 51 : 
var LA25_52 = input.LA(1);
var index25_52 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_52);
if ( s>=0 ) return s;
break;
case 52 : 
var LA25_53 = input.LA(1);
var index25_53 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_53);
if ( s>=0 ) return s;
break;
case 53 : 
var LA25_54 = input.LA(1);
var index25_54 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_54);
if ( s>=0 ) return s;
break;
case 54 : 
var LA25_55 = input.LA(1);
var index25_55 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_55);
if ( s>=0 ) return s;
break;
case 55 : 
var LA25_56 = input.LA(1);
var index25_56 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_56);
if ( s>=0 ) return s;
break;
case 56 : 
var LA25_57 = input.LA(1);
var index25_57 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_57);
if ( s>=0 ) return s;
break;
case 57 : 
var LA25_58 = input.LA(1);
var index25_58 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_58);
if ( s>=0 ) return s;
break;
case 58 : 
var LA25_59 = input.LA(1);
var index25_59 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_59);
if ( s>=0 ) return s;
break;
case 59 : 
var LA25_60 = input.LA(1);
var index25_60 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_60);
if ( s>=0 ) return s;
break;
case 60 : 
var LA25_61 = input.LA(1);
var index25_61 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_61);
if ( s>=0 ) return s;
break;
case 61 : 
var LA25_62 = input.LA(1);
var index25_62 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_62);
if ( s>=0 ) return s;
break;
case 62 : 
var LA25_63 = input.LA(1);
var index25_63 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_63);
if ( s>=0 ) return s;
break;
case 63 : 
var LA25_64 = input.LA(1);
var index25_64 = input.index();
input.rewind();
s = -1;
if ( (this.synpred11_Ham4Parser()) ) {s = 66;}
else if ( (true) ) {s = 68;}
input.seek(index25_64);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 25, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA23_eotS:
"\u0041\uffff",
DFA23_eofS:
"\u0001\u0005\u0040\uffff",
DFA23_minS:
"\u0001\u000f\u0001\u0000\u0001\uffff\u0002\u0000\u003c\uffff",
DFA23_maxS:
"\u0001\u00d9\u0001\u0000\u0001\uffff\u0002\u0000\u003c\uffff",
DFA23_acceptS:
"\u0002\uffff\u0001\u0001\u0002\uffff\u0001\u0002\u003b\uffff",
DFA23_specialS:
"\u0001\u0000\u0001\u0001\u0001\uffff\u0001\u0002\u0001\u0003\u003c"+
"\uffff}>",
DFA23_transitionS: [
"\u0001\u0005\u0021\uffff\u001e\u0005\u0004\uffff\u001e\u0005"+
"\u0001\u0003\u0004\u0001\u0002\u0005\u0001\u0002\u0006\u0004"+
"\u0006\uffff\u0015\u0005\u0008\uffff\u0009\u0005\u0002\uffff"+
"\u0011\u0005\u0009\uffff\u0013\u0005",
"\u0001\uffff",
"",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA23_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_eotS),
DFA23_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_eofS),
DFA23_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA23_minS),
DFA23_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA23_maxS),
DFA23_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_acceptS),
DFA23_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_specialS),
DFA23_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA23_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA23_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA23 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 23;
this.eot = Ham4Parser.DFA23_eot;
this.eof = Ham4Parser.DFA23_eof;
this.min = Ham4Parser.DFA23_min;
this.max = Ham4Parser.DFA23_max;
this.accept = Ham4Parser.DFA23_accept;
this.special = Ham4Parser.DFA23_special;
this.transition = Ham4Parser.DFA23_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA23, org.antlr.runtime.DFA, {
getDescription: function() {
return "832:13: ( ( thumbspecial )=> thumbspecial )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA23_0 = input.LA(1);
var index23_0 = input.index();
input.rewind();
s = -1;
if ( ((LA23_0>=HamIndexfinger && LA23_0<=HamPinky)) ) {s = 1;}
else if ( (LA23_0==HamBetween) && (this.synpred12_Ham4Parser())) {s = 2;}
else if ( (LA23_0==HamThumb) ) {s = 3;}
else if ( ((LA23_0>=HamFingertip && LA23_0<=HamFingerside)) ) {s = 4;}
else if ( (LA23_0==EOF||LA23_0==HamPlus||(LA23_0>=HamExtfingeru && LA23_0<=HamReplace)||(LA23_0>=HamTongue && LA23_0<=HamHandback)||(LA23_0>=HamThumbside && LA23_0<=HamPinkyside)||(LA23_0>=HamNomotion && LA23_0<=HamMovex)||(LA23_0>=HamFingerplay && LA23_0<=HamCircler)||(LA23_0>=HamClose && LA23_0<=HamRepeatreverse)||(LA23_0>=HamNodding && LA23_0<=HamCircleuo)) ) {s = 5;}
input.seek(index23_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA23_1 = input.LA(1);
var index23_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA23_3 = input.LA(1);
var index23_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA23_4 = input.LA(1);
var index23_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred12_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 5;}
input.seek(index23_4);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 23, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA26_eotS:
"\u0042\uffff",
DFA26_eofS:
"\u0001\u0002\u0041\uffff",
DFA26_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA26_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA26_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA26_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA26_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u0025\u0002"+
"\u0001\u0001\u0006\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA26_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_eotS),
DFA26_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_eofS),
DFA26_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA26_minS),
DFA26_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA26_maxS),
DFA26_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_acceptS),
DFA26_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_specialS),
DFA26_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA26_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA26_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA26 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 26;
this.eot = Ham4Parser.DFA26_eot;
this.eof = Ham4Parser.DFA26_eof;
this.min = Ham4Parser.DFA26_min;
this.max = Ham4Parser.DFA26_max;
this.accept = Ham4Parser.DFA26_accept;
this.special = Ham4Parser.DFA26_special;
this.transition = Ham4Parser.DFA26_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA26, org.antlr.runtime.DFA, {
getDescription: function() {
return "876:9: ( ( HamBetween handshapeclass )=> HamBetween basichandshape )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA26_1 = input.LA(1);
var index26_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred14_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index26_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 26, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA33_eotS:
"\u0042\uffff",
DFA33_eofS:
"\u0001\u0002\u0041\uffff",
DFA33_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA33_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA33_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA33_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA33_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u001f\u0002"+
"\u0004\u0001\u0009\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA33_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_eotS),
DFA33_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_eofS),
DFA33_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA33_minS),
DFA33_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA33_maxS),
DFA33_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_acceptS),
DFA33_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_specialS),
DFA33_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA33_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA33_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA33 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 33;
this.eot = Ham4Parser.DFA33_eot;
this.eof = Ham4Parser.DFA33_eof;
this.min = Ham4Parser.DFA33_min;
this.max = Ham4Parser.DFA33_max;
this.accept = Ham4Parser.DFA33_accept;
this.special = Ham4Parser.DFA33_special;
this.transition = Ham4Parser.DFA33_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA33, org.antlr.runtime.DFA, {
getDescription: function() {
return "985:9: ( ( hsfingeritem )=> hsfingeritem recfingerlist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA33_1 = input.LA(1);
var index33_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred15_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index33_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 33, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA34_eotS:
"\u0042\uffff",
DFA34_eofS:
"\u0001\u0002\u0041\uffff",
DFA34_minS:
"\u0001\u000f\u0001\u0000\u0040\uffff",
DFA34_maxS:
"\u0001\u00d9\u0001\u0000\u0040\uffff",
DFA34_acceptS:
"\u0002\uffff\u0001\u0002\u003e\uffff\u0001\u0001",
DFA34_specialS:
"\u0001\uffff\u0001\u0000\u0040\uffff}>",
DFA34_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u001f\u0002"+
"\u0004\u0001\u0009\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0009\u0002\u0002\uffff\u0011\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA34_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_eotS),
DFA34_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_eofS),
DFA34_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA34_minS),
DFA34_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA34_maxS),
DFA34_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_acceptS),
DFA34_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_specialS),
DFA34_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA34_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA34_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA34 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 34;
this.eot = Ham4Parser.DFA34_eot;
this.eof = Ham4Parser.DFA34_eof;
this.min = Ham4Parser.DFA34_min;
this.max = Ham4Parser.DFA34_max;
this.accept = Ham4Parser.DFA34_accept;
this.special = Ham4Parser.DFA34_special;
this.transition = Ham4Parser.DFA34_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA34, org.antlr.runtime.DFA, {
getDescription: function() {
return "1033:9: ( ( hsfingeritem digit )=> hsfingeritem reccautiousfingerlist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA34_1 = input.LA(1);
var index34_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred16_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 2;}
input.seek(index34_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 34, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA35_eotS:
"\u0042\uffff",
DFA35_eofS:
"\u0001\u0003\u0041\uffff",
DFA35_minS:
"\u0001\u000f\u0002\u0000\u003f\uffff",
DFA35_maxS:
"\u0001\u00d9\u0002\u0000\u003f\uffff",
DFA35_acceptS:
"\u0003\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA35_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u003f\uffff}>",
DFA35_transitionS: [
"\u0001\u0003\u0021\uffff\u001e\u0003\u0004\uffff\u001e\u0003"+
"\u0001\u0001\u0004\u0002\u0009\u0003\u0006\uffff\u0015\u0003"+
"\u0008\uffff\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff"+
"\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA35_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_eotS),
DFA35_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_eofS),
DFA35_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA35_minS),
DFA35_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA35_maxS),
DFA35_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_acceptS),
DFA35_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_specialS),
DFA35_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA35_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA35_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA35 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 35;
this.eot = Ham4Parser.DFA35_eot;
this.eof = Ham4Parser.DFA35_eof;
this.min = Ham4Parser.DFA35_min;
this.max = Ham4Parser.DFA35_max;
this.accept = Ham4Parser.DFA35_accept;
this.special = Ham4Parser.DFA35_special;
this.transition = Ham4Parser.DFA35_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA35, org.antlr.runtime.DFA, {
getDescription: function() {
return "1081:9: ( ( fingershape )=> fingershape recfingershapelist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA35_1 = input.LA(1);
var index35_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred17_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index35_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA35_2 = input.LA(1);
var index35_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred17_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index35_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 35, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA36_eotS:
"\u0042\uffff",
DFA36_eofS:
"\u0001\u0003\u0041\uffff",
DFA36_minS:
"\u0001\u000f\u0002\u0000\u003f\uffff",
DFA36_maxS:
"\u0001\u00d9\u0002\u0000\u003f\uffff",
DFA36_acceptS:
"\u0003\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA36_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u003f\uffff}>",
DFA36_transitionS: [
"\u0001\u0003\u0021\uffff\u001e\u0003\u0004\uffff\u001e\u0003"+
"\u0001\u0001\u0004\u0002\u0009\u0003\u0006\uffff\u0015\u0003"+
"\u0008\uffff\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff"+
"\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA36_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_eotS),
DFA36_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_eofS),
DFA36_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA36_minS),
DFA36_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA36_maxS),
DFA36_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_acceptS),
DFA36_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_specialS),
DFA36_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA36_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA36_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA36 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 36;
this.eot = Ham4Parser.DFA36_eot;
this.eof = Ham4Parser.DFA36_eof;
this.min = Ham4Parser.DFA36_min;
this.max = Ham4Parser.DFA36_max;
this.accept = Ham4Parser.DFA36_accept;
this.special = Ham4Parser.DFA36_special;
this.transition = Ham4Parser.DFA36_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA36, org.antlr.runtime.DFA, {
getDescription: function() {
return "1129:9: ( ( fingercrossing )=> fingercrossing recfingercrossinglist )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA36_1 = input.LA(1);
var index36_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred18_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index36_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA36_2 = input.LA(1);
var index36_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred18_Ham4Parser()) ) {s = 65;}
else if ( (true) ) {s = 3;}
input.seek(index36_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 36, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA49_eotS:
"\u001d\uffff",
DFA49_eofS:
"\u001d\uffff",
DFA49_minS:
"\u0001\u0043\u001c\uffff",
DFA49_maxS:
"\u0001\u00ba\u001c\uffff",
DFA49_acceptS:
"\u0001\uffff\u0001\u0001\u0017\uffff\u0001\u0002\u0003\uffff",
DFA49_specialS:
"\u001d\uffff}>",
DFA49_transitionS: [
"\u0003\u0001\u000d\uffff\u0025\u0001\u0001\uffff\u0006\u0001"+
"\u0024\uffff\u0001\u0019\u0009\uffff\u0004\u0019\u0009\uffff"+
"\u0001\u0019",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA49_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_eotS),
DFA49_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_eofS),
DFA49_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA49_minS),
DFA49_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA49_maxS),
DFA49_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_acceptS),
DFA49_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_specialS),
DFA49_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA49_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA49_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA49 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 49;
this.eot = Ham4Parser.DFA49_eot;
this.eof = Ham4Parser.DFA49_eof;
this.min = Ham4Parser.DFA49_min;
this.max = Ham4Parser.DFA49_max;
this.accept = Ham4Parser.DFA49_accept;
this.special = Ham4Parser.DFA49_special;
this.transition = Ham4Parser.DFA49_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA49, org.antlr.runtime.DFA, {
getDescription: function() {
return "1566:5: ( location1as2 | location2not1 )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA54_eotS:
"\u001a\uffff",
DFA54_eofS:
"\u001a\uffff",
DFA54_minS:
"\u0001\u0043\u0002\u0000\u0002\uffff\u0001\u0000\u0014\uffff",
DFA54_maxS:
"\u0001\u007e\u0002\u0000\u0002\uffff\u0001\u0000\u0014\uffff",
DFA54_acceptS:
"\u0003\uffff\u0002\u0002\u0001\uffff\u0001\u0003\u0012\uffff\u0001"+
"\u0001",
DFA54_specialS:
"\u0001\u0000\u0001\u0001\u0001\u0002\u0002\uffff\u0001\u0003\u0014"+
"\uffff}>",
DFA54_transitionS: [
"\u0003\u0006\u000d\uffff\u0013\u0006\u0002\u0005\u0004\u0006"+
"\u0005\u0003\u0001\u0001\u0004\u0002\u0002\u0003\u0001\uffff"+
"\u0006\u0004",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA54_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_eotS),
DFA54_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_eofS),
DFA54_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA54_minS),
DFA54_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA54_maxS),
DFA54_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_acceptS),
DFA54_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_specialS),
DFA54_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA54_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA54_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA54 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 54;
this.eot = Ham4Parser.DFA54_eot;
this.eof = Ham4Parser.DFA54_eof;
this.min = Ham4Parser.DFA54_min;
this.max = Ham4Parser.DFA54_max;
this.accept = Ham4Parser.DFA54_accept;
this.special = Ham4Parser.DFA54_special;
this.transition = Ham4Parser.DFA54_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA54, org.antlr.runtime.DFA, {
getDescription: function() {
return "1674:5: ( ( locationindexuse )=> locationindexuse | ( levelhand )=> locationhand | locationbodyarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA54_0 = input.LA(1);
var index54_0 = input.index();
input.rewind();
s = -1;
if ( (LA54_0==HamThumb) ) {s = 1;}
else if ( ((LA54_0>=HamIndexfinger && LA54_0<=HamPinky)) ) {s = 2;}
else if ( ((LA54_0>=HamWristback && LA54_0<=HamHandback)||(LA54_0>=HamThumbside && LA54_0<=HamPinkyside)) && (this.synpred21_Ham4Parser())) {s = 3;}
else if ( ((LA54_0>=HamFingertip && LA54_0<=HamFingerside)) && (this.synpred21_Ham4Parser())) {s = 4;}
else if ( ((LA54_0>=HamLrbeside && LA54_0<=HamLrat)) ) {s = 5;}
else if ( ((LA54_0>=HamEarlobe && LA54_0<=HamShouldertop)||(LA54_0>=HamTongue && LA54_0<=HamBelowstomach)||(LA54_0>=HamUpperarm && LA54_0<=HamLowerarm)) ) {s = 6;}
input.seek(index54_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA54_1 = input.LA(1);
var index54_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred20_Ham4Parser()) ) {s = 25;}
else if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
input.seek(index54_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA54_2 = input.LA(1);
var index54_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred20_Ham4Parser()) ) {s = 25;}
else if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
input.seek(index54_2);
if ( s>=0 ) return s;
break;
case 3 : 
var LA54_5 = input.LA(1);
var index54_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred21_Ham4Parser()) ) {s = 4;}
else if ( (true) ) {s = 6;}
input.seek(index54_5);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 54, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA56_eotS:
"\u0015\uffff",
DFA56_eofS:
"\u0015\uffff",
DFA56_minS:
"\u0001\u0043\u0012\uffff\u0001\u0000\u0001\uffff",
DFA56_maxS:
"\u0001\u006b\u0012\uffff\u0001\u0000\u0001\uffff",
DFA56_acceptS:
"\u0001\uffff\u0001\u0001\u0011\u0002\u0001\uffff\u0001\u0003",
DFA56_specialS:
"\u0001\u0000\u0012\uffff\u0001\u0001\u0001\uffff}>",
DFA56_transitionS: [
"\u0001\u0012\u0001\u0007\u0001\u000d\u000d\uffff\u0001\u0008"+
"\u0001\u0009\u0001\u0010\u0001\u0001\u0001\u0002\u0001\u0003"+
"\u0001\u0004\u0001\u0005\u0001\u0009\u0001\u0006\u0002\u0012"+
"\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000e"+
"\u0001\u000f\u0001\u0011\u0002\u0013\u0004\u0014",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA56_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_eotS),
DFA56_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_eofS),
DFA56_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA56_minS),
DFA56_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA56_maxS),
DFA56_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_acceptS),
DFA56_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_specialS),
DFA56_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA56_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA56_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA56 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 56;
this.eot = Ham4Parser.DFA56_eot;
this.eof = Ham4Parser.DFA56_eof;
this.min = Ham4Parser.DFA56_min;
this.max = Ham4Parser.DFA56_max;
this.accept = Ham4Parser.DFA56_accept;
this.special = Ham4Parser.DFA56_special;
this.transition = Ham4Parser.DFA56_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA56, org.antlr.runtime.DFA, {
getDescription: function() {
return "1756:5: ( HamNeutralspace ( HamArmextended )? | ( levelbody )=> locationbody | locationarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA56_0 = input.LA(1);
var index56_0 = input.index();
input.rewind();
s = -1;
if ( (LA56_0==HamNeutralspace) ) {s = 1;}
else if ( (LA56_0==HamHead) && (this.synpred22_Ham4Parser())) {s = 2;}
else if ( (LA56_0==HamHeadtop) && (this.synpred22_Ham4Parser())) {s = 3;}
else if ( (LA56_0==HamForehead) && (this.synpred22_Ham4Parser())) {s = 4;}
else if ( (LA56_0==HamEyebrows) && (this.synpred22_Ham4Parser())) {s = 5;}
else if ( (LA56_0==HamNose) && (this.synpred22_Ham4Parser())) {s = 6;}
else if ( (LA56_0==HamNostrils) && (this.synpred22_Ham4Parser())) {s = 7;}
else if ( (LA56_0==HamTongue) && (this.synpred22_Ham4Parser())) {s = 8;}
else if ( (LA56_0==HamTeeth||LA56_0==HamEyes||LA56_0==HamLips) && (this.synpred22_Ham4Parser())) {s = 9;}
else if ( (LA56_0==HamChin) && (this.synpred22_Ham4Parser())) {s = 10;}
else if ( (LA56_0==HamUnderchin) && (this.synpred22_Ham4Parser())) {s = 11;}
else if ( (LA56_0==HamNeck) && (this.synpred22_Ham4Parser())) {s = 12;}
else if ( (LA56_0==HamShouldertop) && (this.synpred22_Ham4Parser())) {s = 13;}
else if ( (LA56_0==HamShoulders) && (this.synpred22_Ham4Parser())) {s = 14;}
else if ( (LA56_0==HamChest) && (this.synpred22_Ham4Parser())) {s = 15;}
else if ( (LA56_0==HamStomach) && (this.synpred22_Ham4Parser())) {s = 16;}
else if ( (LA56_0==HamBelowstomach) && (this.synpred22_Ham4Parser())) {s = 17;}
else if ( (LA56_0==HamEarlobe||(LA56_0>=HamEar && LA56_0<=HamCheek)) && (this.synpred22_Ham4Parser())) {s = 18;}
else if ( ((LA56_0>=HamLrbeside && LA56_0<=HamLrat)) ) {s = 19;}
else if ( ((LA56_0>=HamUpperarm && LA56_0<=HamLowerarm)) ) {s = 20;}
input.seek(index56_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA56_19 = input.LA(1);
var index56_19 = input.index();
input.rewind();
s = -1;
if ( (this.synpred22_Ham4Parser()) ) {s = 18;}
else if ( (true) ) {s = 20;}
input.seek(index56_19);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 56, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA57_eotS:
"\u0016\uffff",
DFA57_eofS:
"\u0001\u0002\u0015\uffff",
DFA57_minS:
"\u0001\u000f\u0015\uffff",
DFA57_maxS:
"\u0001\u00d9\u0015\uffff",
DFA57_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0013\uffff",
DFA57_specialS:
"\u0016\uffff}>",
DFA57_transitionS: [
"\u0001\u0002\u003e\uffff\u0002\u0002\u0001\u0001\u0034\uffff"+
"\u0015\u0002\u0001\uffff\u0001\u0002\u0006\uffff\u0009\u0002"+
"\u0002\uffff\u0002\u0002\u0007\uffff\u0008\u0002\u0009\uffff"+
"\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA57_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_eotS),
DFA57_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_eofS),
DFA57_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA57_minS),
DFA57_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA57_maxS),
DFA57_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_acceptS),
DFA57_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_specialS),
DFA57_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA57_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA57_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA57 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 57;
this.eot = Ham4Parser.DFA57_eot;
this.eof = Ham4Parser.DFA57_eof;
this.min = Ham4Parser.DFA57_min;
this.max = Ham4Parser.DFA57_max;
this.accept = Ham4Parser.DFA57_accept;
this.special = Ham4Parser.DFA57_special;
this.transition = Ham4Parser.DFA57_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA57, org.antlr.runtime.DFA, {
getDescription: function() {
return "1788:9: ( HamBehind )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA58_eotS:
"\u0015\uffff",
DFA58_eofS:
"\u0001\u0004\u0014\uffff",
DFA58_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA58_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA58_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA58_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA58_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0001\u0002\u0035\uffff"+
"\u0015\u0004\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004"+
"\u0002\uffff\u0002\u0001\u0007\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA58_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_eotS),
DFA58_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_eofS),
DFA58_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA58_minS),
DFA58_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA58_maxS),
DFA58_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_acceptS),
DFA58_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_specialS),
DFA58_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA58_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA58_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA58 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 58;
this.eot = Ham4Parser.DFA58_eot;
this.eof = Ham4Parser.DFA58_eof;
this.min = Ham4Parser.DFA58_min;
this.max = Ham4Parser.DFA58_max;
this.accept = Ham4Parser.DFA58_accept;
this.special = Ham4Parser.DFA58_special;
this.transition = Ham4Parser.DFA58_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA58, org.antlr.runtime.DFA, {
getDescription: function() {
return "1789:9: ( ( contactbody )=> contactbody )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA58_0 = input.LA(1);
var index58_0 = input.index();
input.rewind();
s = -1;
if ( ((LA58_0>=HamClose && LA58_0<=HamTouch)) && (this.synpred23_Ham4Parser())) {s = 1;}
else if ( (LA58_0==HamArmextended) && (this.synpred23_Ham4Parser())) {s = 2;}
else if ( (LA58_0==HamSeqbegin) ) {s = 3;}
else if ( (LA58_0==EOF||LA58_0==HamPlus||LA58_0==HamReplace||(LA58_0>=HamNomotion && LA58_0<=HamMovex)||LA58_0==HamLargemod||(LA58_0>=HamFingerplay && LA58_0<=HamCircler)||(LA58_0>=HamRepeatfromstart && LA58_0<=HamRepeatcontinueseveral)||(LA58_0>=HamSeqend && LA58_0<=HamRepeatreverse)||(LA58_0>=HamNodding && LA58_0<=HamCircleuo)) ) {s = 4;}
input.seek(index58_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA58_3 = input.LA(1);
var index58_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred23_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index58_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 58, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA59_eotS:
"\u0015\uffff",
DFA59_eofS:
"\u0001\u0004\u0014\uffff",
DFA59_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA59_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA59_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA59_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA59_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0036\uffff\u0015\u0004"+
"\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004\u0002\uffff"+
"\u0002\u0001\u0002\u0002\u0005\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA59_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_eotS),
DFA59_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_eofS),
DFA59_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA59_minS),
DFA59_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA59_maxS),
DFA59_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_acceptS),
DFA59_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_specialS),
DFA59_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA59_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA59_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA59 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 59;
this.eot = Ham4Parser.DFA59_eot;
this.eof = Ham4Parser.DFA59_eof;
this.min = Ham4Parser.DFA59_min;
this.max = Ham4Parser.DFA59_max;
this.accept = Ham4Parser.DFA59_accept;
this.special = Ham4Parser.DFA59_special;
this.transition = Ham4Parser.DFA59_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA59, org.antlr.runtime.DFA, {
getDescription: function() {
return "1812:9: ( ( contacthand )=> contacthand )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA59_0 = input.LA(1);
var index59_0 = input.index();
input.rewind();
s = -1;
if ( ((LA59_0>=HamClose && LA59_0<=HamTouch)) && (this.synpred24_Ham4Parser())) {s = 1;}
else if ( ((LA59_0>=HamInterlock && LA59_0<=HamCross)) && (this.synpred24_Ham4Parser())) {s = 2;}
else if ( (LA59_0==HamSeqbegin) ) {s = 3;}
else if ( (LA59_0==EOF||LA59_0==HamPlus||LA59_0==HamReplace||(LA59_0>=HamNomotion && LA59_0<=HamMovex)||LA59_0==HamLargemod||(LA59_0>=HamFingerplay && LA59_0<=HamCircler)||(LA59_0>=HamRepeatfromstart && LA59_0<=HamRepeatcontinueseveral)||(LA59_0>=HamSeqend && LA59_0<=HamRepeatreverse)||(LA59_0>=HamNodding && LA59_0<=HamCircleuo)) ) {s = 4;}
input.seek(index59_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA59_3 = input.LA(1);
var index59_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred24_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index59_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 59, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA60_eotS:
"\u0016\uffff",
DFA60_eofS:
"\u0001\u0002\u0015\uffff",
DFA60_minS:
"\u0001\u000f\u0015\uffff",
DFA60_maxS:
"\u0001\u00d9\u0015\uffff",
DFA60_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0013\uffff",
DFA60_specialS:
"\u0016\uffff}>",
DFA60_transitionS: [
"\u0001\u0002\u003e\uffff\u0002\u0002\u0001\u0001\u0034\uffff"+
"\u0015\u0002\u0001\uffff\u0001\u0002\u0006\uffff\u0009\u0002"+
"\u0002\uffff\u0002\u0002\u0007\uffff\u0008\u0002\u0009\uffff"+
"\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA60_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_eotS),
DFA60_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_eofS),
DFA60_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA60_minS),
DFA60_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA60_maxS),
DFA60_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_acceptS),
DFA60_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_specialS),
DFA60_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA60_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA60_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA60 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 60;
this.eot = Ham4Parser.DFA60_eot;
this.eof = Ham4Parser.DFA60_eof;
this.min = Ham4Parser.DFA60_min;
this.max = Ham4Parser.DFA60_max;
this.accept = Ham4Parser.DFA60_accept;
this.special = Ham4Parser.DFA60_special;
this.transition = Ham4Parser.DFA60_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA60, org.antlr.runtime.DFA, {
getDescription: function() {
return "1836:9: ( HamBehind )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA61_eotS:
"\u0015\uffff",
DFA61_eofS:
"\u0001\u0004\u0014\uffff",
DFA61_minS:
"\u0001\u000f\u0002\uffff\u0001\u0000\u0011\uffff",
DFA61_maxS:
"\u0001\u00d9\u0002\uffff\u0001\u0000\u0011\uffff",
DFA61_acceptS:
"\u0001\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0010\uffff",
DFA61_specialS:
"\u0001\u0000\u0002\uffff\u0001\u0001\u0011\uffff}>",
DFA61_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0001\u0002\u0035\uffff"+
"\u0015\u0004\u0001\uffff\u0001\u0004\u0006\uffff\u0009\u0004"+
"\u0002\uffff\u0002\u0001\u0007\uffff\u0004\u0004\u0001\u0003"+
"\u0003\u0004\u0009\uffff\u0013\u0004",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA61_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_eotS),
DFA61_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_eofS),
DFA61_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA61_minS),
DFA61_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA61_maxS),
DFA61_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_acceptS),
DFA61_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_specialS),
DFA61_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA61_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA61_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA61 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 61;
this.eot = Ham4Parser.DFA61_eot;
this.eof = Ham4Parser.DFA61_eof;
this.min = Ham4Parser.DFA61_min;
this.max = Ham4Parser.DFA61_max;
this.accept = Ham4Parser.DFA61_accept;
this.special = Ham4Parser.DFA61_special;
this.transition = Ham4Parser.DFA61_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA61, org.antlr.runtime.DFA, {
getDescription: function() {
return "1837:9: ( ( contactbody )=> contactbody )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA61_0 = input.LA(1);
var index61_0 = input.index();
input.rewind();
s = -1;
if ( ((LA61_0>=HamClose && LA61_0<=HamTouch)) && (this.synpred25_Ham4Parser())) {s = 1;}
else if ( (LA61_0==HamArmextended) && (this.synpred25_Ham4Parser())) {s = 2;}
else if ( (LA61_0==HamSeqbegin) ) {s = 3;}
else if ( (LA61_0==EOF||LA61_0==HamPlus||LA61_0==HamReplace||(LA61_0>=HamNomotion && LA61_0<=HamMovex)||LA61_0==HamLargemod||(LA61_0>=HamFingerplay && LA61_0<=HamCircler)||(LA61_0>=HamRepeatfromstart && LA61_0<=HamRepeatcontinueseveral)||(LA61_0>=HamSeqend && LA61_0<=HamRepeatreverse)||(LA61_0>=HamNodding && LA61_0<=HamCircleuo)) ) {s = 4;}
input.seek(index61_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA61_3 = input.LA(1);
var index61_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred25_Ham4Parser()) ) {s = 2;}
else if ( (true) ) {s = 4;}
input.seek(index61_3);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 61, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA92_eotS:
"\u000d\uffff",
DFA92_eofS:
"\u0001\u000b\u000c\uffff",
DFA92_minS:
"\u0001\u000f\u000c\uffff",
DFA92_maxS:
"\u0001\u00d9\u000c\uffff",
DFA92_acceptS:
"\u0001\uffff\u0001\u0001\u0009\uffff\u0001\u0002\u0001\uffff",
DFA92_specialS:
"\u000d\uffff}>",
DFA92_transitionS: [
"\u0001\u000b\u003e\uffff\u0001\u0001\u0036\uffff\u0015\u0001"+
"\u0008\uffff\u0002\u0001\u0001\uffff\u0006\u0001\u000f\uffff"+
"\u0001\u0001\u000c\uffff\u0006\u0001\u0001\uffff\u000c\u0001",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA92_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_eotS),
DFA92_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_eofS),
DFA92_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA92_minS),
DFA92_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA92_maxS),
DFA92_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_acceptS),
DFA92_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_specialS),
DFA92_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA92_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA92_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA92 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 92;
this.eot = Ham4Parser.DFA92_eot;
this.eof = Ham4Parser.DFA92_eof;
this.min = Ham4Parser.DFA92_min;
this.max = Ham4Parser.DFA92_max;
this.accept = Ham4Parser.DFA92_accept;
this.special = Ham4Parser.DFA92_special;
this.transition = Ham4Parser.DFA92_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA92, org.antlr.runtime.DFA, {
getDescription: function() {
return "2347:9: ( action2t a2tlist )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA93_eotS:
"\u000d\uffff",
DFA93_eofS:
"\u0001\u000b\u000c\uffff",
DFA93_minS:
"\u0001\u000f\u000c\uffff",
DFA93_maxS:
"\u0001\u00d9\u000c\uffff",
DFA93_acceptS:
"\u0001\uffff\u0001\u0001\u0009\uffff\u0001\u0002\u0001\uffff",
DFA93_specialS:
"\u000d\uffff}>",
DFA93_transitionS: [
"\u0001\u000b\u003e\uffff\u0001\u0001\u0036\uffff\u0015\u0001"+
"\u0008\uffff\u0002\u0001\u0001\uffff\u0006\u0001\u000f\uffff"+
"\u0001\u0001\u000c\uffff\u0006\u0001\u0001\uffff\u000c\u0001",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA93_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_eotS),
DFA93_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_eofS),
DFA93_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA93_minS),
DFA93_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA93_maxS),
DFA93_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_acceptS),
DFA93_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_specialS),
DFA93_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA93_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA93_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA93 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 93;
this.eot = Ham4Parser.DFA93_eot;
this.eof = Ham4Parser.DFA93_eof;
this.min = Ham4Parser.DFA93_min;
this.max = Ham4Parser.DFA93_max;
this.accept = Ham4Parser.DFA93_accept;
this.special = Ham4Parser.DFA93_special;
this.transition = Ham4Parser.DFA93_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA93, org.antlr.runtime.DFA, {
getDescription: function() {
return "2372:9: ( action1t a1tlist )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA95_eotS:
"\u000e\uffff",
DFA95_eofS:
"\u000e\uffff",
DFA95_minS:
"\u0001\u004e\u000a\u0000\u0003\uffff",
DFA95_maxS:
"\u0001\u00d9\u000a\u0000\u0003\uffff",
DFA95_acceptS:
"\u000b\uffff\u0001\u0001\u0001\u0002\u0001\u0003",
DFA95_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001"+
"\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0003"+
"\uffff}>",
DFA95_transitionS: [
"\u0001\u0006\u0036\uffff\u0001\u0001\u0012\u0002\u0002\u0004"+
"\u0008\uffff\u0001\u0007\u0001\u0009\u0001\uffff\u0006\u0003"+
"\u000f\uffff\u0001\u0008\u000c\uffff\u0005\u0005\u0001\u000a"+
"\u0001\uffff\u000c\u0003",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA95_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_eotS),
DFA95_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_eofS),
DFA95_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA95_minS),
DFA95_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA95_maxS),
DFA95_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_acceptS),
DFA95_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_specialS),
DFA95_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA95_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA95_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA95 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 95;
this.eot = Ham4Parser.DFA95_eot;
this.eof = Ham4Parser.DFA95_eof;
this.min = Ham4Parser.DFA95_min;
this.max = Ham4Parser.DFA95_max;
this.accept = Ham4Parser.DFA95_accept;
this.special = Ham4Parser.DFA95_special;
this.transition = Ham4Parser.DFA95_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA95, org.antlr.runtime.DFA, {
getDescription: function() {
return "2425:5: ( ( action1 location2not1 )=> action1 location2not1 repetitionsoption -> ^( ACTION2T action1 location2not1 ( repetitionsoption )? ) | ( action1t )=> action1t -> ^( ACTION2T action1t ) | ( ( HamParbegin ( action1 )+ HamPlus ( action1 )+ HamParend location2 )=> splitaction2loc2 | ( HamParbegin ( action1t )+ HamPlus )=> splitaction2t | paraction2t | seqaction2t | seqfusedaction2t ) repetitionsoption -> ^( ACTION2T ( splitaction2loc2 )? ( splitaction2t )? ( paraction2t )? ( seqaction2t )? ( seqfusedaction2t )? ( repetitionsoption )? ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA95_1 = input.LA(1);
var index95_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA95_2 = input.LA(1);
var index95_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_2);
if ( s>=0 ) return s;
break;
case 2 : 
var LA95_3 = input.LA(1);
var index95_3 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_3);
if ( s>=0 ) return s;
break;
case 3 : 
var LA95_4 = input.LA(1);
var index95_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_4);
if ( s>=0 ) return s;
break;
case 4 : 
var LA95_5 = input.LA(1);
var index95_5 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_5);
if ( s>=0 ) return s;
break;
case 5 : 
var LA95_6 = input.LA(1);
var index95_6 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_6);
if ( s>=0 ) return s;
break;
case 6 : 
var LA95_7 = input.LA(1);
var index95_7 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
input.seek(index95_7);
if ( s>=0 ) return s;
break;
case 7 : 
var LA95_8 = input.LA(1);
var index95_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_8);
if ( s>=0 ) return s;
break;
case 8 : 
var LA95_9 = input.LA(1);
var index95_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_9);
if ( s>=0 ) return s;
break;
case 9 : 
var LA95_10 = input.LA(1);
var index95_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred27_Ham4Parser()) ) {s = 11;}
else if ( (this.synpred28_Ham4Parser()) ) {s = 12;}
else if ( (true) ) {s = 13;}
input.seek(index95_10);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 95, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA98_eotS:
"\u000e\uffff",
DFA98_eofS:
"\u000e\uffff",
DFA98_minS:
"\u0001\u004e\u0007\uffff\u0003\u0000\u0003\uffff",
DFA98_maxS:
"\u0001\u00d9\u0007\uffff\u0003\u0000\u0003\uffff",
DFA98_acceptS:
"\u0001\uffff\u0007\u0001\u0003\uffff\u0001\u0003\u0001\u0002\u0001"+
"\u0004",
DFA98_specialS:
"\u0001\u0000\u0007\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0003"+
"\uffff}>",
DFA98_transitionS: [
"\u0001\u0006\u0036\uffff\u0001\u0001\u0012\u0002\u0002\u0004"+
"\u0008\uffff\u0001\u0007\u0001\u0009\u0001\uffff\u0006\u0003"+
"\u000f\uffff\u0001\u0008\u000c\uffff\u0005\u0005\u0001\u000a"+
"\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA98_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_eotS),
DFA98_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_eofS),
DFA98_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA98_minS),
DFA98_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA98_maxS),
DFA98_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_acceptS),
DFA98_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_specialS),
DFA98_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA98_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA98_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA98 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 98;
this.eot = Ham4Parser.DFA98_eot;
this.eof = Ham4Parser.DFA98_eof;
this.min = Ham4Parser.DFA98_min;
this.max = Ham4Parser.DFA98_max;
this.accept = Ham4Parser.DFA98_accept;
this.special = Ham4Parser.DFA98_special;
this.transition = Ham4Parser.DFA98_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA98, org.antlr.runtime.DFA, {
getDescription: function() {
return "2503:9: ( ( action1 )=> ( action1 ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )? ) | paraction1t | seqnmoraction1t | seqfusedaction1t )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA98_0 = input.LA(1);
var index98_0 = input.index();
input.rewind();
s = -1;
if ( (LA98_0==HamNomotion) && (this.synpred31_Ham4Parser())) {s = 1;}
else if ( ((LA98_0>=HamMoveu && LA98_0<=HamMoveuo)) && (this.synpred31_Ham4Parser())) {s = 2;}
else if ( ((LA98_0>=HamCircleo && LA98_0<=HamCircler)||(LA98_0>=HamCircleul && LA98_0<=HamCircleuo)) && (this.synpred31_Ham4Parser())) {s = 3;}
else if ( ((LA98_0>=HamMovecross && LA98_0<=HamMovex)) && (this.synpred31_Ham4Parser())) {s = 4;}
else if ( ((LA98_0>=HamNodding && LA98_0<=HamStirccw)) && (this.synpred31_Ham4Parser())) {s = 5;}
else if ( (LA98_0==HamReplace) && (this.synpred31_Ham4Parser())) {s = 6;}
else if ( (LA98_0==HamFingerplay) && (this.synpred31_Ham4Parser())) {s = 7;}
else if ( (LA98_0==HamSeqbegin) ) {s = 8;}
else if ( (LA98_0==HamParbegin) ) {s = 9;}
else if ( (LA98_0==HamFusionbegin) ) {s = 10;}
input.seek(index98_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA98_8 = input.LA(1);
var index98_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 11;}
input.seek(index98_8);
if ( s>=0 ) return s;
break;
case 2 : 
var LA98_9 = input.LA(1);
var index98_9 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 12;}
input.seek(index98_9);
if ( s>=0 ) return s;
break;
case 3 : 
var LA98_10 = input.LA(1);
var index98_10 = input.index();
input.rewind();
s = -1;
if ( (this.synpred31_Ham4Parser()) ) {s = 7;}
else if ( (true) ) {s = 13;}
input.seek(index98_10);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 98, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA97_eotS:
"\u002c\uffff",
DFA97_eofS:
"\u0001\u001d\u002b\uffff",
DFA97_minS:
"\u0001\u000f\u0001\u0000\u0002\uffff\u0001\u0000\u0027\uffff",
DFA97_maxS:
"\u0001\u00d9\u0001\u0000\u0002\uffff\u0001\u0000\u0027\uffff",
DFA97_acceptS:
"\u0002\uffff\u0002\u0001\u0001\uffff\u0001\u0002\u0017\uffff\u0001"+
"\u0003\u000e\uffff",
DFA97_specialS:
"\u0001\u0000\u0001\u0001\u0002\uffff\u0001\u0002\u0027\uffff}>",
DFA97_transitionS: [
"\u0001\u001d\u0033\uffff\u0003\u0005\u0008\uffff\u0001\u001d"+
"\u0004\uffff\u0025\u0005\u0001\uffff\u0006\u0005\u0006\uffff"+
"\u0015\u001d\u0008\uffff\u0001\u001d\u0001\u0001\u0007\u001d"+
"\u0002\uffff\u0002\u0002\u0002\u0003\u0005\uffff\u0004\u001d"+
"\u0001\u0004\u0003\u001d\u0009\uffff\u0013\u001d",
"\u0001\uffff",
"",
"",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA97_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_eotS),
DFA97_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_eofS),
DFA97_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA97_minS),
DFA97_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA97_maxS),
DFA97_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_acceptS),
DFA97_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_specialS),
DFA97_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA97_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA97_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA97 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 97;
this.eot = Ham4Parser.DFA97_eot;
this.eof = Ham4Parser.DFA97_eof;
this.min = Ham4Parser.DFA97_min;
this.max = Ham4Parser.DFA97_max;
this.accept = Ham4Parser.DFA97_accept;
this.special = Ham4Parser.DFA97_special;
this.transition = Ham4Parser.DFA97_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA97, org.antlr.runtime.DFA, {
getDescription: function() {
return "2508:17: ( ( handconstellation )=> handconstellation | location1 ( HamLargemod )? )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA97_0 = input.LA(1);
var index97_0 = input.index();
input.rewind();
s = -1;
if ( (LA97_0==HamParbegin) ) {s = 1;}
else if ( ((LA97_0>=HamClose && LA97_0<=HamTouch)) && (this.synpred32_Ham4Parser())) {s = 2;}
else if ( ((LA97_0>=HamInterlock && LA97_0<=HamCross)) && (this.synpred32_Ham4Parser())) {s = 3;}
else if ( (LA97_0==HamSeqbegin) ) {s = 4;}
else if ( ((LA97_0>=HamEarlobe && LA97_0<=HamShouldertop)||(LA97_0>=HamTongue && LA97_0<=HamPinkyside)||(LA97_0>=HamFingertip && LA97_0<=HamFingerside)) ) {s = 5;}
else if ( (LA97_0==EOF||LA97_0==HamPlus||LA97_0==HamReplace||(LA97_0>=HamNomotion && LA97_0<=HamMovex)||LA97_0==HamFingerplay||(LA97_0>=HamParend && LA97_0<=HamCircler)||(LA97_0>=HamRepeatfromstart && LA97_0<=HamRepeatcontinueseveral)||(LA97_0>=HamSeqend && LA97_0<=HamRepeatreverse)||(LA97_0>=HamNodding && LA97_0<=HamCircleuo)) ) {s = 29;}
input.seek(index97_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA97_1 = input.LA(1);
var index97_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred32_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 29;}
input.seek(index97_1);
if ( s>=0 ) return s;
break;
case 2 : 
var LA97_4 = input.LA(1);
var index97_4 = input.index();
input.rewind();
s = -1;
if ( (this.synpred32_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 29;}
input.seek(index97_4);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 97, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA96_eotS:
"\u0013\uffff",
DFA96_eofS:
"\u0001\u0002\u0012\uffff",
DFA96_minS:
"\u0001\u000f\u0012\uffff",
DFA96_maxS:
"\u0001\u00d9\u0012\uffff",
DFA96_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0010\uffff",
DFA96_specialS:
"\u0013\uffff}>",
DFA96_transitionS: [
"\u0001\u0002\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0001\uffff\u0001\u0001\u0006\uffff\u0009\u0002\u000b\uffff"+
"\u0008\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA96_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_eotS),
DFA96_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_eofS),
DFA96_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA96_minS),
DFA96_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA96_maxS),
DFA96_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_acceptS),
DFA96_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_specialS),
DFA96_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA96_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA96_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA96 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 96;
this.eot = Ham4Parser.DFA96_eot;
this.eof = Ham4Parser.DFA96_eof;
this.min = Ham4Parser.DFA96_min;
this.max = Ham4Parser.DFA96_max;
this.accept = Ham4Parser.DFA96_accept;
this.special = Ham4Parser.DFA96_special;
this.transition = Ham4Parser.DFA96_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA96, org.antlr.runtime.DFA, {
getDescription: function() {
return "2514:21: ( HamLargemod )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA102_eotS:
"\u000d\uffff",
DFA102_eofS:
"\u000d\uffff",
DFA102_minS:
"\u0001\u004e\u0007\uffff\u0001\u0000\u0004\uffff",
DFA102_maxS:
"\u0001\u00d9\u0007\uffff\u0001\u0000\u0004\uffff",
DFA102_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0006\uffff\u0001\u0004\u0001"+
"\u0006\u0001\u0003\u0001\u0005",
DFA102_specialS:
"\u0008\uffff\u0001\u0000\u0004\uffff}>",
DFA102_transitionS: [
"\u0001\u0002\u0036\uffff\u0001\u0001\u0014\u0002\u0008\uffff"+
"\u0001\u0002\u0001\u0009\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0008\u000c\uffff\u0005\u0002\u0001\u000a\u0001\uffff"+
"\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA102_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_eotS),
DFA102_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_eofS),
DFA102_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA102_minS),
DFA102_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA102_maxS),
DFA102_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_acceptS),
DFA102_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_specialS),
DFA102_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA102_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA102_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA102 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 102;
this.eot = Ham4Parser.DFA102_eot;
this.eof = Ham4Parser.DFA102_eof;
this.min = Ham4Parser.DFA102_min;
this.max = Ham4Parser.DFA102_max;
this.accept = Ham4Parser.DFA102_accept;
this.special = Ham4Parser.DFA102_special;
this.transition = Ham4Parser.DFA102_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA102, org.antlr.runtime.DFA, {
getDescription: function() {
return "2574:5: ( HamNomotion -> ^( ACTION1 HamNomotion ) | simplemovement ( ( modifier )+ ( HamLargemod )? )? -> ^( ACTION1 simplemovement ( modifier )* ( HamLargemod )? ) | ( HamSeqbegin digit )=> specialfingerplaymovement -> ^( ACTION1 specialfingerplaymovement ) | paraction1 -> ^( ACTION1 paraction1 ) | seqaction1 -> ^( ACTION1 seqaction1 ) | seqfusedaction1 -> ^( ACTION1 seqfusedaction1 ) )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA102_8 = input.LA(1);
var index102_8 = input.index();
input.rewind();
s = -1;
if ( (this.synpred33_Ham4Parser()) ) {s = 11;}
else if ( (true) ) {s = 12;}
input.seek(index102_8);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 102, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA103_eotS:
"\u000d\uffff",
DFA103_eofS:
"\u000d\uffff",
DFA103_minS:
"\u0001\u000f\u000c\uffff",
DFA103_maxS:
"\u0001\u00d9\u000c\uffff",
DFA103_acceptS:
"\u0001\uffff\u0001\u0002\u0001\uffff\u0001\u0001\u0009\uffff",
DFA103_specialS:
"\u000d\uffff}>",
DFA103_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0003\u0036\uffff\u0015\u0003"+
"\u0008\uffff\u0002\u0003\u0001\u0001\u0006\u0003\u000f\uffff"+
"\u0001\u0003\u000c\uffff\u0006\u0003\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA103_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_eotS),
DFA103_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_eofS),
DFA103_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA103_minS),
DFA103_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA103_maxS),
DFA103_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_acceptS),
DFA103_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_specialS),
DFA103_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA103_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA103_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA103 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 103;
this.eot = Ham4Parser.DFA103_eot;
this.eof = Ham4Parser.DFA103_eof;
this.min = Ham4Parser.DFA103_min;
this.max = Ham4Parser.DFA103_max;
this.accept = Ham4Parser.DFA103_accept;
this.special = Ham4Parser.DFA103_special;
this.transition = Ham4Parser.DFA103_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA103, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2605:4: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA104_eotS:
"\u000d\uffff",
DFA104_eofS:
"\u000d\uffff",
DFA104_minS:
"\u0001\u000f\u000c\uffff",
DFA104_maxS:
"\u0001\u00d9\u000c\uffff",
DFA104_acceptS:
"\u0001\uffff\u0001\u0002\u0001\uffff\u0001\u0001\u0009\uffff",
DFA104_specialS:
"\u000d\uffff}>",
DFA104_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0003\u0036\uffff\u0015\u0003"+
"\u0008\uffff\u0002\u0003\u0001\u0001\u0006\u0003\u000f\uffff"+
"\u0001\u0003\u000c\uffff\u0006\u0003\u0001\uffff\u000c\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA104_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_eotS),
DFA104_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_eofS),
DFA104_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA104_minS),
DFA104_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA104_maxS),
DFA104_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_acceptS),
DFA104_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_specialS),
DFA104_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA104_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA104_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA104 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 104;
this.eot = Ham4Parser.DFA104_eot;
this.eof = Ham4Parser.DFA104_eof;
this.min = Ham4Parser.DFA104_min;
this.max = Ham4Parser.DFA104_max;
this.accept = Ham4Parser.DFA104_accept;
this.special = Ham4Parser.DFA104_special;
this.transition = Ham4Parser.DFA104_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA104, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2609:4: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA105_eotS:
"\u000c\uffff",
DFA105_eofS:
"\u000c\uffff",
DFA105_minS:
"\u0001\u004e\u000b\uffff",
DFA105_maxS:
"\u0001\u00d9\u000b\uffff",
DFA105_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA105_specialS:
"\u000c\uffff}>",
DFA105_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA105_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_eotS),
DFA105_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_eofS),
DFA105_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA105_minS),
DFA105_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA105_maxS),
DFA105_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_acceptS),
DFA105_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_specialS),
DFA105_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA105_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA105_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA105 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 105;
this.eot = Ham4Parser.DFA105_eot;
this.eof = Ham4Parser.DFA105_eof;
this.min = Ham4Parser.DFA105_min;
this.max = Ham4Parser.DFA105_max;
this.accept = Ham4Parser.DFA105_accept;
this.special = Ham4Parser.DFA105_special;
this.transition = Ham4Parser.DFA105_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA105, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2631:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA106_eotS:
"\u000c\uffff",
DFA106_eofS:
"\u000c\uffff",
DFA106_minS:
"\u0001\u004e\u000b\uffff",
DFA106_maxS:
"\u0001\u00d9\u000b\uffff",
DFA106_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA106_specialS:
"\u000c\uffff}>",
DFA106_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA106_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_eotS),
DFA106_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_eofS),
DFA106_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA106_minS),
DFA106_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA106_maxS),
DFA106_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_acceptS),
DFA106_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_specialS),
DFA106_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA106_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA106_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA106 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 106;
this.eot = Ham4Parser.DFA106_eot;
this.eof = Ham4Parser.DFA106_eof;
this.min = Ham4Parser.DFA106_min;
this.max = Ham4Parser.DFA106_max;
this.accept = Ham4Parser.DFA106_accept;
this.special = Ham4Parser.DFA106_special;
this.transition = Ham4Parser.DFA106_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA106, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2656:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA107_eotS:
"\u000c\uffff",
DFA107_eofS:
"\u000c\uffff",
DFA107_minS:
"\u0001\u004e\u000b\uffff",
DFA107_maxS:
"\u0001\u00d9\u000b\uffff",
DFA107_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA107_specialS:
"\u000c\uffff}>",
DFA107_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA107_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_eotS),
DFA107_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_eofS),
DFA107_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA107_minS),
DFA107_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA107_maxS),
DFA107_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_acceptS),
DFA107_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_specialS),
DFA107_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA107_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA107_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA107 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 107;
this.eot = Ham4Parser.DFA107_eot;
this.eof = Ham4Parser.DFA107_eof;
this.min = Ham4Parser.DFA107_min;
this.max = Ham4Parser.DFA107_max;
this.accept = Ham4Parser.DFA107_accept;
this.special = Ham4Parser.DFA107_special;
this.transition = Ham4Parser.DFA107_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA107, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2681:9: ( action2t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA108_eotS:
"\u000c\uffff",
DFA108_eofS:
"\u000c\uffff",
DFA108_minS:
"\u0001\u004e\u000b\uffff",
DFA108_maxS:
"\u0001\u00d9\u000b\uffff",
DFA108_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA108_specialS:
"\u000c\uffff}>",
DFA108_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA108_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_eotS),
DFA108_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_eofS),
DFA108_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA108_minS),
DFA108_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA108_maxS),
DFA108_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_acceptS),
DFA108_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_specialS),
DFA108_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA108_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA108_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA108 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 108;
this.eot = Ham4Parser.DFA108_eot;
this.eof = Ham4Parser.DFA108_eof;
this.min = Ham4Parser.DFA108_min;
this.max = Ham4Parser.DFA108_max;
this.accept = Ham4Parser.DFA108_accept;
this.special = Ham4Parser.DFA108_special;
this.transition = Ham4Parser.DFA108_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA108, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2768:9: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA111_eotS:
"\u001e\uffff",
DFA111_eofS:
"\u001e\uffff",
DFA111_minS:
"\u0001\u0043\u001d\uffff",
DFA111_maxS:
"\u0001\u00d9\u001d\uffff",
DFA111_acceptS:
"\u0001\uffff\u0001\u0001\u0012\uffff\u0001\u0002\u0009\uffff",
DFA111_specialS:
"\u001e\uffff}>",
DFA111_transitionS: [
"\u0003\u0001\u0008\uffff\u0001\u0014\u0004\uffff\u0003\u0001"+
"\u0001\uffff\u0015\u0001\u0019\uffff\u0015\u0014\u0008\uffff"+
"\u0002\u0014\u0001\uffff\u0006\u0014\u000f\uffff\u0001\u0014"+
"\u000c\uffff\u0006\u0014\u0001\uffff\u000c\u0014",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA111_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_eotS),
DFA111_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_eofS),
DFA111_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA111_minS),
DFA111_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA111_maxS),
DFA111_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_acceptS),
DFA111_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_specialS),
DFA111_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA111_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA111_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA111 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 111;
this.eot = Ham4Parser.DFA111_eot;
this.eof = Ham4Parser.DFA111_eof;
this.min = Ham4Parser.DFA111_min;
this.max = Ham4Parser.DFA111_max;
this.accept = Ham4Parser.DFA111_accept;
this.special = Ham4Parser.DFA111_special;
this.transition = Ham4Parser.DFA111_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA111, org.antlr.runtime.DFA, {
getDescription: function() {
return "2805:9: ( ( ( levelbody )=> levelbody | levelarm ) action1t -> ^( NMACT1T ( levelbody )* ( levelarm )* action1t ) | ( action1t )+ -> ^( SEQACT1T ( action1t )* ) )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA109_eotS:
"\u0014\uffff",
DFA109_eofS:
"\u0014\uffff",
DFA109_minS:
"\u0001\u0043\u0011\uffff\u0001\u0000\u0001\uffff",
DFA109_maxS:
"\u0001\u006b\u0011\uffff\u0001\u0000\u0001\uffff",
DFA109_acceptS:
"\u0001\uffff\u0011\u0001\u0001\uffff\u0001\u0002",
DFA109_specialS:
"\u0001\u0000\u0011\uffff\u0001\u0001\u0001\uffff}>",
DFA109_transitionS: [
"\u0001\u0011\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007"+
"\u0001\u0008\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002"+
"\u0001\u0003\u0001\u0004\u0001\u0008\u0001\u0005\u0002\u0011"+
"\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d"+
"\u0001\u000e\u0001\u0010\u0002\u0012\u0004\u0013",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\u0001\uffff",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA109_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_eotS),
DFA109_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_eofS),
DFA109_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA109_minS),
DFA109_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA109_maxS),
DFA109_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_acceptS),
DFA109_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_specialS),
DFA109_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA109_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA109_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA109 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 109;
this.eot = Ham4Parser.DFA109_eot;
this.eof = Ham4Parser.DFA109_eof;
this.min = Ham4Parser.DFA109_min;
this.max = Ham4Parser.DFA109_max;
this.accept = Ham4Parser.DFA109_accept;
this.special = Ham4Parser.DFA109_special;
this.transition = Ham4Parser.DFA109_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA109, org.antlr.runtime.DFA, {
getDescription: function() {
return "2806:4: ( ( levelbody )=> levelbody | levelarm )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA109_0 = input.LA(1);
var index109_0 = input.index();
input.rewind();
s = -1;
if ( (LA109_0==HamHead) && (this.synpred34_Ham4Parser())) {s = 1;}
else if ( (LA109_0==HamHeadtop) && (this.synpred34_Ham4Parser())) {s = 2;}
else if ( (LA109_0==HamForehead) && (this.synpred34_Ham4Parser())) {s = 3;}
else if ( (LA109_0==HamEyebrows) && (this.synpred34_Ham4Parser())) {s = 4;}
else if ( (LA109_0==HamNose) && (this.synpred34_Ham4Parser())) {s = 5;}
else if ( (LA109_0==HamNostrils) && (this.synpred34_Ham4Parser())) {s = 6;}
else if ( (LA109_0==HamTongue) && (this.synpred34_Ham4Parser())) {s = 7;}
else if ( (LA109_0==HamTeeth||LA109_0==HamEyes||LA109_0==HamLips) && (this.synpred34_Ham4Parser())) {s = 8;}
else if ( (LA109_0==HamChin) && (this.synpred34_Ham4Parser())) {s = 9;}
else if ( (LA109_0==HamUnderchin) && (this.synpred34_Ham4Parser())) {s = 10;}
else if ( (LA109_0==HamNeck) && (this.synpred34_Ham4Parser())) {s = 11;}
else if ( (LA109_0==HamShouldertop) && (this.synpred34_Ham4Parser())) {s = 12;}
else if ( (LA109_0==HamShoulders) && (this.synpred34_Ham4Parser())) {s = 13;}
else if ( (LA109_0==HamChest) && (this.synpred34_Ham4Parser())) {s = 14;}
else if ( (LA109_0==HamStomach) && (this.synpred34_Ham4Parser())) {s = 15;}
else if ( (LA109_0==HamBelowstomach) && (this.synpred34_Ham4Parser())) {s = 16;}
else if ( (LA109_0==HamEarlobe||(LA109_0>=HamEar && LA109_0<=HamCheek)) && (this.synpred34_Ham4Parser())) {s = 17;}
else if ( ((LA109_0>=HamLrbeside && LA109_0<=HamLrat)) ) {s = 18;}
else if ( ((LA109_0>=HamUpperarm && LA109_0<=HamLowerarm)) ) {s = 19;}
input.seek(index109_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA109_18 = input.LA(1);
var index109_18 = input.index();
input.rewind();
s = -1;
if ( (this.synpred34_Ham4Parser()) ) {s = 17;}
else if ( (true) ) {s = 19;}
input.seek(index109_18);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 109, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA110_eotS:
"\u000c\uffff",
DFA110_eofS:
"\u000c\uffff",
DFA110_minS:
"\u0001\u004e\u000b\uffff",
DFA110_maxS:
"\u0001\u00d9\u000b\uffff",
DFA110_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA110_specialS:
"\u000c\uffff}>",
DFA110_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA110_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_eotS),
DFA110_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_eofS),
DFA110_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA110_minS),
DFA110_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA110_maxS),
DFA110_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_acceptS),
DFA110_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_specialS),
DFA110_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA110_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA110_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA110 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 110;
this.eot = Ham4Parser.DFA110_eot;
this.eof = Ham4Parser.DFA110_eof;
this.min = Ham4Parser.DFA110_min;
this.max = Ham4Parser.DFA110_max;
this.accept = Ham4Parser.DFA110_accept;
this.special = Ham4Parser.DFA110_special;
this.transition = Ham4Parser.DFA110_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA110, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2814:10: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA112_eotS:
"\u000c\uffff",
DFA112_eofS:
"\u000c\uffff",
DFA112_minS:
"\u0001\u004e\u000b\uffff",
DFA112_maxS:
"\u0001\u00d9\u000b\uffff",
DFA112_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA112_specialS:
"\u000c\uffff}>",
DFA112_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA112_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_eotS),
DFA112_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_eofS),
DFA112_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA112_minS),
DFA112_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA112_maxS),
DFA112_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_acceptS),
DFA112_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_specialS),
DFA112_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA112_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA112_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA112 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 112;
this.eot = Ham4Parser.DFA112_eot;
this.eof = Ham4Parser.DFA112_eof;
this.min = Ham4Parser.DFA112_min;
this.max = Ham4Parser.DFA112_max;
this.accept = Ham4Parser.DFA112_accept;
this.special = Ham4Parser.DFA112_special;
this.transition = Ham4Parser.DFA112_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA112, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2842:9: ( action1t )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA113_eotS:
"\u000c\uffff",
DFA113_eofS:
"\u000c\uffff",
DFA113_minS:
"\u0001\u004e\u000b\uffff",
DFA113_maxS:
"\u0001\u00d9\u000b\uffff",
DFA113_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA113_specialS:
"\u000c\uffff}>",
DFA113_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA113_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_eotS),
DFA113_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_eofS),
DFA113_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA113_minS),
DFA113_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA113_maxS),
DFA113_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_acceptS),
DFA113_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_specialS),
DFA113_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA113_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA113_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA113 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 113;
this.eot = Ham4Parser.DFA113_eot;
this.eof = Ham4Parser.DFA113_eof;
this.min = Ham4Parser.DFA113_min;
this.max = Ham4Parser.DFA113_max;
this.accept = Ham4Parser.DFA113_accept;
this.special = Ham4Parser.DFA113_special;
this.transition = Ham4Parser.DFA113_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA113, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2869:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA114_eotS:
"\u000c\uffff",
DFA114_eofS:
"\u000c\uffff",
DFA114_minS:
"\u0001\u004e\u000b\uffff",
DFA114_maxS:
"\u0001\u00d9\u000b\uffff",
DFA114_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA114_specialS:
"\u000c\uffff}>",
DFA114_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u0001\u0001"+
"\u000b\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA114_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_eotS),
DFA114_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_eofS),
DFA114_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA114_minS),
DFA114_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA114_maxS),
DFA114_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_acceptS),
DFA114_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_specialS),
DFA114_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA114_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA114_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA114 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 114;
this.eot = Ham4Parser.DFA114_eot;
this.eof = Ham4Parser.DFA114_eof;
this.min = Ham4Parser.DFA114_min;
this.max = Ham4Parser.DFA114_max;
this.accept = Ham4Parser.DFA114_accept;
this.special = Ham4Parser.DFA114_special;
this.transition = Ham4Parser.DFA114_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA114, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2896:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA115_eotS:
"\u000c\uffff",
DFA115_eofS:
"\u000c\uffff",
DFA115_minS:
"\u0001\u004e\u000b\uffff",
DFA115_maxS:
"\u0001\u00d9\u000b\uffff",
DFA115_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA115_specialS:
"\u000c\uffff}>",
DFA115_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\uffff\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\u0001\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA115_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_eotS),
DFA115_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_eofS),
DFA115_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA115_minS),
DFA115_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA115_maxS),
DFA115_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_acceptS),
DFA115_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_specialS),
DFA115_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA115_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA115_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA115 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 115;
this.eot = Ham4Parser.DFA115_eot;
this.eof = Ham4Parser.DFA115_eof;
this.min = Ham4Parser.DFA115_min;
this.max = Ham4Parser.DFA115_max;
this.accept = Ham4Parser.DFA115_accept;
this.special = Ham4Parser.DFA115_special;
this.transition = Ham4Parser.DFA115_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA115, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2923:9: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA116_eotS:
"\u0012\uffff",
DFA116_eofS:
"\u0001\u0004\u0011\uffff",
DFA116_minS:
"\u0001\u000f\u0001\u0000\u0010\uffff",
DFA116_maxS:
"\u0001\u00d9\u0001\u0000\u0010\uffff",
DFA116_acceptS:
"\u0002\uffff\u0002\u0001\u0001\u0002\u000d\uffff",
DFA116_specialS:
"\u0001\u0000\u0001\u0001\u0010\uffff}>",
DFA116_transitionS: [
"\u0001\u0004\u003e\uffff\u0001\u0004\u0036\uffff\u0015\u0004"+
"\u0008\uffff\u0009\u0004\u000b\uffff\u0004\u0002\u0001\u0001"+
"\u0001\u0004\u0001\u0003\u0001\u0002\u0009\uffff\u0013\u0004",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA116_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_eotS),
DFA116_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_eofS),
DFA116_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA116_minS),
DFA116_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA116_maxS),
DFA116_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_acceptS),
DFA116_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_specialS),
DFA116_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA116_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA116_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA116 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 116;
this.eot = Ham4Parser.DFA116_eot;
this.eof = Ham4Parser.DFA116_eof;
this.min = Ham4Parser.DFA116_min;
this.max = Ham4Parser.DFA116_max;
this.accept = Ham4Parser.DFA116_accept;
this.special = Ham4Parser.DFA116_special;
this.transition = Ham4Parser.DFA116_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA116, org.antlr.runtime.DFA, {
getDescription: function() {
return "2949:9: ( ( ( HamSeqbegin )? repetition | HamAlternatingmotion )=> repetitions )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA116_0 = input.LA(1);
var index116_0 = input.index();
input.rewind();
s = -1;
if ( (LA116_0==HamSeqbegin) ) {s = 1;}
else if ( ((LA116_0>=HamRepeatfromstart && LA116_0<=HamRepeatcontinueseveral)||LA116_0==HamRepeatreverse) && (this.synpred35_Ham4Parser())) {s = 2;}
else if ( (LA116_0==HamAlternatingmotion) && (this.synpred35_Ham4Parser())) {s = 3;}
else if ( (LA116_0==EOF||LA116_0==HamPlus||LA116_0==HamReplace||(LA116_0>=HamNomotion && LA116_0<=HamMovex)||(LA116_0>=HamFingerplay && LA116_0<=HamCircler)||LA116_0==HamSeqend||(LA116_0>=HamNodding && LA116_0<=HamCircleuo)) ) {s = 4;}
input.seek(index116_0);
if ( s>=0 ) return s;
break;
case 1 : 
var LA116_1 = input.LA(1);
var index116_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred35_Ham4Parser()) ) {s = 3;}
else if ( (true) ) {s = 4;}
input.seek(index116_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 116, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA127_eotS:
"\u0030\uffff",
DFA127_eofS:
"\u0001\u0002\u002f\uffff",
DFA127_minS:
"\u0001\u000f\u002f\uffff",
DFA127_maxS:
"\u0001\u00d9\u002f\uffff",
DFA127_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002d\uffff",
DFA127_specialS:
"\u0030\uffff}>",
DFA127_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u000f\u0002\u0002\uffff\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA127_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_eotS),
DFA127_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_eofS),
DFA127_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA127_minS),
DFA127_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA127_maxS),
DFA127_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_acceptS),
DFA127_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_specialS),
DFA127_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA127_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA127_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA127 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 127;
this.eot = Ham4Parser.DFA127_eot;
this.eof = Ham4Parser.DFA127_eof;
this.min = Ham4Parser.DFA127_min;
this.max = Ham4Parser.DFA127_max;
this.accept = Ham4Parser.DFA127_accept;
this.special = Ham4Parser.DFA127_special;
this.transition = Ham4Parser.DFA127_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA127, org.antlr.runtime.DFA, {
getDescription: function() {
return "3148:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA128_eotS:
"\u002f\uffff",
DFA128_eofS:
"\u0001\u0003\u002e\uffff",
DFA128_minS:
"\u0001\u000f\u002e\uffff",
DFA128_maxS:
"\u0001\u00d9\u002e\uffff",
DFA128_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u002b\uffff",
DFA128_specialS:
"\u002f\uffff}>",
DFA128_transitionS: [
"\u0001\u0003\u0033\uffff\u0003\u0003\u0008\uffff\u0001\u0003"+
"\u0004\uffff\u0025\u0003\u0001\uffff\u0006\u0003\u0006\uffff"+
"\u0015\u0003\u0002\uffff\u0004\u0001\u0002\u0002\u0009\u0003"+
"\u0002\uffff\u0011\u0003\u0009\uffff\u0013\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA128_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_eotS),
DFA128_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_eofS),
DFA128_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA128_minS),
DFA128_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA128_maxS),
DFA128_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_acceptS),
DFA128_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_specialS),
DFA128_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA128_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA128_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA128 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 128;
this.eot = Ham4Parser.DFA128_eot;
this.eof = Ham4Parser.DFA128_eof;
this.min = Ham4Parser.DFA128_min;
this.max = Ham4Parser.DFA128_max;
this.accept = Ham4Parser.DFA128_accept;
this.special = Ham4Parser.DFA128_special;
this.transition = Ham4Parser.DFA128_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA128, org.antlr.runtime.DFA, {
getDescription: function() {
return "3149:13: ( arckind | zigzag )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA129_eotS:
"\u0032\uffff",
DFA129_eofS:
"\u0001\u0002\u0031\uffff",
DFA129_minS:
"\u0001\u000f\u0031\uffff",
DFA129_maxS:
"\u0001\u00d9\u0031\uffff",
DFA129_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002f\uffff",
DFA129_specialS:
"\u0032\uffff}>",
DFA129_transitionS: [
"\u0001\u0002\u0001\uffff\u0009\u0002\u0029\uffff\u0003\u0002"+
"\u0008\uffff\u0001\u0002\u0004\uffff\u0025\u0002\u0001\uffff"+
"\u0006\u0002\u0006\uffff\u0015\u0002\u0002\u0001\u0006\uffff"+
"\u001c\u0002\u0002\uffff\u0004\u0002\u0003\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA129_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_eotS),
DFA129_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_eofS),
DFA129_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA129_minS),
DFA129_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA129_maxS),
DFA129_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_acceptS),
DFA129_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_specialS),
DFA129_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA129_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA129_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA129 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 129;
this.eot = Ham4Parser.DFA129_eot;
this.eof = Ham4Parser.DFA129_eof;
this.min = Ham4Parser.DFA129_min;
this.max = Ham4Parser.DFA129_max;
this.accept = Ham4Parser.DFA129_accept;
this.special = Ham4Parser.DFA129_special;
this.transition = Ham4Parser.DFA129_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA129, org.antlr.runtime.DFA, {
getDescription: function() {
return "3156:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA130_eotS:
"\u0031\uffff",
DFA130_eofS:
"\u0001\u0003\u0030\uffff",
DFA130_minS:
"\u0001\u000f\u0030\uffff",
DFA130_maxS:
"\u0001\u00d9\u0030\uffff",
DFA130_acceptS:
"\u0001\uffff\u0001\u0001\u0001\uffff\u0001\u0002\u002d\uffff",
DFA130_specialS:
"\u0031\uffff}>",
DFA130_transitionS: [
"\u0001\u0003\u0001\uffff\u0009\u0001\u0029\uffff\u0003\u0003"+
"\u0008\uffff\u0001\u0003\u0004\uffff\u0025\u0003\u0001\uffff"+
"\u0006\u0003\u0006\uffff\u0015\u0003\u0008\uffff\u001c\u0003"+
"\u0002\uffff\u0004\u0003\u0003\uffff\u0013\u0003",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA130_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_eotS),
DFA130_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_eofS),
DFA130_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA130_minS),
DFA130_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA130_maxS),
DFA130_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_acceptS),
DFA130_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_specialS),
DFA130_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA130_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA130_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA130 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 130;
this.eot = Ham4Parser.DFA130_eot;
this.eof = Ham4Parser.DFA130_eof;
this.min = Ham4Parser.DFA130_min;
this.max = Ham4Parser.DFA130_max;
this.accept = Ham4Parser.DFA130_accept;
this.special = Ham4Parser.DFA130_special;
this.transition = Ham4Parser.DFA130_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA130, org.antlr.runtime.DFA, {
getDescription: function() {
return "3157:13: ( revolutions )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA131_eotS:
"\u002f\uffff",
DFA131_eofS:
"\u0001\u0002\u002e\uffff",
DFA131_minS:
"\u0001\u000f\u002e\uffff",
DFA131_maxS:
"\u0001\u00d9\u002e\uffff",
DFA131_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002c\uffff",
DFA131_specialS:
"\u002f\uffff}>",
DFA131_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u001c\u0002\u0002\uffff\u0004\u0001"+
"\u0003\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA131_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_eotS),
DFA131_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_eofS),
DFA131_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA131_minS),
DFA131_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA131_maxS),
DFA131_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_acceptS),
DFA131_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_specialS),
DFA131_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA131_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA131_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA131 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 131;
this.eot = Ham4Parser.DFA131_eot;
this.eof = Ham4Parser.DFA131_eof;
this.min = Ham4Parser.DFA131_min;
this.max = Ham4Parser.DFA131_max;
this.accept = Ham4Parser.DFA131_accept;
this.special = Ham4Parser.DFA131_special;
this.transition = Ham4Parser.DFA131_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA131, org.antlr.runtime.DFA, {
getDescription: function() {
return "3158:13: ( ellipse )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA132_eotS:
"\u002e\uffff",
DFA132_eofS:
"\u0001\u0002\u002d\uffff",
DFA132_minS:
"\u0001\u000f\u002d\uffff",
DFA132_maxS:
"\u0001\u00d9\u002d\uffff",
DFA132_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA132_specialS:
"\u002e\uffff}>",
DFA132_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u0009\u0002\u0002\u0001\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA132_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_eotS),
DFA132_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_eofS),
DFA132_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA132_minS),
DFA132_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA132_maxS),
DFA132_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_acceptS),
DFA132_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_specialS),
DFA132_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA132_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA132_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA132 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 132;
this.eot = Ham4Parser.DFA132_eot;
this.eof = Ham4Parser.DFA132_eof;
this.min = Ham4Parser.DFA132_min;
this.max = Ham4Parser.DFA132_max;
this.accept = Ham4Parser.DFA132_accept;
this.special = Ham4Parser.DFA132_special;
this.transition = Ham4Parser.DFA132_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA132, org.antlr.runtime.DFA, {
getDescription: function() {
return "3159:13: ( sizechangenonlinear )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA133_eotS:
"\u002e\uffff",
DFA133_eofS:
"\u0001\u0002\u002d\uffff",
DFA133_minS:
"\u0001\u000f\u002d\uffff",
DFA133_maxS:
"\u0001\u00d9\u002d\uffff",
DFA133_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA133_specialS:
"\u002e\uffff}>",
DFA133_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u0006\uffff\u0009\u0002\u0002\uffff"+
"\u0011\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA133_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_eotS),
DFA133_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_eofS),
DFA133_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA133_minS),
DFA133_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA133_maxS),
DFA133_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_acceptS),
DFA133_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_specialS),
DFA133_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA133_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA133_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA133 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 133;
this.eot = Ham4Parser.DFA133_eot;
this.eof = Ham4Parser.DFA133_eof;
this.min = Ham4Parser.DFA133_min;
this.max = Ham4Parser.DFA133_max;
this.accept = Ham4Parser.DFA133_accept;
this.special = Ham4Parser.DFA133_special;
this.transition = Ham4Parser.DFA133_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA133, org.antlr.runtime.DFA, {
getDescription: function() {
return "3162:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA134_eotS:
"\u002e\uffff",
DFA134_eofS:
"\u0001\u0002\u002d\uffff",
DFA134_minS:
"\u0001\u000f\u002d\uffff",
DFA134_maxS:
"\u0001\u00d9\u002d\uffff",
DFA134_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u002b\uffff",
DFA134_specialS:
"\u002e\uffff}>",
DFA134_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0002\u0001\u0006\uffff\u0009\u0002\u0002\uffff"+
"\u0011\u0002\u0009\uffff\u0013\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA134_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_eotS),
DFA134_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_eofS),
DFA134_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA134_minS),
DFA134_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA134_maxS),
DFA134_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_acceptS),
DFA134_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_specialS),
DFA134_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA134_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA134_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA134 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 134;
this.eot = Ham4Parser.DFA134_eot;
this.eof = Ham4Parser.DFA134_eof;
this.min = Ham4Parser.DFA134_min;
this.max = Ham4Parser.DFA134_max;
this.accept = Ham4Parser.DFA134_accept;
this.special = Ham4Parser.DFA134_special;
this.transition = Ham4Parser.DFA134_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA134, org.antlr.runtime.DFA, {
getDescription: function() {
return "3165:13: ( size )?";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA136_eotS:
"\u002e\uffff",
DFA136_eofS:
"\u0001\u0002\u002d\uffff",
DFA136_minS:
"\u0001\u000f\u0001\u0000\u002c\uffff",
DFA136_maxS:
"\u0001\u00d9\u0001\u0000\u002c\uffff",
DFA136_acceptS:
"\u0002\uffff\u0001\u0002\u002a\uffff\u0001\u0001",
DFA136_specialS:
"\u0001\uffff\u0001\u0000\u002c\uffff}>",
DFA136_transitionS: [
"\u0001\u0002\u0033\uffff\u0003\u0002\u0008\uffff\u0001\u0002"+
"\u0004\uffff\u0025\u0002\u0001\uffff\u0006\u0002\u0006\uffff"+
"\u0015\u0002\u0008\uffff\u0009\u0002\u0002\uffff\u000d\u0002"+
"\u0001\u0001\u0003\u0002\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA136_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_eotS),
DFA136_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_eofS),
DFA136_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA136_minS),
DFA136_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA136_maxS),
DFA136_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_acceptS),
DFA136_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_specialS),
DFA136_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA136_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA136_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA136 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 136;
this.eot = Ham4Parser.DFA136_eot;
this.eof = Ham4Parser.DFA136_eof;
this.min = Ham4Parser.DFA136_min;
this.max = Ham4Parser.DFA136_max;
this.accept = Ham4Parser.DFA136_accept;
this.special = Ham4Parser.DFA136_special;
this.transition = Ham4Parser.DFA136_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA136, org.antlr.runtime.DFA, {
getDescription: function() {
return "3171:9: ( ( HamSeqbegin HamBrushing )=> brushingcontact )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA136_1 = input.LA(1);
var index136_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred37_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 2;}
input.seek(index136_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 136, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA137_eotS:
"\u002e\uffff",
DFA137_eofS:
"\u0001\u0003\u002d\uffff",
DFA137_minS:
"\u0001\u000f\u0002\u0000\u002b\uffff",
DFA137_maxS:
"\u0001\u00d9\u0002\u0000\u002b\uffff",
DFA137_acceptS:
"\u0003\uffff\u0001\u0002\u0029\uffff\u0001\u0001",
DFA137_specialS:
"\u0001\uffff\u0001\u0000\u0001\u0001\u002b\uffff}>",
DFA137_transitionS: [
"\u0001\u0003\u0033\uffff\u0003\u0003\u0008\uffff\u0001\u0003"+
"\u0004\uffff\u001e\u0003\u0001\u0001\u0004\u0002\u0002\u0003"+
"\u0001\uffff\u0006\u0003\u0006\uffff\u0015\u0003\u0008\uffff"+
"\u0009\u0003\u0002\uffff\u0011\u0003\u0009\uffff\u0013\u0003",
"\u0001\uffff",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA137_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_eotS),
DFA137_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_eofS),
DFA137_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA137_minS),
DFA137_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA137_maxS),
DFA137_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_acceptS),
DFA137_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_specialS),
DFA137_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA137_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA137_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA137 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 137;
this.eot = Ham4Parser.DFA137_eot;
this.eof = Ham4Parser.DFA137_eof;
this.min = Ham4Parser.DFA137_min;
this.max = Ham4Parser.DFA137_max;
this.accept = Ham4Parser.DFA137_accept;
this.special = Ham4Parser.DFA137_special;
this.transition = Ham4Parser.DFA137_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA137, org.antlr.runtime.DFA, {
getDescription: function() {
return "3176:9: ( ( locationindexdefine )=> locationindexdefine )?";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA137_1 = input.LA(1);
var index137_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred38_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 3;}
input.seek(index137_1);
if ( s>=0 ) return s;
break;
case 1 : 
var LA137_2 = input.LA(1);
var index137_2 = input.index();
input.rewind();
s = -1;
if ( (this.synpred38_Ham4Parser()) ) {s = 45;}
else if ( (true) ) {s = 3;}
input.seek(index137_2);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 137, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA157_eotS:
"\u0041\uffff",
DFA157_eofS:
"\u0001\u0002\u0040\uffff",
DFA157_minS:
"\u0001\u000f\u0001\u0000\u003f\uffff",
DFA157_maxS:
"\u0001\u00d9\u0001\u0000\u003f\uffff",
DFA157_acceptS:
"\u0002\uffff\u0001\u0002\u003d\uffff\u0001\u0001",
DFA157_specialS:
"\u0001\uffff\u0001\u0000\u003f\uffff}>",
DFA157_transitionS: [
"\u0001\u0002\u0021\uffff\u001e\u0002\u0004\uffff\u0025\u0002"+
"\u0001\uffff\u0006\u0002\u0006\uffff\u0015\u0002\u0008\uffff"+
"\u0001\u0002\u0001\u0001\u0007\u0002\u0002\uffff\u0011\u0002"+
"\u0009\uffff\u0013\u0002",
"\u0001\uffff",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA157_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_eotS),
DFA157_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_eofS),
DFA157_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA157_minS),
DFA157_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA157_maxS),
DFA157_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_acceptS),
DFA157_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_specialS),
DFA157_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA157_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA157_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA157 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 157;
this.eot = Ham4Parser.DFA157_eot;
this.eof = Ham4Parser.DFA157_eof;
this.min = Ham4Parser.DFA157_min;
this.max = Ham4Parser.DFA157_max;
this.accept = Ham4Parser.DFA157_accept;
this.special = Ham4Parser.DFA157_special;
this.transition = Ham4Parser.DFA157_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA157, org.antlr.runtime.DFA, {
getDescription: function() {
return "3442:13: ( ( splitreplacetail )=> splitreplacetail | ( extfidir1 )? ( palmor1 )? )";
},
specialStateTransition: function(s, input) {
var _s = s;
/* bind to recognizer so semantic predicates can be evaluated */
var retval = (function(s, input) {
switch ( s ) {
case 0 : 
var LA157_1 = input.LA(1);
var index157_1 = input.index();
input.rewind();
s = -1;
if ( (this.synpred39_Ham4Parser()) ) {s = 64;}
else if ( (true) ) {s = 2;}
input.seek(index157_1);
if ( s>=0 ) return s;
break;
}
}).call(this.recognizer, s, input);
if (!org.antlr.lang.isUndefined(retval)) {
return retval;
}
if (this.recognizer.state.backtracking>0) {this.recognizer.state.failed=true; return -1;}
var nvae =
new org.antlr.runtime.NoViableAltException(this.getDescription(), 157, _s, input);
this.error(nvae);
throw nvae;
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA171_eotS:
"\u0013\uffff",
DFA171_eofS:
"\u0013\uffff",
DFA171_minS:
"\u0001\u0031\u0012\uffff",
DFA171_maxS:
"\u0001\u0042\u0012\uffff",
DFA171_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
"\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
"\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001"+
"\u0011\u0001\u0012",
DFA171_specialS:
"\u0013\uffff}>",
DFA171_transitionS: [
"\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005"+
"\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a"+
"\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f"+
"\u0001\u0010\u0001\u0011\u0001\u0012",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA171_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_eotS),
DFA171_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_eofS),
DFA171_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA171_minS),
DFA171_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA171_maxS),
DFA171_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_acceptS),
DFA171_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_specialS),
DFA171_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA171_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA171_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA171 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 171;
this.eot = Ham4Parser.DFA171_eot;
this.eof = Ham4Parser.DFA171_eof;
this.min = Ham4Parser.DFA171_min;
this.max = Ham4Parser.DFA171_max;
this.accept = Ham4Parser.DFA171_accept;
this.special = Ham4Parser.DFA171_special;
this.transition = Ham4Parser.DFA171_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA171, org.antlr.runtime.DFA, {
getDescription: function() {
return "3825:5: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA173_eotS:
"\u0011\uffff",
DFA173_eofS:
"\u0011\uffff",
DFA173_minS:
"\u0001\u0044\u0010\uffff",
DFA173_maxS:
"\u0001\u0065\u0010\uffff",
DFA173_acceptS:
"\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001"+
"\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001"+
"\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010",
DFA173_specialS:
"\u0011\uffff}>",
DFA173_transitionS: [
"\u0001\u0006\u0001\u000c\u000d\uffff\u0001\u0007\u0001\u0008"+
"\u0001\u000f\u0001\uffff\u0001\u0001\u0001\u0002\u0001\u0003"+
"\u0001\u0004\u0001\u0008\u0001\u0005\u0002\uffff\u0001\u0008"+
"\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000d\u0001\u000e"+
"\u0001\u0010",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA173_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_eotS),
DFA173_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_eofS),
DFA173_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA173_minS),
DFA173_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA173_maxS),
DFA173_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_acceptS),
DFA173_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_specialS),
DFA173_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA173_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA173_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA173 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 173;
this.eot = Ham4Parser.DFA173_eot;
this.eof = Ham4Parser.DFA173_eof;
this.min = Ham4Parser.DFA173_min;
this.max = Ham4Parser.DFA173_max;
this.accept = Ham4Parser.DFA173_accept;
this.special = Ham4Parser.DFA173_special;
this.transition = Ham4Parser.DFA173_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA173, org.antlr.runtime.DFA, {
getDescription: function() {
return "3998:5: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamNose | HamNostrils | HamTongue | ( ( HamEyes | HamLips | HamTeeth ) ( HamDoublebent | HamDoublehooked )? ) | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA180_eotS:
"\u000c\uffff",
DFA180_eofS:
"\u000c\uffff",
DFA180_minS:
"\u0001\u000f\u000b\uffff",
DFA180_maxS:
"\u0001\u00d9\u000b\uffff",
DFA180_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA180_specialS:
"\u000c\uffff}>",
DFA180_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0008\uffff\u0002\u0002\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0002\u000c\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA180_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_eotS),
DFA180_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_eofS),
DFA180_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA180_minS),
DFA180_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA180_maxS),
DFA180_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_acceptS),
DFA180_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_specialS),
DFA180_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA180_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA180_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA180 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 180;
this.eot = Ham4Parser.DFA180_eot;
this.eof = Ham4Parser.DFA180_eof;
this.min = Ham4Parser.DFA180_min;
this.max = Ham4Parser.DFA180_max;
this.accept = Ham4Parser.DFA180_accept;
this.special = Ham4Parser.DFA180_special;
this.transition = Ham4Parser.DFA180_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA180, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2439:27: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA181_eotS:
"\u000c\uffff",
DFA181_eofS:
"\u000c\uffff",
DFA181_minS:
"\u0001\u004e\u000b\uffff",
DFA181_maxS:
"\u0001\u00d9\u000b\uffff",
DFA181_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA181_specialS:
"\u000c\uffff}>",
DFA181_transitionS: [
"\u0001\u0002\u0036\uffff\u0015\u0002\u0008\uffff\u0002\u0002"+
"\u0001\u0001\u0006\u0002\u000f\uffff\u0001\u0002\u000c\uffff"+
"\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA181_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_eotS),
DFA181_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_eofS),
DFA181_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA181_minS),
DFA181_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA181_maxS),
DFA181_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_acceptS),
DFA181_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_specialS),
DFA181_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA181_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA181_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA181 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 181;
this.eot = Ham4Parser.DFA181_eot;
this.eof = Ham4Parser.DFA181_eof;
this.min = Ham4Parser.DFA181_min;
this.max = Ham4Parser.DFA181_max;
this.accept = Ham4Parser.DFA181_accept;
this.special = Ham4Parser.DFA181_special;
this.transition = Ham4Parser.DFA181_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA181, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2440:15: ( action1 )+";
},
dummy: null
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA182_eotS:
"\u000c\uffff",
DFA182_eofS:
"\u000c\uffff",
DFA182_minS:
"\u0001\u000f\u000b\uffff",
DFA182_maxS:
"\u0001\u00d9\u000b\uffff",
DFA182_acceptS:
"\u0001\uffff\u0001\u0002\u0001\u0001\u0009\uffff",
DFA182_specialS:
"\u000c\uffff}>",
DFA182_transitionS: [
"\u0001\u0001\u003e\uffff\u0001\u0002\u0036\uffff\u0015\u0002"+
"\u0008\uffff\u0002\u0002\u0001\uffff\u0006\u0002\u000f\uffff"+
"\u0001\u0002\u000c\uffff\u0006\u0002\u0001\uffff\u000c\u0002",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
]
});
org.antlr.lang.augmentObject(Ham4Parser, {
DFA182_eot:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_eotS),
DFA182_eof:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_eofS),
DFA182_min:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA182_minS),
DFA182_max:
org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars(Ham4Parser.DFA182_maxS),
DFA182_accept:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_acceptS),
DFA182_special:
org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_specialS),
DFA182_transition: (function() {
var a = [],
i,
numStates = Ham4Parser.DFA182_transitionS.length;
for (i=0; i<numStates; i++) {
a.push(org.antlr.runtime.DFA.unpackEncodedString(Ham4Parser.DFA182_transitionS[i]));
}
return a;
})()
});
Ham4Parser.DFA182 = function(recognizer) {
this.recognizer = recognizer;
this.decisionNumber = 182;
this.eot = Ham4Parser.DFA182_eot;
this.eof = Ham4Parser.DFA182_eof;
this.min = Ham4Parser.DFA182_min;
this.max = Ham4Parser.DFA182_max;
this.accept = Ham4Parser.DFA182_accept;
this.special = Ham4Parser.DFA182_special;
this.transition = Ham4Parser.DFA182_transition;
};
org.antlr.lang.extend(Ham4Parser.DFA182, org.antlr.runtime.DFA, {
getDescription: function() {
return "()+ loopback of 2444:27: ( action1t )+";
},
dummy: null
});
// public class variables
org.antlr.lang.augmentObject(Ham4Parser, {
tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "WS", "HamTab", "HamLinefeed", "HamPagebreak", "HamReturn", "HamVersion40", "HamSpace", "HamExclaim", "HamQuery", "HamFullstop", "HamComma", "HamPlus", "HamMetaalt", "HamClocku", "HamClockul", "HamClockl", "HamClockdl", "HamClockd", "HamClockdr", "HamClockr", "HamClockur", "HamClockfull", "HamSymmpar", "HamSymmlr", "HamFist", "HamFlathand", "HamFinger2", "HamFinger23", "HamFinger23spread", "HamFinger2345", "HamThumboutmod", "HamThumbacrossmod", "HamPinch12", "HamPinchall", "HamPinch12open", "HamCee12", "HamCeeall", "HamCee12open", "HamThumbopenmod", "HamFingerstraightmod", "HamFingerbendmod", "HamFingerhookedmod", "HamNondominant", "HamDoublebent", "HamDoublehooked", "HamExtfingeru", "HamExtfingerur", "HamExtfingerr", "HamExtfingerdr", "HamExtfingerd", "HamExtfingerdl", "HamExtfingerl", "HamExtfingerul", "HamExtfingerol", "HamExtfingero", "HamExtfingeror", "HamExtfingeril", "HamExtfingeri", "HamExtfingerir", "HamExtfingerui", "HamExtfingerdi", "HamExtfingerdo", "HamExtfingeruo", "HamEarlobe", "HamNostrils", "HamShouldertop", "HamPalmu", "HamPalmur", "HamPalmr", "HamPalmdr", "HamPalmd", "HamPalmdl", "HamPalml", "HamPalmul", "HamReplace", "HamArmextended", "HamBehind", "HamEtc", "HamOrirelative", "HamTongue", "HamTeeth", "HamStomach", "HamNeutralspace", "HamHead", "HamHeadtop", "HamForehead", "HamEyebrows", "HamEyes", "HamNose", "HamEar", "HamCheek", "HamLips", "HamChin", "HamUnderchin", "HamNeck", "HamShoulders", "HamChest", "HamBelowstomach", "HamLrbeside", "HamLrat", "HamUpperarm", "HamElbow", "HamElbowinside", "HamLowerarm", "HamWristback", "HamWristpulse", "HamThumbball", "HamPalm", "HamHandback", "HamThumb", "HamIndexfinger", "HamMiddlefinger", "HamRingfinger", "HamPinky", "HamThumbside", "HamPinkyside", "HamBetween", "HamFingertip", "HamFingernail", "HamFingerpad", "HamFingermidjoint", "HamFingerbase", "HamFingerside", "HamWristtopulse", "HamWristtoback", "HamWristtothumb", "HamWristtopinky", "HamCoreftag", "HamCorefref", "HamNomotion", "HamMoveu", "HamMoveur", "HamMover", "HamMovedr", "HamMoved", "HamMovedl", "HamMovel", "HamMoveul", "HamMoveol", "HamMoveo", "HamMoveor", "HamMoveil", "HamMovei", "HamMoveir", "HamMoveui", "HamMovedi", "HamMovedo", "HamMoveuo", "HamMovecross", "HamMovex", "HamSmallmod", "HamLargemod", "HamArcl", "HamArcu", "HamArcr", "HamArcd", "HamWavy", "HamZigzag", "HamFingerplay", "HamParbegin", "HamParend", "HamCircleo", "HamCirclei", "HamCircled", "HamCircleu", "HamCirclel", "HamCircler", "HamIncreasing", "HamDecreasing", "HamClose", "HamTouch", "HamInterlock", "HamCross", "HamFast", "HamSlow", "HamTense", "HamRest", "HamHalt", "HamRepeatfromstart", "HamRepeatfromstartseveral", "HamRepeatcontinue", "HamRepeatcontinueseveral", "HamSeqbegin", "HamSeqend", "HamAlternatingmotion", "HamRepeatreverse", "HamBrushing", "HamNonipsi", "HamEllipseh", "HamEllipseur", "HamEllipsev", "HamEllipseul", "HamMime", "HamAltbegin", "HamAltend", "HamNodding", "HamSwinging", "HamTwisting", "HamStircw", "HamStirccw", "HamFusionbegin", "HamFusionend", "HamCircleul", "HamCircledr", "HamCircleur", "HamCircledl", "HamCircleol", "HamCircleir", "HamCircleor", "HamCircleil", "HamCircledo", "HamCircleui", "HamCircledi", "HamCircleuo", "HamNbs", "HAMSIGNS", "SIGN2", "SIGN1", "ICFG2", "ICFG1", "NMICLIST", "NMICUNIT", "MICFG2", "MICFG1", "HDCONFIG2", "HDCONFIG1", "SPLITHDCFG2", "HDCFGTAIL2", "HSHAPE2", "HSHAPE1", "BASICHDSHP1", "BASICHDSHP", "HSCLASS", "FIBENDING", "THUMBPOS", "FINGERLIST", "FISHPLIST", "FICRSSLIST", "FSHAPE", "FCROSSING", "THSPECIAL", "EXTFIDIR2", "EXTFIDIR1", "EXTFIDIR", "PALMOR2", "PALMOR1", "LOC2", "LOC1", "LOCTNBODYARM", "LOCTNBODY", "LOCTNHAND", "LOCTNARM", "LEVBODY", "LEVHAND", "LEVARM", "HCONSTLLN", "CNTCTBODY", "CNTCTHAND", "CNTCTOFHAND", "A2TLIST", "A1TLIST", "A1LIST", "ACTION2T", "ACTION1T", "ACTION2", "ACTION1", "PARACT2T", "SEQACT2T", "SPLITACT2LOC2", "SPLITACT2T", "PARACT1T", "SEQACT1T", "NMACT1T", "PARACT1", "REPETITIONS", "SIMPLEMVMT", "STRGHTMVMT", "CRCLRMVMT", "REPLACE", "SPLITREPLACETL", "REPLACETAIL1", "HSFINGERITEM", "LOCBODY", "MOVINGREPETITION", "SEQACT1", "SEQFUSEDACT2T", "SEQFUSEDACT1T", "SEQFUSEDACT1", "CNTCTOHHAND", "CNTCTOHARM"],
FOLLOW_hamsignseq_in_hamsinglesign734: new org.antlr.runtime.BitSet([0x00000000, 0x00000000]),
FOLLOW_EOF_in_hamsinglesign744: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sign2or1_in_hamsignseq812: new org.antlr.runtime.BitSet([0x00008002, 0x00000000]),
FOLLOW_HamPlus_in_hamsignseq844: new org.antlr.runtime.BitSet([0xFC000000, 0x000043F3,0x00000000, 0x00000000,0x00000020, 0x04000008]),
FOLLOW_sign2or1_in_hamsignseq864: new org.antlr.runtime.BitSet([0x00008002, 0x00000000]),
FOLLOW_nondomsign1_in_sign2or1951: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sign2_in_sign2or1967: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_symmoperator_in_sign21008: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000008]),
FOLLOW_initialconfig2_in_sign21018: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a2tstar_in_sign21028: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_initialconfig2_in_sign21061: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21071: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_sign21137: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
FOLLOW_HamNondominant_in_sign21147: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_sign21157: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21167: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_sign21202: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_sign21212: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_sign21222: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNondominant_in_nondomsign11274: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_nondomsign11284: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tstar_in_nondomsign11294: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_symmoperator1352: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator1424: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator1440: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator1467: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator1483: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamAlternatingmotion_in_symmoperator1509: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
FOLLOW_HamNonipsi_in_symmoperator1524: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig21561: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000008]),
FOLLOW_minitialconfig2_in_initialconfig21574: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig11633: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_minitialconfig1_in_initialconfig11646: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nmicunit_in_nminitialconfig1717: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_HamSeqbegin_in_nmicunit1780: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x00000FFF]),
FOLLOW_levelbody_in_nmicunit1811: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelarm_in_nmicunit1833: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_nmicunit1853: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_nmicunit1863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig2_in_minitialconfig21961: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_minitialconfig22017: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_minitialconfig22060: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_minitialconfig22071: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_HamPlus_in_minitialconfig22127: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_minitialconfig22142: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_minitialconfig22156: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1_in_minitialconfig22200: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_minitialconfig22214: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x00000010]),
FOLLOW_location1_in_minitialconfig22233: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_minitialconfig22250: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig12324: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_minitialconfig12336: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_handconfig22441: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_handconfigtail2_in_handconfig22451: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_handconfig22506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splithandconfig2_in_handconfig22535: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape1_in_handconfig12584: new org.antlr.runtime.BitSet([0x00000002, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfig12608: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfig12622: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splithandconfig22692: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_splithandconfig22703: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splithandconfig22713: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_handconfig1_in_splithandconfig22724: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splithandconfig22734: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir2_in_handconfigtail22823: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_palmor2_in_handconfigtail22833: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handconfigtail22863: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22876: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfigtail22888: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handconfigtail22898: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22911: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_handconfigtail22923: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handconfigtail22933: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape1_in_handshape23006: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handshape23035: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_handshape1_in_handshape23050: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handshape23060: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_handshape1_in_handshape23075: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handshape23085: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_basichandshape1_in_handshape13136: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_cautiousfingerlist_in_handshape13201: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13215: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13229: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_thumbbetweenexplicit_in_handshape13243: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_cautiousfingerlist_in_handshape13321: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13335: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13349: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbspecial_in_handshape13373: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerlist_in_handshape13454: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13468: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13482: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbbetweendefault_in_handshape13498: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_handshape13502: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerlist_in_handshape13535: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingershapelist_in_handshape13549: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_fingercrossinglist_in_handshape13563: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_basichandshape_in_basichandshape13649: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_basichandshape13714: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3]),
FOLLOW_basichandshape_in_basichandshape13729: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshapeclass_in_basichandshape3797: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C,0x00020000, 0x00000000]),
FOLLOW_HamNondominant_in_basichandshape3821: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_basichandshape3843: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C]),
FOLLOW_handbendandthumb_in_basichandshape3856: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbpos_in_handbendandthumb3927: new org.antlr.runtime.BitSet([0x00000002, 0x0001BC0C]),
FOLLOW_fingerbending_in_handbendandthumb3939: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerbending_in_handbendandthumb3958: new org.antlr.runtime.BitSet([0x00000002, 0x0000040C]),
FOLLOW_thumbpos_in_handbendandthumb3970: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingerlist_in_fingerlist4002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_recfingerlist4111: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingerlist_in_recfingerlist4125: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_reccautiousfingerlist_in_cautiousfingerlist4165: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_reccautiousfingerlist4268: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_reccautiousfingerlist_in_reccautiousfingerlist4282: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingershapelist_in_fingershapelist4322: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingershape_in_recfingershapelist4426: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingershapelist_in_recfingershapelist4440: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_recfingercrossinglist_in_fingercrossinglist4480: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingercrossing_in_recfingercrossinglist4581: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_recfingercrossinglist_in_recfingercrossinglist4595: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_hsfingeritem4651: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000]),
FOLLOW_HamLargemod_in_hsfingeritem4663: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_digit4723: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_digit4733: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_hsdigit4783: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_hsdigit4793: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_fingershape4822: new org.antlr.runtime.BitSet([0x00000000, 0x0001BC0C]),
FOLLOW_fingerbending_in_fingershape4832: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_fingercrossing4892: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7E000000]),
FOLLOW_fingerpart_in_fingercrossing4902: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_fingercrossing4916: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetween_in_thumbspecial4976: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_thumbspecial4986: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetweenexplicit_in_thumbbetween5015: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbbetweendefault_in_thumbbetween5025: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_thumbbetweenexplicit5054: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_thumbbetweenexplicit5064: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_thumbbetweenexplicit5075: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBetween_in_thumbbetweendefault5134: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumb_in_thumbextra5200: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_thumbextra5216: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_extfidir25282: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitextfidir2_in_extfidir25298: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitextfidir25349: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_splitextfidir25361: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitextfidir25371: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_splitextfidir25383: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitextfidir25393: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir_in_extfidir15424: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x01000000]),
FOLLOW_HamBetween_in_extfidir15448: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir_in_extfidir15462: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_extfidir15497: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_palmor25569: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitpalmor2_in_palmor25585: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitpalmor25636: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_splitpalmor25648: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitpalmor25658: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_splitpalmor25670: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitpalmor25680: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor_in_palmor15711: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00060000, 0x01000000]),
FOLLOW_HamBetween_in_palmor15735: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor_in_palmor15749: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamEtc_in_palmor15767: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_palmor15802: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1as2_in_location25877: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location2not1_in_location25893: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location1_in_location1as25928: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_location2not16006: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFF80038, 0x000000FF]),
FOLLOW_HamNeutralspace_in_location2not16030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000]),
FOLLOW_HamArmextended_in_location2not16046: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbody_in_location2not16075: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_location2not16123: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_location2not16133: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_location2not16143: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_location2not16153: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_location2not16163: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexuse_in_location16268: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationhand_in_location16308: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbodyarm_in_location16324: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_locationindexdefine6384: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000008, 0x00000000]),
FOLLOW_HamCoreftag_in_locationindexdefine6394: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_digit_in_locationindexuse6431: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamCorefref_in_locationindexuse6441: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNeutralspace_in_locationbodyarm6484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000]),
FOLLOW_HamArmextended_in_locationbodyarm6496: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationbody_in_locationbodyarm6539: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationarm_in_locationbodyarm6555: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexbody_in_locationbody6609: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00018000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_HamBehind_in_locationbody6621: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contactbody_in_locationbody6644: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexhand_in_locationhand6705: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contacthand_in_locationhand6723: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexarm_in_locationarm6781: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00018000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_HamBehind_in_locationarm6793: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contactbody_in_locationarm6816: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody6877: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexbody6901: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_levelbody_in_levelcomplexbody6917: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand6957: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexhand6981: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_levelhand_in_levelcomplexhand6997: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm7037: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_levelcomplexarm7061: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x00000FFF]),
FOLLOW_levelarm_in_levelcomplexarm7077: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locbody_in_levelbody7129: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000000FF]),
FOLLOW_HamEtc_in_levelbody7141: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelbody7156: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locsided_in_levelbody7194: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000000FF]),
FOLLOW_HamEtc_in_levelbody7206: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelbody7221: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelbody7259: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x0000003F]),
FOLLOW_locbody_in_levelbody7283: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_levelbody7299: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locsided_in_levelbody7326: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_levelbody7342: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_lochand_in_levelhand7424: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000180FF]),
FOLLOW_dorsalorpalmar_in_levelhand7436: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelhand7451: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelhand7488: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7EFFF000]),
FOLLOW_lochand_in_levelhand7498: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00018000]),
FOLLOW_dorsalorpalmar_in_levelhand7510: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locarm_in_levelarm7577: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFBA0038, 0x000180FF]),
FOLLOW_HamEtc_in_levelarm7589: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000180FF]),
FOLLOW_dorsalorpalmar_in_levelarm7604: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0xFFB80038, 0x000000FF]),
FOLLOW_side_in_levelarm7619: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_side_in_levelarm7660: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000F00]),
FOLLOW_locarm_in_levelarm7670: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00018000]),
FOLLOW_HamEtc_in_levelarm7682: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00018000]),
FOLLOW_dorsalorpalmar_in_levelarm7697: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_pcontact_in_contactbody7768: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArmextended_in_contactbody7784: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactofhand_in_contactbody7800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_pcontact_in_contacthand7866: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ccontact_in_contacthand7882: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactofhand_in_contacthand7898: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_handconstellation7966: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_locationhand_in_handconstellation7981: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_handconstellation7995: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB80038, 0x7EFFF0FF]),
FOLLOW_locationhand_in_handconstellation8010: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_handconstellation8024: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0401E008]),
FOLLOW_contacthand_in_handconstellation8046: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_contactofhand8100: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x0001E000]),
FOLLOW_pcontact_in_contactofhand8125: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_ccontact_in_contactofhand8149: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_contactohhand_in_contactofhand8215: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_contactoharm_in_contactofhand8239: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_contactofhand8259: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexhand_in_contactohhand8321: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelcomplexarm_in_contactoharm8372: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handpart_in_lochand8435: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_lochand8451: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_lochand8463: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_lochand8484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x7E3E0000]),
FOLLOW_fingerpart_in_lochand8499: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_a2tlist_in_a2tstar8540: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_a1tlist_in_a1tstar8592: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action2t_in_a2tlist8664: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a2tlist_in_a2tlist8678: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_a1tlist8738: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_a1tlist_in_a1tlist8752: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action2t8830: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2not1_in_action2t8840: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action2t8850: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_action2t8908: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitaction2loc2_in_action2t9017: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_splitaction2t_in_action2t9082: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_paraction2t_in_action2t9106: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqaction2t_in_action2t9130: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqfusedaction2t_in_action2t9154: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action2t9174: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action1t9308: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x37C1E008]),
FOLLOW_handconstellation_in_action1t9396: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_location1_in_action1t9436: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x37C00000]),
FOLLOW_HamLargemod_in_action1t9460: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_paraction1t_in_action1t9520: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqnmoraction1t_in_action1t9544: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_seqfusedaction1t_in_action1t9569: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x37C00000]),
FOLLOW_repetitionsoption_in_action1t9589: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_action19725: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_simplemovement_in_action19754: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_modifier_in_action19780: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x003E0000]),
FOLLOW_HamLargemod_in_action19799: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_specialfingerplaymovement_in_action19874: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_paraction1_in_action19903: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_seqaction1_in_action19932: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_seqfusedaction1_in_action19961: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_action1seq9997: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_action1tseq10009: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParbegin_in_paraction2t10036: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_paraction2t10049: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction2t10062: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqaction2t10115: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_seqaction2t10128: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqaction2t10141: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction2t10194: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action2t_in_seqfusedaction2t10207: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction2t10220: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitaction2loc210273: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1seq_in_splitaction2loc210286: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2loc210296: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1seq_in_splitaction2loc210308: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitaction2loc210318: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_splitaction2loc210329: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitaction2t10388: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1tseq_in_splitaction2t10401: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2t10411: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1tseq_in_splitaction2t10423: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitaction2t10433: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_paraction1t10497: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_paraction1t10510: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction1t10523: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqnmoraction1t10582: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFB84038, 0x00000FFF,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelbody_in_seqnmoraction1t10613: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_levelarm_in_seqnmoraction1t10625: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_seqnmoraction1t10635: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_action1t_in_seqnmoraction1t10671: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqnmoraction1t10708: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction1t10753: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_seqfusedaction1t10766: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction1t10779: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_paraction110837: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_paraction110850: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_paraction110863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_seqaction110921: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_seqaction110934: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x0C0007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamSeqend_in_seqaction110947: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFusionbegin_in_seqfusedaction111005: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_seqfusedaction111018: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFFF80, 0x00000000]),
FOLLOW_HamFusionend_in_seqfusedaction111031: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_repetitions_in_repetitionsoption11146: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_repetitions11226: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_HamRepeatfromstartseveral_in_repetitions11237: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_repetitions11247: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_repetitions11257: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_repetitions11267: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_repetition_in_repetitions11314: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x33C01800]),
FOLLOW_HamEtc_in_repetitions11346: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_repetition_in_repetitions11378: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_movingrepetition_in_repetitions11417: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_sizechangenonlinear_in_repetitions11439: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11466: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11482: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11537: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions11549: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_alternations11600: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_alternations11612: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_movingrepetition11650: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x23C00000]),
FOLLOW_repetition_in_movingrepetition11661: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_movingrepetition11671: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x08001800]),
FOLLOW_size_in_movingrepetition11683: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08001800]),
FOLLOW_sizechangenonlinear_in_movingrepetition11698: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_movingrepetition11711: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_straightmovement_in_simplemovement11792: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0xFC000000, 0x04000003]),
FOLLOW_size_in_simplemovement11808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0xF0000000, 0x04000003]),
FOLLOW_arckind_in_simplemovement11843: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_zigzag_in_simplemovement11875: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_circularmovement_in_simplemovement11914: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_simplemovement11930: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_revolutions_in_simplemovement11949: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800,0x0000000F, 0x00000000]),
FOLLOW_ellipse_in_simplemovement11968: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04001800]),
FOLLOW_sizechangenonlinear_in_simplemovement11987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_movementcross_in_simplemovement12014: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04000000]),
FOLLOW_size_in_simplemovement12030: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_wristmovement_in_simplemovement12057: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x0C000000, 0x04000000]),
FOLLOW_size_in_simplemovement12073: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_replacement_in_simplemovement12100: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_HamFingerplay_in_simplemovement12124: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x04000000]),
FOLLOW_brushingcontact_in_simplemovement12186: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_locationindexdefine_in_simplemovement12281: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_specialfingerplaymovement12441: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_specialfingerplaymovement12454: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x00000004]),
FOLLOW_HamFingerplay_in_specialfingerplaymovement12467: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_specialfingerplaymovement12477: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement12522: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_straightmovement12546: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement12561: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement12614: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_HamBetween_in_circularmovement12638: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000007E0,0x03FFC000, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement12653: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_arc_in_arckind12706: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000000]),
FOLLOW_arc_in_arckind12718: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_arckind12733: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_zigzag12765: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_zigzag12825: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_zigzag12840: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_zigzag12855: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sizechange_in_sizechangenonlinear12887: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_sizechangenonlinear12899: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ellipsedirection_in_ellipse12931: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_ellipse12943: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_clock_in_revolutions12987: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13011: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13027: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions13053: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13072: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions13084: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions13099: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamReplace_in_replacement13137: new org.antlr.runtime.BitSet([0xF0000000, 0xFFFE43F3,0x00003FC7, 0x00000000,0x00000000, 0x00001808]),
FOLLOW_sizechange_in_replacement13150: new org.antlr.runtime.BitSet([0xF0000000, 0xFFFE43F3,0x00003FC7, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_handshape1_in_replacement13177: new org.antlr.runtime.BitSet([0x00000002, 0xFFFE0000,0x00003FC7, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_splitreplacetail_in_replacement13249: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacement13283: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacement13306: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitreplacetail_in_replacement13372: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacement13411: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacement13427: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_replacement13472: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_splitreplacetail13526: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00003FC7, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail13537: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_splitreplacetail13547: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00003FC7, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_HamNomotion_in_splitreplacetail13572: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_replacetail1_in_splitreplacetail13597: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000010]),
FOLLOW_HamParend_in_splitreplacetail13617: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir1_in_replacetail113681: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00003FC0, 0x00000000]),
FOLLOW_palmor1_in_replacetail113693: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_palmor1_in_replacetail113712: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_brushingcontact13768: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_brushingcontact13780: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF]),
FOLLOW_location1_in_brushingcontact13790: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_HamSeqend_in_brushingcontact13800: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_handshapeclasstok13836: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshapeclasstok_in_handshapeclass13972: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_fingerbendingtok14009: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerbendingtok_in_fingerbending14073: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_thumbpostok14115: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbpostok_in_thumbpos14159: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumb_in_thumb14199: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_finger0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_fingerpart0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeru_in_extfidirtok14372: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerur_in_extfidirtok14382: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerr_in_extfidirtok14392: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdr_in_extfidirtok14402: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerd_in_extfidirtok14412: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdl_in_extfidirtok14422: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerl_in_extfidirtok14432: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerul_in_extfidirtok14442: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerol_in_extfidirtok14466: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_set_in_extfidirtok14480: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingero_in_extfidirtok14551: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidirtok14575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_set_in_extfidirtok14589: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeril_in_extfidirtok14674: new org.antlr.runtime.BitSet([0x00000002, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_set_in_extfidirtok14688: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeri_in_extfidirtok14759: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidirtok14783: new org.antlr.runtime.BitSet([0x00000002, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_set_in_extfidirtok14797: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidirtok14882: new org.antlr.runtime.BitSet([0x00000002, 0x50000000]),
FOLLOW_set_in_extfidirtok14896: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidirtok14981: new org.antlr.runtime.BitSet([0x00000002, 0x50000000]),
FOLLOW_set_in_extfidirtok14995: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidirtok15080: new org.antlr.runtime.BitSet([0x00000002, 0x0A000000]),
FOLLOW_set_in_extfidirtok15094: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidirtok15179: new org.antlr.runtime.BitSet([0x00000002, 0x0A000000]),
FOLLOW_set_in_extfidirtok15193: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidirtok_in_extfidir15274: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_palmor0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locarm0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHead_in_locbodytok15476: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHeadtop_in_locbodytok15486: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamForehead_in_locbodytok15496: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEyebrows_in_locbodytok15506: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNose_in_locbodytok15516: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNostrils_in_locbodytok15526: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTongue_in_locbodytok15536: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locbodytok15560: new org.antlr.runtime.BitSet([0x00000002, 0x00018000]),
FOLLOW_set_in_locbodytok15642: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamChin_in_locbodytok15713: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamUnderchin_in_locbodytok15723: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNeck_in_locbodytok15733: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamShouldertop_in_locbodytok15743: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamShoulders_in_locbodytok15753: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamChest_in_locbodytok15763: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStomach_in_locbodytok15773: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBelowstomach_in_locbodytok15783: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locbodytok_in_locbody15803: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_locsided0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_handpart0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_side0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_dorsalorpalmar0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_pcontact0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_ccontact0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_sizechange0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_repetition0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementarrow0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementcross0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_wristmovement0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_movementcircle0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_ellipsedirection0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_clock0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_modifier0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_arc0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_set_in_size0: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNondominant_in_synpred1_Ham4Parser927: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_synpred1_Ham4Parser929: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNomotion_in_synpred2_Ham4Parser1111: new org.antlr.runtime.BitSet([0x00000000, 0x00004000]),
FOLLOW_HamNondominant_in_synpred2_Ham4Parser1113: new org.antlr.runtime.BitSet([0xF0000000, 0x000043F3,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_initialconfig1_in_synpred2_Ham4Parser1115: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred3_Ham4Parser1805: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconfig2_in_synpred4_Ham4Parser1939: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_location2_in_synpred5_Ham4Parser1987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPlus_in_synpred6_Ham4Parser2097: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_synpred7_Ham4Parser2410: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_HamParbegin_in_synpred7_Ham4Parser2414: new org.antlr.runtime.BitSet([0x00000000, 0xFFFE0000,0x00000007, 0x00000000]),
FOLLOW_extfidir1_in_synpred7_Ham4Parser2419: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handshape2_in_synpred8_Ham4Parser2484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_extfidir2_in_synpred9_Ham4Parser2801: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred10_Ham4Parser3164: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x013E0000]),
FOLLOW_HamBetween_in_synpred10_Ham4Parser3169: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_synpred10_Ham4Parser3171: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsdigit_in_synpred11_Ham4Parser3278: new org.antlr.runtime.BitSet([0x00000000, 0x0001BC0C,0x00000000, 0x7E3E0000]),
FOLLOW_fingerbending_in_synpred11_Ham4Parser3285: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingerpart_in_synpred11_Ham4Parser3289: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbspecial_in_synpred12_Ham4Parser3367: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred13_Ham4Parser3411: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7F3E0000]),
FOLLOW_thumbbetweendefault_in_synpred13_Ham4Parser3418: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_thumbextra_in_synpred13_Ham4Parser3422: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamBetween_in_synpred14_Ham4Parser3675: new org.antlr.runtime.BitSet([0xF0000000, 0x000003F3]),
FOLLOW_handshapeclass_in_synpred14_Ham4Parser3677: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred15_Ham4Parser4081: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_hsfingeritem_in_synpred16_Ham4Parser4236: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_synpred16_Ham4Parser4238: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingershape_in_synpred17_Ham4Parser4396: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_fingercrossing_in_synpred18_Ham4Parser4551: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_synpred19_Ham4Parser5984: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexuse_in_synpred20_Ham4Parser6226: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_synpred21_Ham4Parser6286: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred22_Ham4Parser6517: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactbody_in_synpred23_Ham4Parser6638: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contacthand_in_synpred24_Ham4Parser6718: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_contactbody_in_synpred25_Ham4Parser6810: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_synpred26_Ham4Parser8185: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_synpred27_Ham4Parser8806: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2not1_in_synpred27_Ham4Parser8808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1t_in_synpred28_Ham4Parser8886: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_synpred29_Ham4Parser8953: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_synpred29_Ham4Parser8957: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamPlus_in_synpred29_Ham4Parser8962: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1_in_synpred29_Ham4Parser8980: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007FC,0x03FFDF80, 0x00000000]),
FOLLOW_HamParend_in_synpred29_Ham4Parser8985: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0xFFF80038, 0x7EFFFFFF,0x00000000, 0x0401E008]),
FOLLOW_location2_in_synpred29_Ham4Parser8987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamParbegin_in_synpred30_Ham4Parser9043: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_action1t_in_synpred30_Ham4Parser9047: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00004000, 0x00000000,0x03FFFFE0, 0x040007EC,0x03FFDF80, 0x00000000]),
FOLLOW_HamPlus_in_synpred30_Ham4Parser9052: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_action1_in_synpred31_Ham4Parser9260: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_handconstellation_in_synpred32_Ham4Parser9350: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred33_Ham4Parser9850: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_synpred33_Ham4Parser9852: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelbody_in_synpred34_Ham4Parser10607: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred35_Ham4Parser11107: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x23C00000]),
FOLLOW_repetition_in_synpred35_Ham4Parser11112: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_synpred35_Ham4Parser11116: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred36_Ham4Parser11200: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_HamRepeatfromstartseveral_in_synpred36_Ham4Parser11202: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00020000, 0x00000000]),
FOLLOW_HamEtc_in_synpred36_Ham4Parser11204: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSeqbegin_in_synpred37_Ham4Parser12158: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_synpred37_Ham4Parser12160: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_locationindexdefine_in_synpred38_Ham4Parser12255: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_splitreplacetail_in_synpred39_Ham4Parser13211: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});
})();//-------- js/HMLBuilder.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   A DOM creator for Gestural SiGML
var Data, Defs, HMLBuilder, Logger, cwaenv, document, lggr;
cwaenv = this.getCWAEnv();
document = this.document;
Data = cwaenv.get("Data");
Defs = cwaenv.get("HNSDefs");
Logger = cwaenv.get("Logger");
// Enhanced if run from HtoG tool
lggr = Logger.get("SiGML");
HMLBuilder = class HMLBuilder {
constructor() {
this.doc = Data.toDOM("<sign/>");
if (typeof lggr.debug === "function") {
lggr.debug("Sign document created");
}
}
newHMLElement(tag) {
if (typeof lggr.trace === "function") {
lggr.trace(`HML: newHMLElement(${tag})`);
}
return this.doc.createElement(tag);
}
// newHMLAttr: Not used from HMLGen
// newHMLComment: Not used from HMLGen
wrapperEl(tag, inner) {
var wel;
if (typeof lggr.trace === "function") {
lggr.trace(`HML: wrapperEl(${tag})`);
}
wel = this.newHMLElement(tag);
wel.appendChild(inner);
return wel;
}
wrapPair(tag, inner0, inner1) {
var wel;
if (typeof lggr.trace === "function") {
lggr.trace(`HML: wrapPair(${tag})`);
}
wel = this.wrapperEl(tag, inner0);
wel.appendChild(inner1);
return wel;
}
wrapIfNeeded(tag, el) {
var elIsOK;
elIsOK = el.tagName === tag && !(el.hasAttributes());
if (typeof lggr.trace === "function") {
lggr.trace(`HML: wrapIfNeeded(${tag}) Needed is ${elIsOK}`);
}
if (elIsOK) {
return el;
} else {
return this.wrapperEl(tag, el);
}
}
stripParentIfNotNeeded(el) {
var child, res;
if (typeof lggr.trace === "function") {
lggr.trace("HML: stripParentIfNotNeeded");
}
res = el;
// Assume always an element
child = el.firstChild;
if (typeof lggr.trace === "function") {
lggr.trace(`HML: Child ${child} Element name ${el.tagName}`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`HML: Element\n${Data.ppDOM(el)}`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`HML: Child\n${Data.ppDOM(child)}`);
}
//for elm in el.childNodes
//  lggr.trace? "HML: Child elem\n#{Data.ppDOM elm}"
if (el.tagName === (child != null ? child.tagName : void 0) && !(el.hasAttributes())) {
if (typeof lggr.trace === "function") {
lggr.trace("HML: stripParentIfNotNeeded removing child");
}
res = el.removeChild(child);
}
return res;
}
elementFromList(al, etag) {
var e, elmem, i, ix, len;
if (typeof lggr.trace === "function") {
lggr.trace(`HML: elementFromList ${etag} length ${al.length}`);
}
if (al.length === 1) {
return al[0];
} else {
e = this.newHMLElement(etag);
for (ix = i = 0, len = al.length; i < len; ix = ++i) {
elmem = al[ix];
if (typeof lggr.trace === "function") {
lggr.trace(`HML: elementFromList ${etag} append child ${ix} ${elmem.tagName}`);
}
e.appendChild(elmem);
}
return e;
}
}
// insertNonManual: Defined below
// setDocRoot: Not used from HMLGen
// parseElement: Not used from HMLGen
rootEl(inner) {
this.doc.documentElement.appendChild(inner);
return this.doc;
}
appendChildList(el, chl) {
var chlel, i, len, results;
results = [];
for (i = 0, len = chl.length; i < len; i++) {
chlel = chl[i];
// Now checking for null elements
results.push(this.checkedAppendChild(el, chlel));
}
return results;
}
checkedAppendChildList(el, chl) {
if (chl != null) {
return this.appendChildList(el, chl);
}
}
checkedAppendChild(el, ch) {
if (ch != null) {
return el.appendChild(ch);
}
}
checkedSetAttr(el, aname, aval) {
if (aval != null) {
if (typeof lggr.trace === "function") {
lggr.trace(`HML: checkedSetAttr: ${aname} set to ${aval}`);
}
return el.setAttribute(aname, aval);
} else {
return typeof lggr.trace === "function" ? lggr.trace(`HML: checkedSetAttr: ${aname} not set`) : void 0;
}
}
checkedSetFlagAttr(el, aname, flagIsTrue) {
if (flagIsTrue) {
return el.setAttribute(aname, "true");
}
}
checkedStringSetFlagAttr(el, aname, aval) {
if (aval === "true") {
if (typeof lggr.trace === "function") {
lggr.trace(`HML: checkedStringSetFlagAttr: ${aname} set to true`);
}
return el.setAttribute(aname, "true");
} else {
return typeof lggr.trace === "function" ? lggr.trace(`HML: checkedStringSetFlagAttr: ${aname} not set for ${aval}`) : void 0;
}
}
// getLSSerializer
// Construct nonmanual element and insert in document
insertNonManual(signel, nmstr) {
var aid, aval, chEl, childtag, fullnmtag, i, len, nmEl, ref;
if (typeof lggr.debug === "function") {
lggr.debug(`HML: insertNonManual: \"${nmstr}\"`);
}
if (nmstr.length > 0) {
if (typeof lggr.trace === "function") {
lggr.trace(`NM: <${Defs.HNS_NONMAN_TAG}>`);
}
nmEl = this.newHMLElement(Defs.HNS_NONMAN_TAG);
ref = nmstr.split(/\s+/);
for (i = 0, len = ref.length; i < len; i++) {
fullnmtag = ref[i];
childtag = this._hnsNMElementTag(fullnmtag);
aid = this._hnsNMAttrName(fullnmtag);
aval = this._hnsNMAttrValueFull(fullnmtag);
if (typeof lggr.trace === "function") {
lggr.trace(`NM: <${childtag} ${aid}=\"${aval}\"/>`);
}
chEl = this.newHMLElement(childtag);
this.checkedSetAttr(chEl, aid, aval);
this.checkedAppendChild(nmEl, chEl);
}
if (typeof lggr.trace === "function") {
lggr.trace(`NM: </${Defs.HNS_NONMAN_TAG}>`);
}
signel.insertBefore(nmEl, signel.firstChild);
return typeof lggr.trace === "function" ? lggr.trace("NM: Inserted") : void 0;
}
}
_hnsNMElementTag(nmtag) {
var ID, ei, hnseltag, mgi, nmi, t;
t = (nmtag.charAt(0)).toLowerCase();
if (t === Defs.MOUTH_PICTURE_LETTER) {
return Defs.HNS_MOUTHPICTURE_TAG;
} else {
mgi = Defs.MOUTH_GESTURE_LETTERS.indexOf(t);
if (0 <= mgi) {
hnseltag = Defs.HNS_MOUTHGESTURE_TAG;
} else {
nmi = Defs.NON_MOUTH_RELATED_LETTERS.indexOf(t);
if (0 <= nmi) {
hnseltag = Defs.NON_MOUTH_RELATED_HML_TAGS[nmi];
if (hnseltag === null) {
// Eyes
ID = (nmtag.substring(1)).toUpperCase();
ei = 0;
while (ei < Defs.EYES_TAG_LISTS.length && (Defs.EYES_TAG_LISTS[ei].indexOf(ID)) < 0) {
ei++;
}
if (ei < Defs.EYES_TAG_LISTS.length) {
hnseltag = Defs.EYE_RELATED_HML_TAGS[ei];
} else {
hnseltag = Defs.HNS_EXTRA_TAG;
}
}
} else {
hnseltag = Defs.HNS_EXTRA_TAG;
}
}
return hnseltag;
}
}
_hnsNMAttrName(nmtag) {
var tagLetter;
tagLetter = (nmtag.charAt(0)).toLowerCase();
if (tagLetter === Defs.MOUTH_PICTURE_LETTER) {
return Defs.PICTURE_ATTR;
} else {
return Defs.TAG_ATTR;
}
}
_hnsNMAttrValueFull(nmtag) {
var htail, htailU, tlL, tlU;
tlL = (nmtag.charAt(0)).toLowerCase();
tlU = tlL.toUpperCase();
htail = nmtag.substring(1);
htailU = tlL === Defs.MOUTH_PICTURE_LETTER ? null : htail.toUpperCase();
if (tlL === Defs.MOUTH_PICTURE_LETTER) {
// Do not encode strings for now
// @_xmlAttrValueString htail
return htail;
} else if (0 <= Defs.MOUTH_GESTURE_LETTERS.indexOf(tlL)) {
return `${tlU}${htailU}`;
} else if (0 <= Defs.NON_MOUTH_RELATED_LETTERS.indexOf(tlL)) {
return htailU;
} else {
return `${tlU}${htailU}`;
}
}
_xmlAttrValueString(aval) {
var abuf, ch, i, len, xs;
abuf = "";
for (i = 0, len = aval.length; i < len; i++) {
ch = aval[i];
xs = Defs.xmlSpecials.indexOf(ch);
abuf += xs < 0 ? ch : Defs.xmlEscapes[xs];
}
return abuf;
}
};
// Static
// Export
cwaenv.add(HMLBuilder, "HMLBuilder");
// (End HMLBuilder.coffee)
}).call(this);
//-------- js/Ham4HMLGen.js --------
// $ANTLR 3.3 Nov 30, 2010 12:50:56 Ham4HMLGen.g 2020-05-16 18:27:08
// TreeParser header: Start
// Logger enhanced when run from HtoG Tool
var H4MLGenLogger = this.getCWAEnv().get("Logger").get("SiGML");
// TreeParser header: End
var Ham4HMLGen = function(input, state) {
if (!state) {
state = new org.antlr.runtime.RecognizerSharedState();
}
(function(){
// TreeParser members
var hBuilder = null;
this.trace = function(str) {
if (typeof H4MLGenLogger.trace === "function") H4MLGenLogger.trace(str);
};
}).call(this);
Ham4HMLGen.superclass.constructor.call(this, input, state);
/* @todo only create adaptor if output=AST */
this.adaptor = new org.antlr.runtime.tree.CommonTreeAdaptor();
};
org.antlr.lang.augmentObject(Ham4HMLGen, {
EOF: -1,
WS: 4,
HamTab: 5,
HamLinefeed: 6,
HamPagebreak: 7,
HamReturn: 8,
HamVersion40: 9,
HamSpace: 10,
HamExclaim: 11,
HamQuery: 12,
HamFullstop: 13,
HamComma: 14,
HamPlus: 15,
HamMetaalt: 16,
HamClocku: 17,
HamClockul: 18,
HamClockl: 19,
HamClockdl: 20,
HamClockd: 21,
HamClockdr: 22,
HamClockr: 23,
HamClockur: 24,
HamClockfull: 25,
HamSymmpar: 26,
HamSymmlr: 27,
HamFist: 28,
HamFlathand: 29,
HamFinger2: 30,
HamFinger23: 31,
HamFinger23spread: 32,
HamFinger2345: 33,
HamThumboutmod: 34,
HamThumbacrossmod: 35,
HamPinch12: 36,
HamPinchall: 37,
HamPinch12open: 38,
HamCee12: 39,
HamCeeall: 40,
HamCee12open: 41,
HamThumbopenmod: 42,
HamFingerstraightmod: 43,
HamFingerbendmod: 44,
HamFingerhookedmod: 45,
HamNondominant: 46,
HamDoublebent: 47,
HamDoublehooked: 48,
HamExtfingeru: 49,
HamExtfingerur: 50,
HamExtfingerr: 51,
HamExtfingerdr: 52,
HamExtfingerd: 53,
HamExtfingerdl: 54,
HamExtfingerl: 55,
HamExtfingerul: 56,
HamExtfingerol: 57,
HamExtfingero: 58,
HamExtfingeror: 59,
HamExtfingeril: 60,
HamExtfingeri: 61,
HamExtfingerir: 62,
HamExtfingerui: 63,
HamExtfingerdi: 64,
HamExtfingerdo: 65,
HamExtfingeruo: 66,
HamEarlobe: 67,
HamNostrils: 68,
HamShouldertop: 69,
HamPalmu: 70,
HamPalmur: 71,
HamPalmr: 72,
HamPalmdr: 73,
HamPalmd: 74,
HamPalmdl: 75,
HamPalml: 76,
HamPalmul: 77,
HamReplace: 78,
HamArmextended: 79,
HamBehind: 80,
HamEtc: 81,
HamOrirelative: 82,
HamTongue: 83,
HamTeeth: 84,
HamStomach: 85,
HamNeutralspace: 86,
HamHead: 87,
HamHeadtop: 88,
HamForehead: 89,
HamEyebrows: 90,
HamEyes: 91,
HamNose: 92,
HamEar: 93,
HamCheek: 94,
HamLips: 95,
HamChin: 96,
HamUnderchin: 97,
HamNeck: 98,
HamShoulders: 99,
HamChest: 100,
HamBelowstomach: 101,
HamLrbeside: 102,
HamLrat: 103,
HamUpperarm: 104,
HamElbow: 105,
HamElbowinside: 106,
HamLowerarm: 107,
HamWristback: 108,
HamWristpulse: 109,
HamThumbball: 110,
HamPalm: 111,
HamHandback: 112,
HamThumb: 113,
HamIndexfinger: 114,
HamMiddlefinger: 115,
HamRingfinger: 116,
HamPinky: 117,
HamThumbside: 118,
HamPinkyside: 119,
HamBetween: 120,
HamFingertip: 121,
HamFingernail: 122,
HamFingerpad: 123,
HamFingermidjoint: 124,
HamFingerbase: 125,
HamFingerside: 126,
HamWristtopulse: 127,
HamWristtoback: 128,
HamWristtothumb: 129,
HamWristtopinky: 130,
HamCoreftag: 131,
HamCorefref: 132,
HamNomotion: 133,
HamMoveu: 134,
HamMoveur: 135,
HamMover: 136,
HamMovedr: 137,
HamMoved: 138,
HamMovedl: 139,
HamMovel: 140,
HamMoveul: 141,
HamMoveol: 142,
HamMoveo: 143,
HamMoveor: 144,
HamMoveil: 145,
HamMovei: 146,
HamMoveir: 147,
HamMoveui: 148,
HamMovedi: 149,
HamMovedo: 150,
HamMoveuo: 151,
HamMovecross: 152,
HamMovex: 153,
HamSmallmod: 154,
HamLargemod: 155,
HamArcl: 156,
HamArcu: 157,
HamArcr: 158,
HamArcd: 159,
HamWavy: 160,
HamZigzag: 161,
HamFingerplay: 162,
HamParbegin: 163,
HamParend: 164,
HamCircleo: 165,
HamCirclei: 166,
HamCircled: 167,
HamCircleu: 168,
HamCirclel: 169,
HamCircler: 170,
HamIncreasing: 171,
HamDecreasing: 172,
HamClose: 173,
HamTouch: 174,
HamInterlock: 175,
HamCross: 176,
HamFast: 177,
HamSlow: 178,
HamTense: 179,
HamRest: 180,
HamHalt: 181,
HamRepeatfromstart: 182,
HamRepeatfromstartseveral: 183,
HamRepeatcontinue: 184,
HamRepeatcontinueseveral: 185,
HamSeqbegin: 186,
HamSeqend: 187,
HamAlternatingmotion: 188,
HamRepeatreverse: 189,
HamBrushing: 190,
HamNonipsi: 191,
HamEllipseh: 192,
HamEllipseur: 193,
HamEllipsev: 194,
HamEllipseul: 195,
HamMime: 196,
HamAltbegin: 197,
HamAltend: 198,
HamNodding: 199,
HamSwinging: 200,
HamTwisting: 201,
HamStircw: 202,
HamStirccw: 203,
HamFusionbegin: 204,
HamFusionend: 205,
HamCircleul: 206,
HamCircledr: 207,
HamCircleur: 208,
HamCircledl: 209,
HamCircleol: 210,
HamCircleir: 211,
HamCircleor: 212,
HamCircleil: 213,
HamCircledo: 214,
HamCircleui: 215,
HamCircledi: 216,
HamCircleuo: 217,
HamNbs: 218,
HAMSIGNS: 219,
SIGN2: 220,
SIGN1: 221,
ICFG2: 222,
ICFG1: 223,
NMICLIST: 224,
NMICUNIT: 225,
MICFG2: 226,
MICFG1: 227,
HDCONFIG2: 228,
HDCONFIG1: 229,
SPLITHDCFG2: 230,
HDCFGTAIL2: 231,
HSHAPE2: 232,
HSHAPE1: 233,
BASICHDSHP1: 234,
BASICHDSHP: 235,
HSCLASS: 236,
FIBENDING: 237,
THUMBPOS: 238,
FINGERLIST: 239,
FISHPLIST: 240,
FICRSSLIST: 241,
FSHAPE: 242,
FCROSSING: 243,
THSPECIAL: 244,
EXTFIDIR2: 245,
EXTFIDIR1: 246,
EXTFIDIR: 247,
PALMOR2: 248,
PALMOR1: 249,
LOC2: 250,
LOC1: 251,
LOCTNBODYARM: 252,
LOCTNBODY: 253,
LOCTNHAND: 254,
LOCTNARM: 255,
LEVBODY: 256,
LEVHAND: 257,
LEVARM: 258,
HCONSTLLN: 259,
CNTCTBODY: 260,
CNTCTHAND: 261,
CNTCTOFHAND: 262,
A2TLIST: 263,
A1TLIST: 264,
A1LIST: 265,
ACTION2T: 266,
ACTION1T: 267,
ACTION2: 268,
ACTION1: 269,
PARACT2T: 270,
SEQACT2T: 271,
SPLITACT2LOC2: 272,
SPLITACT2T: 273,
PARACT1T: 274,
SEQACT1T: 275,
NMACT1T: 276,
PARACT1: 277,
REPETITIONS: 278,
SIMPLEMVMT: 279,
STRGHTMVMT: 280,
CRCLRMVMT: 281,
REPLACE: 282,
SPLITREPLACETL: 283,
REPLACETAIL1: 284,
HSFINGERITEM: 285,
LOCBODY: 286,
MOVINGREPETITION: 287,
SEQACT1: 288,
SEQFUSEDACT2T: 289,
SEQFUSEDACT1T: 290,
SEQFUSEDACT1: 291,
CNTCTOHHAND: 292,
CNTCTOHARM: 293
});
(function(){
// public class variables
var EOF= -1,
WS= 4,
HamTab= 5,
HamLinefeed= 6,
HamPagebreak= 7,
HamReturn= 8,
HamVersion40= 9,
HamSpace= 10,
HamExclaim= 11,
HamQuery= 12,
HamFullstop= 13,
HamComma= 14,
HamPlus= 15,
HamMetaalt= 16,
HamClocku= 17,
HamClockul= 18,
HamClockl= 19,
HamClockdl= 20,
HamClockd= 21,
HamClockdr= 22,
HamClockr= 23,
HamClockur= 24,
HamClockfull= 25,
HamSymmpar= 26,
HamSymmlr= 27,
HamFist= 28,
HamFlathand= 29,
HamFinger2= 30,
HamFinger23= 31,
HamFinger23spread= 32,
HamFinger2345= 33,
HamThumboutmod= 34,
HamThumbacrossmod= 35,
HamPinch12= 36,
HamPinchall= 37,
HamPinch12open= 38,
HamCee12= 39,
HamCeeall= 40,
HamCee12open= 41,
HamThumbopenmod= 42,
HamFingerstraightmod= 43,
HamFingerbendmod= 44,
HamFingerhookedmod= 45,
HamNondominant= 46,
HamDoublebent= 47,
HamDoublehooked= 48,
HamExtfingeru= 49,
HamExtfingerur= 50,
HamExtfingerr= 51,
HamExtfingerdr= 52,
HamExtfingerd= 53,
HamExtfingerdl= 54,
HamExtfingerl= 55,
HamExtfingerul= 56,
HamExtfingerol= 57,
HamExtfingero= 58,
HamExtfingeror= 59,
HamExtfingeril= 60,
HamExtfingeri= 61,
HamExtfingerir= 62,
HamExtfingerui= 63,
HamExtfingerdi= 64,
HamExtfingerdo= 65,
HamExtfingeruo= 66,
HamEarlobe= 67,
HamNostrils= 68,
HamShouldertop= 69,
HamPalmu= 70,
HamPalmur= 71,
HamPalmr= 72,
HamPalmdr= 73,
HamPalmd= 74,
HamPalmdl= 75,
HamPalml= 76,
HamPalmul= 77,
HamReplace= 78,
HamArmextended= 79,
HamBehind= 80,
HamEtc= 81,
HamOrirelative= 82,
HamTongue= 83,
HamTeeth= 84,
HamStomach= 85,
HamNeutralspace= 86,
HamHead= 87,
HamHeadtop= 88,
HamForehead= 89,
HamEyebrows= 90,
HamEyes= 91,
HamNose= 92,
HamEar= 93,
HamCheek= 94,
HamLips= 95,
HamChin= 96,
HamUnderchin= 97,
HamNeck= 98,
HamShoulders= 99,
HamChest= 100,
HamBelowstomach= 101,
HamLrbeside= 102,
HamLrat= 103,
HamUpperarm= 104,
HamElbow= 105,
HamElbowinside= 106,
HamLowerarm= 107,
HamWristback= 108,
HamWristpulse= 109,
HamThumbball= 110,
HamPalm= 111,
HamHandback= 112,
HamThumb= 113,
HamIndexfinger= 114,
HamMiddlefinger= 115,
HamRingfinger= 116,
HamPinky= 117,
HamThumbside= 118,
HamPinkyside= 119,
HamBetween= 120,
HamFingertip= 121,
HamFingernail= 122,
HamFingerpad= 123,
HamFingermidjoint= 124,
HamFingerbase= 125,
HamFingerside= 126,
HamWristtopulse= 127,
HamWristtoback= 128,
HamWristtothumb= 129,
HamWristtopinky= 130,
HamCoreftag= 131,
HamCorefref= 132,
HamNomotion= 133,
HamMoveu= 134,
HamMoveur= 135,
HamMover= 136,
HamMovedr= 137,
HamMoved= 138,
HamMovedl= 139,
HamMovel= 140,
HamMoveul= 141,
HamMoveol= 142,
HamMoveo= 143,
HamMoveor= 144,
HamMoveil= 145,
HamMovei= 146,
HamMoveir= 147,
HamMoveui= 148,
HamMovedi= 149,
HamMovedo= 150,
HamMoveuo= 151,
HamMovecross= 152,
HamMovex= 153,
HamSmallmod= 154,
HamLargemod= 155,
HamArcl= 156,
HamArcu= 157,
HamArcr= 158,
HamArcd= 159,
HamWavy= 160,
HamZigzag= 161,
HamFingerplay= 162,
HamParbegin= 163,
HamParend= 164,
HamCircleo= 165,
HamCirclei= 166,
HamCircled= 167,
HamCircleu= 168,
HamCirclel= 169,
HamCircler= 170,
HamIncreasing= 171,
HamDecreasing= 172,
HamClose= 173,
HamTouch= 174,
HamInterlock= 175,
HamCross= 176,
HamFast= 177,
HamSlow= 178,
HamTense= 179,
HamRest= 180,
HamHalt= 181,
HamRepeatfromstart= 182,
HamRepeatfromstartseveral= 183,
HamRepeatcontinue= 184,
HamRepeatcontinueseveral= 185,
HamSeqbegin= 186,
HamSeqend= 187,
HamAlternatingmotion= 188,
HamRepeatreverse= 189,
HamBrushing= 190,
HamNonipsi= 191,
HamEllipseh= 192,
HamEllipseur= 193,
HamEllipsev= 194,
HamEllipseul= 195,
HamMime= 196,
HamAltbegin= 197,
HamAltend= 198,
HamNodding= 199,
HamSwinging= 200,
HamTwisting= 201,
HamStircw= 202,
HamStirccw= 203,
HamFusionbegin= 204,
HamFusionend= 205,
HamCircleul= 206,
HamCircledr= 207,
HamCircleur= 208,
HamCircledl= 209,
HamCircleol= 210,
HamCircleir= 211,
HamCircleor= 212,
HamCircleil= 213,
HamCircledo= 214,
HamCircleui= 215,
HamCircledi= 216,
HamCircleuo= 217,
HamNbs= 218,
HAMSIGNS= 219,
SIGN2= 220,
SIGN1= 221,
ICFG2= 222,
ICFG1= 223,
NMICLIST= 224,
NMICUNIT= 225,
MICFG2= 226,
MICFG1= 227,
HDCONFIG2= 228,
HDCONFIG1= 229,
SPLITHDCFG2= 230,
HDCFGTAIL2= 231,
HSHAPE2= 232,
HSHAPE1= 233,
BASICHDSHP1= 234,
BASICHDSHP= 235,
HSCLASS= 236,
FIBENDING= 237,
THUMBPOS= 238,
FINGERLIST= 239,
FISHPLIST= 240,
FICRSSLIST= 241,
FSHAPE= 242,
FCROSSING= 243,
THSPECIAL= 244,
EXTFIDIR2= 245,
EXTFIDIR1= 246,
EXTFIDIR= 247,
PALMOR2= 248,
PALMOR1= 249,
LOC2= 250,
LOC1= 251,
LOCTNBODYARM= 252,
LOCTNBODY= 253,
LOCTNHAND= 254,
LOCTNARM= 255,
LEVBODY= 256,
LEVHAND= 257,
LEVARM= 258,
HCONSTLLN= 259,
CNTCTBODY= 260,
CNTCTHAND= 261,
CNTCTOFHAND= 262,
A2TLIST= 263,
A1TLIST= 264,
A1LIST= 265,
ACTION2T= 266,
ACTION1T= 267,
ACTION2= 268,
ACTION1= 269,
PARACT2T= 270,
SEQACT2T= 271,
SPLITACT2LOC2= 272,
SPLITACT2T= 273,
PARACT1T= 274,
SEQACT1T= 275,
NMACT1T= 276,
PARACT1= 277,
REPETITIONS= 278,
SIMPLEMVMT= 279,
STRGHTMVMT= 280,
CRCLRMVMT= 281,
REPLACE= 282,
SPLITREPLACETL= 283,
REPLACETAIL1= 284,
HSFINGERITEM= 285,
LOCBODY= 286,
MOVINGREPETITION= 287,
SEQACT1= 288,
SEQFUSEDACT2T= 289,
SEQFUSEDACT1T= 290,
SEQFUSEDACT1= 291,
CNTCTOHHAND= 292,
CNTCTOHARM= 293;
var UP = org.antlr.runtime.Token.UP,
DOWN = org.antlr.runtime.Token.DOWN;
// public instance methods/vars
org.antlr.lang.extend(Ham4HMLGen, org.antlr.runtime.tree.TreeParser, {
getTokenNames: function() { return Ham4HMLGen.tokenNames; },
getGrammarFileName: function() { return "Ham4HMLGen.g"; }
});
org.antlr.lang.augmentObject(Ham4HMLGen.prototype, {
// Ham4HMLGen.g:43:1: hamsignseq[sb] returns [Element r = null] : ^( HAMSIGNS (s2or1= sign2or1 )* ) ;
// $ANTLR start "hamsignseq"
hamsignseq: function(sb) {
var r =  null;
var s2or1 = null;
// this.hBuilder = sb;     // Instance variable initialisation.
hBuilder = sb;     // Instance variable initialisation.
var     hss     = hBuilder.newHMLElement("hamnosys_sign");
//	Element     s2or1   = null
this.trace("HMLGen: hamsignseq starts "+this.state.backtracking);
try {
// Ham4HMLGen.g:58:5: ( ^( HAMSIGNS (s2or1= sign2or1 )* ) )
// Ham4HMLGen.g:59:2: ^( HAMSIGNS (s2or1= sign2or1 )* )
this.match(this.input,HAMSIGNS,Ham4HMLGen.FOLLOW_HAMSIGNS_in_hamsignseq149); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:60:3: (s2or1= sign2or1 )*
loop1:
do {
var alt1=2;
var LA1_0 = this.input.LA(1);
if ( ((LA1_0>=SIGN2 && LA1_0<=SIGN1)) ) {
alt1=1;
}
switch (alt1) {
case 1 :
// Ham4HMLGen.g:61:4: s2or1= sign2or1
this.pushFollow(Ham4HMLGen.FOLLOW_sign2or1_in_hamsignseq164);
s2or1=this.sign2or1();
this.state._fsp--;
hss.appendChild(s2or1); 
break;
default :
break loop1;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
r = hBuilder.rootEl(hss);
this.trace("HMLGen: hamsignseq finish "+this.state.backtracking);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return r;
},
// Ham4HMLGen.g:72:1: sign2or1 returns [Element rsgn = null] : (rsgn1= sign2 | rsgn2= nondomsign1 ) ;
// $ANTLR start "sign2or1"
sign2or1: function() {
var rsgn =  null;
var rsgn1 = null;
var rsgn2 = null;
try {
// Ham4HMLGen.g:76:5: ( (rsgn1= sign2 | rsgn2= nondomsign1 ) )
// Ham4HMLGen.g:77:5: (rsgn1= sign2 | rsgn2= nondomsign1 )
// Ham4HMLGen.g:77:5: (rsgn1= sign2 | rsgn2= nondomsign1 )
var alt2=2;
var LA2_0 = this.input.LA(1);
if ( (LA2_0==SIGN2) ) {
alt2=1;
}
else if ( (LA2_0==SIGN1) ) {
alt2=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 2, 0, this.input);
throw nvae;
}
switch (alt2) {
case 1 :
// Ham4HMLGen.g:78:9: rsgn1= sign2
this.pushFollow(Ham4HMLGen.FOLLOW_sign2_in_sign2or1246);
rsgn1=this.sign2();
this.state._fsp--;
rsgn = rsgn1; 
break;
case 2 :
// Ham4HMLGen.g:80:9: rsgn2= nondomsign1
this.pushFollow(Ham4HMLGen.FOLLOW_nondomsign1_in_sign2or1273);
rsgn2=this.nondomsign1();
this.state._fsp--;
rsgn = rsgn2; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:84:1: sign2 returns [Element rsgn = null] : ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) ) ;
// $ANTLR start "sign2"
sign2: function() {
var rsgn =  null;
var sym = null;
var icpair = null;
var atlst = null;
var     holdover    = false;
var     nondominant = false;
try {
// Ham4HMLGen.g:91:5: ( ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) ) )
// Ham4HMLGen.g:92:5: ^( SIGN2 (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar ) )
this.match(this.input,SIGN2,Ham4HMLGen.FOLLOW_SIGN2_in_sign2324); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:93:9: (sym= symmoperator icpair= initialconfig2 atlst= a2tstar | icpair= initialconfig2 atlst= a1tstar | HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar )
var alt4=3;
switch ( this.input.LA(1) ) {
case HamSymmpar:
case HamSymmlr:
alt4=1;
break;
case ICFG2:
alt4=2;
break;
case HamNomotion:
alt4=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 4, 0, this.input);
throw nvae;
}
switch (alt4) {
case 1 :
// Ham4HMLGen.g:94:13: sym= symmoperator icpair= initialconfig2 atlst= a2tstar
this.pushFollow(Ham4HMLGen.FOLLOW_symmoperator_in_sign2356);
sym=this.symmoperator();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig2_in_sign2375);
icpair=this.initialconfig2();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a2tstar_in_sign2395);
atlst=this.a2tstar();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:98:13: icpair= initialconfig2 atlst= a1tstar
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig2_in_sign2424);
icpair=this.initialconfig2();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_sign2444);
atlst=this.a1tstar();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:102:13: HamNomotion ( HamNondominant )? icpair= initialconfig1 atlst= a1tstar
this.match(this.input,HamNomotion,Ham4HMLGen.FOLLOW_HamNomotion_in_sign2481); 
holdover = true; 
// Ham4HMLGen.g:103:13: ( HamNondominant )?
var alt3=2;
var LA3_0 = this.input.LA(1);
if ( (LA3_0==HamNondominant) ) {
alt3=1;
}
switch (alt3) {
case 1 :
// Ham4HMLGen.g:103:15: HamNondominant
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_sign2515); 
nondominant = true; 
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig1_in_sign2550);
icpair=this.initialconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_sign2570);
atlst=this.a1tstar();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsgn = hBuilder.newHMLElement("sign2");
hBuilder.checkedAppendChild(rsgn, sym);
hBuilder.checkedAppendChild(rsgn, icpair[0]);
hBuilder.checkedAppendChild(rsgn, icpair[1]);
hBuilder.checkedAppendChildList(rsgn, atlst);
hBuilder.checkedSetFlagAttr(rsgn, "nondominant", nondominant);
hBuilder.checkedSetFlagAttr(rsgn, "holdover", holdover);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:119:1: nondomsign1 returns [Element rsgn = null] : ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar ) ;
// $ANTLR start "nondomsign1"
nondomsign1: function() {
var rsgn =  null;
var icpair = null;
var atlst = null;
try {
// Ham4HMLGen.g:123:5: ( ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar ) )
// Ham4HMLGen.g:124:5: ^( SIGN1 HamNondominant icpair= initialconfig1 atlst= a1tstar )
this.match(this.input,SIGN1,Ham4HMLGen.FOLLOW_SIGN1_in_nondomsign1624); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_nondomsign1644); 
this.pushFollow(Ham4HMLGen.FOLLOW_initialconfig1_in_nondomsign1659);
icpair=this.initialconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_a1tstar_in_nondomsign1675);
atlst=this.a1tstar();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsgn = hBuilder.newHMLElement("sign1");
hBuilder.checkedSetAttr(rsgn, "which_hand", "nondominant");
hBuilder.checkedAppendChild(rsgn, icpair[0]);
rsgn.appendChild(icpair[1]);
hBuilder.appendChildList(rsgn, atlst);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsgn;
},
// Ham4HMLGen.g:138:1: symmoperator returns [Element rsym = null] : ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ) ;
// $ANTLR start "symmoperator"
symmoperator: function() {
var rsym =  null;
var  plr = null;
var  lg  = null;
var  fb  = null;
var alt = false;
var ni  = false;
try {
// Ham4HMLGen.g:148:5: ( ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? ) )
// Ham4HMLGen.g:149:5: ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4HMLGen.g:149:5: ( ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )? )
// Ham4HMLGen.g:150:9: ( HamSymmpar | HamSymmlr ) ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )? ( HamAlternatingmotion )? ( HamNonipsi )?
// Ham4HMLGen.g:150:9: ( HamSymmpar | HamSymmlr )
var alt5=2;
var LA5_0 = this.input.LA(1);
if ( (LA5_0==HamSymmpar) ) {
alt5=1;
}
else if ( (LA5_0==HamSymmlr) ) {
alt5=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 5, 0, this.input);
throw nvae;
}
switch (alt5) {
case 1 :
// Ham4HMLGen.g:151:13: HamSymmpar
this.match(this.input,HamSymmpar,Ham4HMLGen.FOLLOW_HamSymmpar_in_symmoperator745); 
plr = "hamsymmpar"; 
break;
case 2 :
// Ham4HMLGen.g:153:13: HamSymmlr
this.match(this.input,HamSymmlr,Ham4HMLGen.FOLLOW_HamSymmlr_in_symmoperator780); 
plr = "hamsymmlr"; 
break;
}
// Ham4HMLGen.g:155:9: ( ( HamLargemod ) ( HamFingerstraightmod )? | ( HamFingerstraightmod ) ( HamLargemod )? )?
var alt8=3;
var LA8_0 = this.input.LA(1);
if ( (LA8_0==HamLargemod) ) {
alt8=1;
}
else if ( (LA8_0==HamFingerstraightmod) ) {
alt8=2;
}
switch (alt8) {
case 1 :
// Ham4HMLGen.g:156:13: ( HamLargemod ) ( HamFingerstraightmod )?
// Ham4HMLGen.g:156:13: ( HamLargemod )
// Ham4HMLGen.g:156:15: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_symmoperator828); 
lg = "hamlargemod"; 
// Ham4HMLGen.g:157:13: ( HamFingerstraightmod )?
var alt6=2;
var LA6_0 = this.input.LA(1);
if ( (LA6_0==HamFingerstraightmod) ) {
alt6=1;
}
switch (alt6) {
case 1 :
// Ham4HMLGen.g:157:15: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_symmoperator863); 
fb = "hamfingerbent"; 
break;
}
break;
case 2 :
// Ham4HMLGen.g:159:13: ( HamFingerstraightmod ) ( HamLargemod )?
// Ham4HMLGen.g:159:13: ( HamFingerstraightmod )
// Ham4HMLGen.g:159:15: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_symmoperator897); 
fb = "hamfingerbent"; 
// Ham4HMLGen.g:160:13: ( HamLargemod )?
var alt7=2;
var LA7_0 = this.input.LA(1);
if ( (LA7_0==HamLargemod) ) {
alt7=1;
}
switch (alt7) {
case 1 :
// Ham4HMLGen.g:160:15: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_symmoperator920); 
lg = "hamlargemod"; 
break;
}
break;
}
// Ham4HMLGen.g:162:9: ( HamAlternatingmotion )?
var alt9=2;
var LA9_0 = this.input.LA(1);
if ( (LA9_0==HamAlternatingmotion) ) {
alt9=1;
}
switch (alt9) {
case 1 :
// Ham4HMLGen.g:162:13: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_symmoperator965); 
alt= true; 
break;
}
// Ham4HMLGen.g:163:9: ( HamNonipsi )?
var alt10=2;
var LA10_0 = this.input.LA(1);
if ( (LA10_0==HamNonipsi) ) {
alt10=1;
}
switch (alt10) {
case 1 :
// Ham4HMLGen.g:163:13: HamNonipsi
this.match(this.input,HamNonipsi,Ham4HMLGen.FOLLOW_HamNonipsi_in_symmoperator987); 
ni = true; 
break;
}
rsym = hBuilder.newHMLElement("symmoperator");
hBuilder.checkedSetAttr(rsym, "att_par_or_lr", plr);
hBuilder.checkedSetAttr(rsym, "attrib_oi_symm", fb);
hBuilder.checkedSetAttr(rsym, "attrib_ud_symm", lg);
hBuilder.checkedSetFlagAttr(rsym, "outofphase", alt);
hBuilder.checkedSetFlagAttr(rsym, "nonipsi", ni);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsym;
},
// Ham4HMLGen.g:178:1: initialconfig2 returns [Element[] ricpair] : ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 ) ;
// $ANTLR start "initialconfig2"
initialconfig2: function() {
var ricpair = null;
var nmic = null;
var mic = null;
try {
// Ham4HMLGen.g:183:5: ( ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 ) )
// Ham4HMLGen.g:184:5: ^( ICFG2 (nmic= nminitialconfig )? mic= minitialconfig2 )
this.match(this.input,ICFG2,Ham4HMLGen.FOLLOW_ICFG2_in_initialconfig21048); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:185:9: (nmic= nminitialconfig )?
var alt11=2;
var LA11_0 = this.input.LA(1);
if ( (LA11_0==NMICLIST) ) {
alt11=1;
}
switch (alt11) {
case 1 :
// Ham4HMLGen.g:185:11: nmic= nminitialconfig
this.pushFollow(Ham4HMLGen.FOLLOW_nminitialconfig_in_initialconfig21065);
nmic=this.nminitialconfig();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_minitialconfig2_in_initialconfig21086);
mic=this.minitialconfig2();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ricpair = [nmic, mic];
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ricpair;
},
// Ham4HMLGen.g:193:1: initialconfig1 returns [Element[] ricpair] : ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 ) ;
// $ANTLR start "initialconfig1"
initialconfig1: function() {
var ricpair = null;
var nmic = null;
var mic = null;
try {
// Ham4HMLGen.g:198:5: ( ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 ) )
// Ham4HMLGen.g:199:5: ^( ICFG1 (nmic= nminitialconfig )? mic= minitialconfig1 )
this.match(this.input,ICFG1,Ham4HMLGen.FOLLOW_ICFG1_in_initialconfig11127); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:200:9: (nmic= nminitialconfig )?
var alt12=2;
var LA12_0 = this.input.LA(1);
if ( (LA12_0==NMICLIST) ) {
alt12=1;
}
switch (alt12) {
case 1 :
// Ham4HMLGen.g:200:11: nmic= nminitialconfig
this.pushFollow(Ham4HMLGen.FOLLOW_nminitialconfig_in_initialconfig11144);
nmic=this.nminitialconfig();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_minitialconfig1_in_initialconfig11165);
mic=this.minitialconfig1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ricpair = [nmic, mic];
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ricpair;
},
// Ham4HMLGen.g:208:1: nminitialconfig returns [Element rnmic = null] : ^( NMICLIST (nmpair= nmicunit )+ ) ;
// $ANTLR start "nminitialconfig"
nminitialconfig: function() {
var rnmic =  null;
var nmpair = null;
rnmic = hBuilder.newHMLElement("nminitialconfig");
try {
// Ham4HMLGen.g:214:5: ( ^( NMICLIST (nmpair= nmicunit )+ ) )
// Ham4HMLGen.g:215:5: ^( NMICLIST (nmpair= nmicunit )+ )
this.match(this.input,NMICLIST,Ham4HMLGen.FOLLOW_NMICLIST_in_nminitialconfig1213); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:216:9: (nmpair= nmicunit )+
var cnt13=0;
loop13:
do {
var alt13=2;
var LA13_0 = this.input.LA(1);
if ( (LA13_0==NMICUNIT) ) {
alt13=1;
}
switch (alt13) {
case 1 :
// Ham4HMLGen.g:217:13: nmpair= nmicunit
this.pushFollow(Ham4HMLGen.FOLLOW_nmicunit_in_nminitialconfig1242);
nmpair=this.nmicunit();
this.state._fsp--;
rnmic.appendChild(nmpair[0]);
rnmic.appendChild(nmpair[1]);
break;
default :
if ( cnt13 >= 1 ) {
break loop13;
}
var eee = new org.antlr.runtime.EarlyExitException(13, this.input);
throw eee;
}
cnt13++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnmic;
},
// Ham4HMLGen.g:226:1: nmicunit returns [Element[] rnmpair = [null,null]] : ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 ) ;
// $ANTLR start "nmicunit"
nmicunit: function() {
var rnmpair =  [null,null];
var nma = null;
var nmb = null;
try {
// Ham4HMLGen.g:232:5: ( ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 ) )
// Ham4HMLGen.g:233:5: ^( NMICUNIT (nma= levelbody | nma= levelarm ) nmb= action1 )
this.match(this.input,NMICUNIT,Ham4HMLGen.FOLLOW_NMICUNIT_in_nmicunit1308); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:234:9: (nma= levelbody | nma= levelarm )
var alt14=2;
var LA14_0 = this.input.LA(1);
if ( (LA14_0==LEVBODY) ) {
alt14=1;
}
else if ( (LA14_0==LEVARM) ) {
alt14=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 14, 0, this.input);
throw nvae;
}
switch (alt14) {
case 1 :
// Ham4HMLGen.g:235:13: nma= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_nmicunit1336);
nma=this.levelbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:237:13: nma= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_nmicunit1364);
nma=this.levelarm();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_nmicunit1388);
nmb=this.action1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rnmpair[0] = nma;
rnmpair[1] = nmb;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnmpair;
},
// Ham4HMLGen.g:247:1: minitialconfig2 returns [Element rmic = null] : ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) ) ;
// $ANTLR start "minitialconfig2"
minitialconfig2: function() {
var rmic =  null;
var hc2 = null;
var loc2 = null;
var hc1 = null;
var l1dom = null;
var l1sub = null;
try {
// Ham4HMLGen.g:250:5: ( ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) ) )
// Ham4HMLGen.g:251:5: ^( MICFG2 (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? ) )
this.match(this.input,MICFG2,Ham4HMLGen.FOLLOW_MICFG2_in_minitialconfig21428); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:252:9: (hc2= handconfig2 (loc2= location2 )? | hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )? )
var alt18=2;
var LA18_0 = this.input.LA(1);
if ( (LA18_0==HDCONFIG2) ) {
alt18=1;
}
else if ( (LA18_0==HDCONFIG1) ) {
alt18=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 18, 0, this.input);
throw nvae;
}
switch (alt18) {
case 1 :
// Ham4HMLGen.g:253:13: hc2= handconfig2 (loc2= location2 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig2_in_minitialconfig21460);
hc2=this.handconfig2();
this.state._fsp--;
// Ham4HMLGen.g:254:13: (loc2= location2 )?
var alt15=2;
var LA15_0 = this.input.LA(1);
if ( (LA15_0==LOC2) ) {
alt15=1;
}
switch (alt15) {
case 1 :
// Ham4HMLGen.g:254:15: loc2= location2
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_minitialconfig21481);
loc2=this.location2();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:256:13: hc1= handconfig1 (l1dom= location1 )? HamPlus (l1sub= location1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_minitialconfig21516);
hc1=this.handconfig1();
this.state._fsp--;
// Ham4HMLGen.g:257:13: (l1dom= location1 )?
var alt16=2;
var LA16_0 = this.input.LA(1);
if ( (LA16_0==LOC1) ) {
alt16=1;
}
switch (alt16) {
case 1 :
// Ham4HMLGen.g:257:15: l1dom= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig21536);
l1dom=this.location1();
this.state._fsp--;
break;
}
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_minitialconfig21563); 
// Ham4HMLGen.g:259:13: (l1sub= location1 )?
var alt17=2;
var LA17_0 = this.input.LA(1);
if ( (LA17_0==LOC1) ) {
alt17=1;
}
switch (alt17) {
case 1 :
// Ham4HMLGen.g:259:15: l1sub= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig21583);
l1sub=this.location1();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (hc2 == null) {
hc2 = hBuilder.newHMLElement("handconfig2");
hc2.appendChild(hc1);
loc2 = hBuilder.newHMLElement("location2");
hBuilder.checkedAppendChild(loc2, l1dom);  // ???? valid?
hBuilder.checkedAppendChild(loc2, l1sub);  // ???? valid?
}
rmic = hBuilder.newHMLElement("minitialconfig2");
rmic.appendChild(hc2);
hBuilder.checkedAppendChild(rmic, loc2);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmic;
},
// Ham4HMLGen.g:276:1: minitialconfig1 returns [Element rmic = null] : ^( MICFG1 hc1= handconfig1 (loc1= location1 )? ) ;
// $ANTLR start "minitialconfig1"
minitialconfig1: function() {
var rmic =  null;
var hc1 = null;
var loc1 = null;
try {
// Ham4HMLGen.g:279:5: ( ^( MICFG1 hc1= handconfig1 (loc1= location1 )? ) )
// Ham4HMLGen.g:280:5: ^( MICFG1 hc1= handconfig1 (loc1= location1 )? )
this.match(this.input,MICFG1,Ham4HMLGen.FOLLOW_MICFG1_in_minitialconfig11636); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_minitialconfig11654);
hc1=this.handconfig1();
this.state._fsp--;
// Ham4HMLGen.g:282:9: (loc1= location1 )?
var alt19=2;
var LA19_0 = this.input.LA(1);
if ( (LA19_0==LOC1) ) {
alt19=1;
}
switch (alt19) {
case 1 :
// Ham4HMLGen.g:282:11: loc1= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_minitialconfig11671);
loc1=this.location1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rmic = hBuilder.newHMLElement("minitialconfig1");
rmic.appendChild(hc1);
hBuilder.checkedAppendChild(rmic, loc1);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmic;
},
// Ham4HMLGen.g:294:1: handconfig2 returns [Element rhc = null] : ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) ) ;
// $ANTLR start "handconfig2"
handconfig2: function() {
var rhc =  null;
var hs2 = null;
var tailpair = null;
var shc = null;
try {
// Ham4HMLGen.g:297:5: ( ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) ) )
// Ham4HMLGen.g:298:5: ^( HDCONFIG2 (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 ) )
this.match(this.input,HDCONFIG2,Ham4HMLGen.FOLLOW_HDCONFIG2_in_handconfig21721); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:299:9: (hs2= handshape2 (tailpair= handconfigtail2 )? | shc= splithandconfig2 )
var alt21=2;
var LA21_0 = this.input.LA(1);
if ( (LA21_0==HSHAPE2) ) {
alt21=1;
}
else if ( (LA21_0==SPLITHDCFG2) ) {
alt21=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 21, 0, this.input);
throw nvae;
}
switch (alt21) {
case 1 :
// Ham4HMLGen.g:300:13: hs2= handshape2 (tailpair= handconfigtail2 )?
this.pushFollow(Ham4HMLGen.FOLLOW_handshape2_in_handconfig21757);
hs2=this.handshape2();
this.state._fsp--;
// Ham4HMLGen.g:301:13: (tailpair= handconfigtail2 )?
var alt20=2;
var LA20_0 = this.input.LA(1);
if ( (LA20_0==HDCFGTAIL2) ) {
alt20=1;
}
switch (alt20) {
case 1 :
// Ham4HMLGen.g:301:15: tailpair= handconfigtail2
this.pushFollow(Ham4HMLGen.FOLLOW_handconfigtail2_in_handconfig21778);
tailpair=this.handconfigtail2();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:303:13: shc= splithandconfig2
this.pushFollow(Ham4HMLGen.FOLLOW_splithandconfig2_in_handconfig21817);
shc=this.splithandconfig2();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = shc;
if (rhc == null) {
rhc = hBuilder.newHMLElement("handconfig2");
rhc.appendChild(hs2);
if (tailpair != null) {
rhc.appendChild(tailpair[0]);   // efd2
rhc.appendChild(tailpair[1]);   // po2
}
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:320:1: handconfig1 returns [Element rhc = null] : ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? ) ;
// $ANTLR start "handconfig1"
handconfig1: function() {
var rhc =  null;
var hs = null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:323:5: ( ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? ) )
// Ham4HMLGen.g:324:5: ^( HDCONFIG1 hs= handshape1 (efd= extfidir1 )? (po= palmor1 )? )
this.match(this.input,HDCONFIG1,Ham4HMLGen.FOLLOW_HDCONFIG1_in_handconfig11871); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handconfig11890);
hs=this.handshape1();
this.state._fsp--;
// Ham4HMLGen.g:326:9: (efd= extfidir1 )?
var alt22=2;
var LA22_0 = this.input.LA(1);
if ( (LA22_0==EXTFIDIR1) ) {
alt22=1;
}
switch (alt22) {
case 1 :
// Ham4HMLGen.g:326:11: efd= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfig11908);
efd=this.extfidir1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:327:9: (po= palmor1 )?
var alt23=2;
var LA23_0 = this.input.LA(1);
if ( (LA23_0==PALMOR1) ) {
alt23=1;
}
switch (alt23) {
case 1 :
// Ham4HMLGen.g:327:11: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfig11930);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconfig1");
rhc.appendChild(hs);
hBuilder.checkedAppendChild(rhc, efd);
hBuilder.checkedAppendChild(rhc, po);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:338:1: splithandconfig2 returns [Element rhc = null] : ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 ) ;
// $ANTLR start "splithandconfig2"
splithandconfig2: function() {
var rhc =  null;
var hcdom = null;
var hcnd = null;
try {
// Ham4HMLGen.g:341:5: ( ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 ) )
// Ham4HMLGen.g:342:5: ^( SPLITHDCFG2 hcdom= handconfig1 hcnd= handconfig1 )
this.match(this.input,SPLITHDCFG2,Ham4HMLGen.FOLLOW_SPLITHDCFG2_in_splithandconfig21985); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_splithandconfig22001);
hcdom=this.handconfig1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_handconfig1_in_splithandconfig22017);
hcnd=this.handconfig1();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconfig2");
rhc.appendChild(hcdom);
rhc.appendChild(hcnd);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:353:1: handconfigtail2 returns [Element[] rtlpair = [null,null]] : ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) ) ;
// $ANTLR start "handconfigtail2"
handconfigtail2: function() {
var rtlpair =  [null,null];
var tmp = null;
var efd1d = null;
var po1d = null;
var efd1s = null;
var po1s = null;
try {
// Ham4HMLGen.g:358:5: ( ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) ) )
// Ham4HMLGen.g:359:5: ^( HDCFGTAIL2 (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 ) )
this.match(this.input,HDCFGTAIL2,Ham4HMLGen.FOLLOW_HDCFGTAIL2_in_handconfigtail22061); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:360:9: (tmp= extfidir2 tmp= palmor2 | efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1 )
var alt24=2;
var LA24_0 = this.input.LA(1);
if ( (LA24_0==EXTFIDIR2) ) {
alt24=1;
}
else if ( (LA24_0==EXTFIDIR1) ) {
alt24=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 24, 0, this.input);
throw nvae;
}
switch (alt24) {
case 1 :
// Ham4HMLGen.g:361:13: tmp= extfidir2 tmp= palmor2
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir2_in_handconfigtail22095);
tmp=this.extfidir2();
this.state._fsp--;
rtlpair[0] = tmp; 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor2_in_handconfigtail22127);
tmp=this.palmor2();
this.state._fsp--;
rtlpair[1] = tmp; 
break;
case 2 :
// Ham4HMLGen.g:364:13: efd1d= extfidir1 po1d= palmor1 efd1s= extfidir1 po1s= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfigtail22169);
efd1d=this.extfidir1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfigtail22192);
po1d=this.palmor1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_handconfigtail22214);
efd1s=this.extfidir1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_handconfigtail22237);
po1s=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (efd1d != null) {
rtlpair[0]  =  hBuilder.newHMLElement("extfidir2");
rtlpair[0].appendChild(efd1d);
rtlpair[0].appendChild(efd1s);
rtlpair[1]  =  hBuilder.newHMLElement("palmor2");
rtlpair[1].appendChild(po1d);
rtlpair[1].appendChild(po1s);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rtlpair;
},
// Ham4HMLGen.g:387:1: handshape2 returns [Element rhs = null] : ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? ) ;
// $ANTLR start "handshape2"
handshape2: function() {
var rhs =  null;
var hsa = null;
var hsb = null;
try {
// Ham4HMLGen.g:390:5: ( ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? ) )
// Ham4HMLGen.g:391:5: ^( HSHAPE2 hsa= handshape1 (hsb= handshape1 )? )
this.match(this.input,HSHAPE2,Ham4HMLGen.FOLLOW_HSHAPE2_in_handshape22295); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handshape22313);
hsa=this.handshape1();
this.state._fsp--;
// Ham4HMLGen.g:393:9: (hsb= handshape1 )?
var alt25=2;
var LA25_0 = this.input.LA(1);
if ( (LA25_0==HSHAPE1) ) {
alt25=1;
}
switch (alt25) {
case 1 :
// Ham4HMLGen.g:393:11: hsb= handshape1
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_handshape22331);
hsb=this.handshape1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhs = hBuilder.newHMLElement("handshape2");
rhs.appendChild(hsa);
hBuilder.checkedAppendChild(rhs, hsb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhs;
},
// Ham4HMLGen.g:402:1: handshape1 returns [Element rhs = null] : ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? ) ;
// $ANTLR start "handshape1"
handshape1: function() {
var rhs =  null;
var attr24 = null;
var fnglst = null;
var fshlst = null;
var fcrlst = null;
var thspc = null;
try {
// Ham4HMLGen.g:405:5: ( ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? ) )
// Ham4HMLGen.g:406:5: ^( HSHAPE1 attr24= basichandshape1 (fnglst= fingerlist )? (fshlst= fingershapelist )? (fcrlst= fingercrossinglist )? (thspc= thumbspecial )? )
this.match(this.input,HSHAPE1,Ham4HMLGen.FOLLOW_HSHAPE1_in_handshape12379); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape1_in_handshape12398);
attr24=this.basichandshape1();
this.state._fsp--;
// Ham4HMLGen.g:408:9: (fnglst= fingerlist )?
var alt26=2;
var LA26_0 = this.input.LA(1);
if ( (LA26_0==FINGERLIST) ) {
alt26=1;
}
switch (alt26) {
case 1 :
// Ham4HMLGen.g:408:11: fnglst= fingerlist
this.pushFollow(Ham4HMLGen.FOLLOW_fingerlist_in_handshape12417);
fnglst=this.fingerlist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:409:9: (fshlst= fingershapelist )?
var alt27=2;
var LA27_0 = this.input.LA(1);
if ( (LA27_0==FISHPLIST) ) {
alt27=1;
}
switch (alt27) {
case 1 :
// Ham4HMLGen.g:409:11: fshlst= fingershapelist
this.pushFollow(Ham4HMLGen.FOLLOW_fingershapelist_in_handshape12439);
fshlst=this.fingershapelist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:410:9: (fcrlst= fingercrossinglist )?
var alt28=2;
var LA28_0 = this.input.LA(1);
if ( (LA28_0==FICRSSLIST) ) {
alt28=1;
}
switch (alt28) {
case 1 :
// Ham4HMLGen.g:410:11: fcrlst= fingercrossinglist
this.pushFollow(Ham4HMLGen.FOLLOW_fingercrossinglist_in_handshape12461);
fcrlst=this.fingercrossinglist();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:411:9: (thspc= thumbspecial )?
var alt29=2;
var LA29_0 = this.input.LA(1);
if ( (LA29_0==THSPECIAL) ) {
alt29=1;
}
switch (alt29) {
case 1 :
// Ham4HMLGen.g:411:11: thspc= thumbspecial
this.pushFollow(Ham4HMLGen.FOLLOW_thumbspecial_in_handshape12484);
thspc=this.thumbspecial();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhs = hBuilder.newHMLElement("handshape1");
hBuilder.checkedSetAttr(
rhs,    "handshapeclass",   attr24[0][0]);
hBuilder.checkedSetAttr(
rhs,    "thumbpos",         attr24[0][1]);
hBuilder.checkedSetAttr(rhs,
"fingerbending",    attr24[0][2]);
hBuilder.checkedStringSetFlagAttr(rhs,
"approx_shape",     attr24[0][3]);
if (attr24[1] != null) {
hBuilder.checkedSetAttr(
rhs,    "second_handshapeclass",    attr24[1][0]);
hBuilder.checkedSetAttr(
rhs,    "second_thumbpos",          attr24[1][1]);
hBuilder.checkedSetAttr(
rhs,    "second_fingerbending",     attr24[1][2]);
}
hBuilder.checkedAppendChildList(rhs, fnglst);
hBuilder.checkedAppendChildList(rhs, fshlst);
hBuilder.checkedAppendChildList(rhs, fcrlst);
hBuilder.checkedAppendChild(rhs, thspc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhs;
},
// Ham4HMLGen.g:438:1: basichandshape1 returns [String[][] rbh = []] : ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? ) ;
// $ANTLR start "basichandshape1"
basichandshape1: function() {
var rbh =  [];
var bha = null;
var bhb = null;
try {
// Ham4HMLGen.g:442:5: ( ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? ) )
// Ham4HMLGen.g:443:5: ^( BASICHDSHP1 bha= basichandshape (bhb= basichandshape )? )
this.match(this.input,BASICHDSHP1,Ham4HMLGen.FOLLOW_BASICHDSHP1_in_basichandshape12527); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape_in_basichandshape12545);
bha=this.basichandshape();
this.state._fsp--;
rbh[0] = bha; 
// Ham4HMLGen.g:445:9: (bhb= basichandshape )?
var alt30=2;
var LA30_0 = this.input.LA(1);
if ( (LA30_0==BASICHDSHP) ) {
alt30=1;
}
switch (alt30) {
case 1 :
// Ham4HMLGen.g:445:11: bhb= basichandshape
this.pushFollow(Ham4HMLGen.FOLLOW_basichandshape_in_basichandshape12568);
bhb=this.basichandshape();
this.state._fsp--;
rbh[1] = bhb; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rbh;
},
// Ham4HMLGen.g:451:1: basichandshape returns [String[] rbhquad = [null,null,null,null]] : ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) ) ;
// $ANTLR start "basichandshape"
basichandshape: function() {
var rbhquad =  [null,null,null,null];
var tmp = null;
try {
// Ham4HMLGen.g:460:5: ( ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) ) )
// Ham4HMLGen.g:461:5: ^( BASICHDSHP (tmp= handshapeclass | HamNondominant ) ( HamEtc )? ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? ) )
this.match(this.input,BASICHDSHP,Ham4HMLGen.FOLLOW_BASICHDSHP_in_basichandshape2617); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:462:9: (tmp= handshapeclass | HamNondominant )
var alt31=2;
var LA31_0 = this.input.LA(1);
if ( (LA31_0==HSCLASS) ) {
alt31=1;
}
else if ( (LA31_0==HamNondominant) ) {
alt31=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 31, 0, this.input);
throw nvae;
}
switch (alt31) {
case 1 :
// Ham4HMLGen.g:462:11: tmp= handshapeclass
this.pushFollow(Ham4HMLGen.FOLLOW_handshapeclass_in_basichandshape2639);
tmp=this.handshapeclass();
this.state._fsp--;
rbhquad[0] = tmp; 
break;
case 2 :
// Ham4HMLGen.g:463:23: HamNondominant
this.match(this.input,HamNondominant,Ham4HMLGen.FOLLOW_HamNondominant_in_basichandshape2668); 
rbhquad[0] = "ham_nondominant"; 
break;
}
// Ham4HMLGen.g:465:9: ( HamEtc )?
var alt32=2;
var LA32_0 = this.input.LA(1);
if ( (LA32_0==HamEtc) ) {
alt32=1;
}
switch (alt32) {
case 1 :
// Ham4HMLGen.g:465:11: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_basichandshape2695); 
rbhquad[3] = "true";  
break;
}
// Ham4HMLGen.g:466:9: ( | tmp= thumbpos (tmp= fingerbending )? | tmp= fingerbending (tmp= thumbpos )? )
var alt35=3;
switch ( this.input.LA(1) ) {
case UP:
alt35=1;
break;
case THUMBPOS:
alt35=2;
break;
case FIBENDING:
alt35=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 35, 0, this.input);
throw nvae;
}
switch (alt35) {
case 1 :
// Ham4HMLGen.g:468:9: 
break;
case 2 :
// Ham4HMLGen.g:469:13: tmp= thumbpos (tmp= fingerbending )?
this.pushFollow(Ham4HMLGen.FOLLOW_thumbpos_in_basichandshape2778);
tmp=this.thumbpos();
this.state._fsp--;
rbhquad[1] = tmp; 
// Ham4HMLGen.g:470:13: (tmp= fingerbending )?
var alt33=2;
var LA33_0 = this.input.LA(1);
if ( (LA33_0==FIBENDING) ) {
alt33=1;
}
switch (alt33) {
case 1 :
// Ham4HMLGen.g:470:15: tmp= fingerbending
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_basichandshape2811);
tmp=this.fingerbending();
this.state._fsp--;
rbhquad[2] = tmp; 
break;
}
break;
case 3 :
// Ham4HMLGen.g:472:13: tmp= fingerbending (tmp= thumbpos )?
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_basichandshape2852);
tmp=this.fingerbending();
this.state._fsp--;
rbhquad[2] = tmp; 
// Ham4HMLGen.g:473:13: (tmp= thumbpos )?
var alt34=2;
var LA34_0 = this.input.LA(1);
if ( (LA34_0==THUMBPOS) ) {
alt34=1;
}
switch (alt34) {
case 1 :
// Ham4HMLGen.g:473:15: tmp= thumbpos
this.pushFollow(Ham4HMLGen.FOLLOW_thumbpos_in_basichandshape2880);
tmp=this.thumbpos();
this.state._fsp--;
rbhquad[1] = tmp; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rbhquad;
},
// Ham4HMLGen.g:478:1: handshapeclass returns [String rhsc = null] : ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ) ;
// $ANTLR start "handshapeclass"
handshapeclass: function() {
var rhsc =  null;
try {
// Ham4HMLGen.g:480:5: ( ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) ) )
// Ham4HMLGen.g:481:5: ^( HSCLASS ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open ) )
this.match(this.input,HSCLASS,Ham4HMLGen.FOLLOW_HSCLASS_in_handshapeclass2939); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:482:9: ( HamFist | HamFlathand | HamFinger2 | HamFinger23 | HamFinger23spread | HamFinger2345 | HamPinch12 | HamPinchall | HamPinch12open | HamCee12 | HamCeeall | HamCee12open )
var alt36=12;
switch ( this.input.LA(1) ) {
case HamFist:
alt36=1;
break;
case HamFlathand:
alt36=2;
break;
case HamFinger2:
alt36=3;
break;
case HamFinger23:
alt36=4;
break;
case HamFinger23spread:
alt36=5;
break;
case HamFinger2345:
alt36=6;
break;
case HamPinch12:
alt36=7;
break;
case HamPinchall:
alt36=8;
break;
case HamPinch12open:
alt36=9;
break;
case HamCee12:
alt36=10;
break;
case HamCeeall:
alt36=11;
break;
case HamCee12open:
alt36=12;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 36, 0, this.input);
throw nvae;
}
switch (alt36) {
case 1 :
// Ham4HMLGen.g:482:13: HamFist
this.match(this.input,HamFist,Ham4HMLGen.FOLLOW_HamFist_in_handshapeclass2953); 
rhsc = "ham_fist"; 
break;
case 2 :
// Ham4HMLGen.g:483:13: HamFlathand
this.match(this.input,HamFlathand,Ham4HMLGen.FOLLOW_HamFlathand_in_handshapeclass2981); 
rhsc = "ham_flathand"; 
break;
case 3 :
// Ham4HMLGen.g:484:13: HamFinger2
this.match(this.input,HamFinger2,Ham4HMLGen.FOLLOW_HamFinger2_in_handshapeclass3005); 
rhsc = "ham_finger2"; 
break;
case 4 :
// Ham4HMLGen.g:485:13: HamFinger23
this.match(this.input,HamFinger23,Ham4HMLGen.FOLLOW_HamFinger23_in_handshapeclass3030); 
rhsc = "ham_finger23"; 
break;
case 5 :
// Ham4HMLGen.g:486:13: HamFinger23spread
this.match(this.input,HamFinger23spread,Ham4HMLGen.FOLLOW_HamFinger23spread_in_handshapeclass3054); 
rhsc = "ham_finger23spread"; 
break;
case 6 :
// Ham4HMLGen.g:487:13: HamFinger2345
this.match(this.input,HamFinger2345,Ham4HMLGen.FOLLOW_HamFinger2345_in_handshapeclass3072); 
rhsc = "ham_finger2345"; 
break;
case 7 :
// Ham4HMLGen.g:488:13: HamPinch12
this.match(this.input,HamPinch12,Ham4HMLGen.FOLLOW_HamPinch12_in_handshapeclass3094); 
rhsc = "ham_pinch12"; 
break;
case 8 :
// Ham4HMLGen.g:489:13: HamPinchall
this.match(this.input,HamPinchall,Ham4HMLGen.FOLLOW_HamPinchall_in_handshapeclass3119); 
rhsc = "ham_pinchall"; 
break;
case 9 :
// Ham4HMLGen.g:490:13: HamPinch12open
this.match(this.input,HamPinch12open,Ham4HMLGen.FOLLOW_HamPinch12open_in_handshapeclass3143); 
rhsc = "ham_pinch12open"; 
break;
case 10 :
// Ham4HMLGen.g:491:13: HamCee12
this.match(this.input,HamCee12,Ham4HMLGen.FOLLOW_HamCee12_in_handshapeclass3164); 
rhsc = "ham_cee12"; 
break;
case 11 :
// Ham4HMLGen.g:492:13: HamCeeall
this.match(this.input,HamCeeall,Ham4HMLGen.FOLLOW_HamCeeall_in_handshapeclass3191); 
rhsc = "ham_ceeall"; 
break;
case 12 :
// Ham4HMLGen.g:493:13: HamCee12open
this.match(this.input,HamCee12open,Ham4HMLGen.FOLLOW_HamCee12open_in_handshapeclass3217); 
rhsc = "ham_cee12open"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhsc;
},
// Ham4HMLGen.g:498:1: fingerbending returns [String rfb = null] : ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ) ;
// $ANTLR start "fingerbending"
fingerbending: function() {
var rfb =  null;
try {
// Ham4HMLGen.g:500:5: ( ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) ) )
// Ham4HMLGen.g:501:5: ^( FIBENDING ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked ) )
this.match(this.input,FIBENDING,Ham4HMLGen.FOLLOW_FIBENDING_in_fingerbending3272); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:502:9: ( HamFingerstraightmod | HamFingerbendmod | HamFingerhookedmod | HamDoublebent | HamDoublehooked )
var alt37=5;
switch ( this.input.LA(1) ) {
case HamFingerstraightmod:
alt37=1;
break;
case HamFingerbendmod:
alt37=2;
break;
case HamFingerhookedmod:
alt37=3;
break;
case HamDoublebent:
alt37=4;
break;
case HamDoublehooked:
alt37=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 37, 0, this.input);
throw nvae;
}
switch (alt37) {
case 1 :
// Ham4HMLGen.g:502:13: HamFingerstraightmod
this.match(this.input,HamFingerstraightmod,Ham4HMLGen.FOLLOW_HamFingerstraightmod_in_fingerbending3286); 
rfb = "ham_finger_straight"; 
break;
case 2 :
// Ham4HMLGen.g:503:13: HamFingerbendmod
this.match(this.input,HamFingerbendmod,Ham4HMLGen.FOLLOW_HamFingerbendmod_in_fingerbending3305); 
rfb = "ham_finger_bend"; 
break;
case 3 :
// Ham4HMLGen.g:504:13: HamFingerhookedmod
this.match(this.input,HamFingerhookedmod,Ham4HMLGen.FOLLOW_HamFingerhookedmod_in_fingerbending3328); 
rfb = "ham_finger_hooked"; 
break;
case 4 :
// Ham4HMLGen.g:505:13: HamDoublebent
this.match(this.input,HamDoublebent,Ham4HMLGen.FOLLOW_HamDoublebent_in_fingerbending3349); 
rfb = "ham_finger_dblbent"; 
break;
case 5 :
// Ham4HMLGen.g:506:13: HamDoublehooked
this.match(this.input,HamDoublehooked,Ham4HMLGen.FOLLOW_HamDoublehooked_in_fingerbending3375); 
rfb = "ham_finger_dblhooked"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfb;
},
// Ham4HMLGen.g:511:1: thumbpos returns [String rtp = null] : ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ) ;
// $ANTLR start "thumbpos"
thumbpos: function() {
var rtp =  null;
try {
// Ham4HMLGen.g:513:5: ( ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) ) )
// Ham4HMLGen.g:514:5: ^( THUMBPOS ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod ) )
this.match(this.input,THUMBPOS,Ham4HMLGen.FOLLOW_THUMBPOS_in_thumbpos3436); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:515:9: ( HamThumboutmod | HamThumbacrossmod | HamThumbopenmod )
var alt38=3;
switch ( this.input.LA(1) ) {
case HamThumboutmod:
alt38=1;
break;
case HamThumbacrossmod:
alt38=2;
break;
case HamThumbopenmod:
alt38=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 38, 0, this.input);
throw nvae;
}
switch (alt38) {
case 1 :
// Ham4HMLGen.g:515:13: HamThumboutmod
this.match(this.input,HamThumboutmod,Ham4HMLGen.FOLLOW_HamThumboutmod_in_thumbpos3450); 
rtp = "ham_thumb_out"; 
break;
case 2 :
// Ham4HMLGen.g:516:13: HamThumbacrossmod
this.match(this.input,HamThumbacrossmod,Ham4HMLGen.FOLLOW_HamThumbacrossmod_in_thumbpos3471); 
rtp = "ham_thumb_across"; 
break;
case 3 :
// Ham4HMLGen.g:517:13: HamThumbopenmod
this.match(this.input,HamThumbopenmod,Ham4HMLGen.FOLLOW_HamThumbopenmod_in_thumbpos3489); 
rtp = "ham_thumb_open"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rtp;
},
// Ham4HMLGen.g:522:1: thumb returns [Element rth = null] : HamThumb ;
// $ANTLR start "thumb"
thumb: function() {
var rth =  null;
try {
// Ham4HMLGen.g:525:5: ( HamThumb )
// Ham4HMLGen.g:525:9: HamThumb
this.match(this.input,HamThumb,Ham4HMLGen.FOLLOW_HamThumb_in_thumb3546); 
rth = hBuilder.newHMLElement("thumb");
rth.setAttribute("fingerid", "ham_digit_1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rth;
},
// Ham4HMLGen.g:532:1: finger returns [Element rfngr = null] : ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky ) ;
// $ANTLR start "finger"
finger: function() {
var rfngr =  null;
var fi = null;
try {
// Ham4HMLGen.g:538:5: ( ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky ) )
// Ham4HMLGen.g:539:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
// Ham4HMLGen.g:539:5: ( HamIndexfinger | HamMiddlefinger | HamRingfinger | HamPinky )
var alt39=4;
switch ( this.input.LA(1) ) {
case HamIndexfinger:
alt39=1;
break;
case HamMiddlefinger:
alt39=2;
break;
case HamRingfinger:
alt39=3;
break;
case HamPinky:
alt39=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 39, 0, this.input);
throw nvae;
}
switch (alt39) {
case 1 :
// Ham4HMLGen.g:539:9: HamIndexfinger
this.match(this.input,HamIndexfinger,Ham4HMLGen.FOLLOW_HamIndexfinger_in_finger3596); 
fi = "2"; 
break;
case 2 :
// Ham4HMLGen.g:540:9: HamMiddlefinger
this.match(this.input,HamMiddlefinger,Ham4HMLGen.FOLLOW_HamMiddlefinger_in_finger3617); 
fi = "3"; 
break;
case 3 :
// Ham4HMLGen.g:541:9: HamRingfinger
this.match(this.input,HamRingfinger,Ham4HMLGen.FOLLOW_HamRingfinger_in_finger3637); 
fi = "4"; 
break;
case 4 :
// Ham4HMLGen.g:542:9: HamPinky
this.match(this.input,HamPinky,Ham4HMLGen.FOLLOW_HamPinky_in_finger3659); 
fi = "5"; 
break;
}
rfngr = hBuilder.newHMLElement("fingernothumb");
rfngr.setAttribute("fingerid", "ham_digit_" + fi);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngr;
},
// Ham4HMLGen.g:550:1: hsfingeritem returns [Element rfngr = null] : ^( HSFINGERITEM fngr= finger ( HamLargemod )? ) ;
// $ANTLR start "hsfingeritem"
hsfingeritem: function() {
var rfngr =  null;
var fngr = null;
var opthumb = false;
try {
// Ham4HMLGen.g:556:5: ( ^( HSFINGERITEM fngr= finger ( HamLargemod )? ) )
// Ham4HMLGen.g:557:5: ^( HSFINGERITEM fngr= finger ( HamLargemod )? )
this.match(this.input,HSFINGERITEM,Ham4HMLGen.FOLLOW_HSFINGERITEM_in_hsfingeritem3723); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_hsfingeritem3737);
fngr=this.finger();
this.state._fsp--;
rfngr = fngr; 
// Ham4HMLGen.g:559:9: ( HamLargemod )?
var alt40=2;
var LA40_0 = this.input.LA(1);
if ( (LA40_0==HamLargemod) ) {
alt40=1;
}
switch (alt40) {
case 1 :
// Ham4HMLGen.g:559:11: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_hsfingeritem3757); 
opthumb = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
hBuilder.checkedSetFlagAttr(rfngr, "thumbopp", opthumb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngr;
},
// Ham4HMLGen.g:566:1: digit returns [Element rd = null] : (fi= thumb | fi= finger ) ;
// $ANTLR start "digit"
digit: function() {
var rd =  null;
var fi = null;
try {
// Ham4HMLGen.g:569:5: ( (fi= thumb | fi= finger ) )
// Ham4HMLGen.g:570:5: (fi= thumb | fi= finger )
// Ham4HMLGen.g:570:5: (fi= thumb | fi= finger )
var alt41=2;
var LA41_0 = this.input.LA(1);
if ( (LA41_0==HamThumb) ) {
alt41=1;
}
else if ( ((LA41_0>=HamIndexfinger && LA41_0<=HamPinky)) ) {
alt41=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 41, 0, this.input);
throw nvae;
}
switch (alt41) {
case 1 :
// Ham4HMLGen.g:570:9: fi= thumb
this.pushFollow(Ham4HMLGen.FOLLOW_thumb_in_digit3825);
fi=this.thumb();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:571:9: fi= finger
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_digit3839);
fi=this.finger();
this.state._fsp--;
break;
}
rd = hBuilder.newHMLElement("finger");
rd.setAttribute("fingerid", fi.getAttribute("fingerid"));
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rd;
},
// Ham4HMLGen.g:579:1: fingerlist returns [Element[] rfngl = null] : ^( FINGERLIST (fng= hsfingeritem )* ) ;
// $ANTLR start "fingerlist"
fingerlist: function() {
var rfngl =  null;
var fng = null;
var      al  = [];
try {
// Ham4HMLGen.g:585:5: ( ^( FINGERLIST (fng= hsfingeritem )* ) )
// Ham4HMLGen.g:586:5: ^( FINGERLIST (fng= hsfingeritem )* )
this.match(this.input,FINGERLIST,Ham4HMLGen.FOLLOW_FINGERLIST_in_fingerlist3888); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:587:9: (fng= hsfingeritem )*
loop42:
do {
var alt42=2;
var LA42_0 = this.input.LA(1);
if ( (LA42_0==HSFINGERITEM) ) {
alt42=1;
}
switch (alt42) {
case 1 :
// Ham4HMLGen.g:587:11: fng= hsfingeritem
this.pushFollow(Ham4HMLGen.FOLLOW_hsfingeritem_in_fingerlist3904);
fng=this.hsfingeritem();
this.state._fsp--;
al.push(fng); 
break;
default :
break loop42;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfngl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfngl;
},
// Ham4HMLGen.g:594:1: fingershapelist returns [Element[] rfsl = null] : ^( FISHPLIST (fs= fingershape )* ) ;
// $ANTLR start "fingershapelist"
fingershapelist: function() {
var rfsl =  null;
var fs = null;
var    al  = [];
try {
// Ham4HMLGen.g:600:5: ( ^( FISHPLIST (fs= fingershape )* ) )
// Ham4HMLGen.g:601:5: ^( FISHPLIST (fs= fingershape )* )
this.match(this.input,FISHPLIST,Ham4HMLGen.FOLLOW_FISHPLIST_in_fingershapelist3968); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:602:9: (fs= fingershape )*
loop43:
do {
var alt43=2;
var LA43_0 = this.input.LA(1);
if ( (LA43_0==FSHAPE) ) {
alt43=1;
}
switch (alt43) {
case 1 :
// Ham4HMLGen.g:602:11: fs= fingershape
this.pushFollow(Ham4HMLGen.FOLLOW_fingershape_in_fingershapelist3984);
fs=this.fingershape();
this.state._fsp--;
al.push(fs); 
break;
default :
break loop43;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfsl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfsl;
},
// Ham4HMLGen.g:609:1: fingercrossinglist returns [Element[] rfcl = null] : ^( FICRSSLIST (fc= fingercrossing )* ) ;
// $ANTLR start "fingercrossinglist"
fingercrossinglist: function() {
var rfcl =  null;
var fc = null;
var    al  = [];
try {
// Ham4HMLGen.g:615:5: ( ^( FICRSSLIST (fc= fingercrossing )* ) )
// Ham4HMLGen.g:616:5: ^( FICRSSLIST (fc= fingercrossing )* )
this.match(this.input,FICRSSLIST,Ham4HMLGen.FOLLOW_FICRSSLIST_in_fingercrossinglist4047); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:617:9: (fc= fingercrossing )*
loop44:
do {
var alt44=2;
var LA44_0 = this.input.LA(1);
if ( (LA44_0==FCROSSING) ) {
alt44=1;
}
switch (alt44) {
case 1 :
// Ham4HMLGen.g:617:11: fc= fingercrossing
this.pushFollow(Ham4HMLGen.FOLLOW_fingercrossing_in_fingercrossinglist4063);
fc=this.fingercrossing();
this.state._fsp--;
al.push(fc); 
break;
default :
break loop44;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rfcl = al;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfcl;
},
// Ham4HMLGen.g:624:1: fingershape returns [Element rfs = null] : ^( FSHAPE d= digit fb= fingerbending ) ;
// $ANTLR start "fingershape"
fingershape: function() {
var rfs =  null;
var d = null;
var fb = null;
try {
// Ham4HMLGen.g:627:5: ( ^( FSHAPE d= digit fb= fingerbending ) )
// Ham4HMLGen.g:628:5: ^( FSHAPE d= digit fb= fingerbending )
this.match(this.input,FSHAPE,Ham4HMLGen.FOLLOW_FSHAPE_in_fingershape4118); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingershape4133);
d=this.digit();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_fingerbending_in_fingershape4147);
fb=this.fingerbending();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rfs = hBuilder.newHMLElement("fingershape");
rfs.appendChild(d);
rfs.setAttribute("fingerbending", fb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfs;
},
// Ham4HMLGen.g:639:1: fingercrossing returns [Element rfc = null] : ^( FCROSSING d0= digit fip= fingerpart d1= digit ) ;
// $ANTLR start "fingercrossing"
fingercrossing: function() {
var rfc =  null;
var d0 = null;
var fip = null;
var d1 = null;
try {
// Ham4HMLGen.g:642:5: ( ^( FCROSSING d0= digit fip= fingerpart d1= digit ) )
// Ham4HMLGen.g:643:5: ^( FCROSSING d0= digit fip= fingerpart d1= digit )
this.match(this.input,FCROSSING,Ham4HMLGen.FOLLOW_FCROSSING_in_fingercrossing4188); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingercrossing4202);
d0=this.digit();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_fingercrossing4216);
fip=this.fingerpart();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_fingercrossing4230);
d1=this.digit();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rfc = hBuilder.newHMLElement("fingercrossing");
rfc.appendChild(d0);
rfc.appendChild(fip);
rfc.appendChild(d1);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfc;
},
// Ham4HMLGen.g:656:1: thumbspecial returns [Element rts = null] : ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) ) ;
// $ANTLR start "thumbspecial"
thumbspecial: function() {
var rts =  null;
var fng0 = null;
var fng1 = null;
var th = null;
var fp = null;
rts = hBuilder.newHMLElement("thumbspecial");
try {
// Ham4HMLGen.g:662:5: ( ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) ) )
// Ham4HMLGen.g:663:5: ^( THSPECIAL ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart ) )
this.match(this.input,THSPECIAL,Ham4HMLGen.FOLLOW_THSPECIAL_in_thumbspecial4276); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:664:9: ( ^( HamBetween (fng0= finger fng1= finger )? ) | th= thumb | fp= fingerpart )
var alt46=3;
switch ( this.input.LA(1) ) {
case HamBetween:
alt46=1;
break;
case HamThumb:
alt46=2;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt46=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 46, 0, this.input);
throw nvae;
}
switch (alt46) {
case 1 :
// Ham4HMLGen.g:664:13: ^( HamBetween (fng0= finger fng1= finger )? )
this.match(this.input,HamBetween,Ham4HMLGen.FOLLOW_HamBetween_in_thumbspecial4291); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:665:17: (fng0= finger fng1= finger )?
var alt45=2;
var LA45_0 = this.input.LA(1);
if ( ((LA45_0>=HamIndexfinger && LA45_0<=HamPinky)) ) {
alt45=1;
}
switch (alt45) {
case 1 :
// Ham4HMLGen.g:665:21: fng0= finger fng1= finger
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_thumbspecial4317);
fng0=this.finger();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_finger_in_thumbspecial4343);
fng1=this.finger();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
if (fng0 == null) {
var btwn = hBuilder.newHMLElement("hambetween");
rts.appendChild(btwn);
}
else {
rts.appendChild(fng0);
rts.appendChild(fng1);
}
break;
case 2 :
// Ham4HMLGen.g:679:13: th= thumb
this.pushFollow(Ham4HMLGen.FOLLOW_thumb_in_thumbspecial4408);
th=this.thumb();
this.state._fsp--;
rts.appendChild(th); 
break;
case 3 :
// Ham4HMLGen.g:680:13: fp= fingerpart
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_thumbspecial4441);
fp=this.fingerpart();
this.state._fsp--;
rts.appendChild(fp); 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rts;
},
// Ham4HMLGen.g:685:1: fingerpart returns [Element rfp = null] : ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside ) ;
// $ANTLR start "fingerpart"
fingerpart: function() {
var rfp =  null;
var  fp = null;
try {
// Ham4HMLGen.g:691:5: ( ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside ) )
// Ham4HMLGen.g:692:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
// Ham4HMLGen.g:692:5: ( HamFingertip | HamFingernail | HamFingerpad | HamFingermidjoint | HamFingerbase | HamFingerside )
var alt47=6;
switch ( this.input.LA(1) ) {
case HamFingertip:
alt47=1;
break;
case HamFingernail:
alt47=2;
break;
case HamFingerpad:
alt47=3;
break;
case HamFingermidjoint:
alt47=4;
break;
case HamFingerbase:
alt47=5;
break;
case HamFingerside:
alt47=6;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 47, 0, this.input);
throw nvae;
}
switch (alt47) {
case 1 :
// Ham4HMLGen.g:692:9: HamFingertip
this.match(this.input,HamFingertip,Ham4HMLGen.FOLLOW_HamFingertip_in_fingerpart4507); 
fp = "ham_finger_tip"; 
break;
case 2 :
// Ham4HMLGen.g:693:9: HamFingernail
this.match(this.input,HamFingernail,Ham4HMLGen.FOLLOW_HamFingernail_in_fingerpart4530); 
fp = "ham_finger_nail"; 
break;
case 3 :
// Ham4HMLGen.g:694:9: HamFingerpad
this.match(this.input,HamFingerpad,Ham4HMLGen.FOLLOW_HamFingerpad_in_fingerpart4552); 
fp = "ham_finger_pad"; 
break;
case 4 :
// Ham4HMLGen.g:695:9: HamFingermidjoint
this.match(this.input,HamFingermidjoint,Ham4HMLGen.FOLLOW_HamFingermidjoint_in_fingerpart4575); 
fp = "ham_finger_midjoint"; 
break;
case 5 :
// Ham4HMLGen.g:696:9: HamFingerbase
this.match(this.input,HamFingerbase,Ham4HMLGen.FOLLOW_HamFingerbase_in_fingerpart4593); 
fp = "ham_finger_base"; 
break;
case 6 :
// Ham4HMLGen.g:697:9: HamFingerside
this.match(this.input,HamFingerside,Ham4HMLGen.FOLLOW_HamFingerside_in_fingerpart4615); 
fp = "ham_finger_side"; 
break;
}
rfp = hBuilder.newHMLElement("fingerpart");
rfp.setAttribute("fingerpart", fp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfp;
},
// Ham4HMLGen.g:708:1: extfidir2 returns [Element refd = null] : ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? ) ;
// $ANTLR start "extfidir2"
extfidir2: function() {
var refd =  null;
var da = null;
var db = null;
try {
// Ham4HMLGen.g:711:5: ( ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? ) )
// Ham4HMLGen.g:712:5: ^( EXTFIDIR2 da= extfidir1 (db= extfidir1 )? )
this.match(this.input,EXTFIDIR2,Ham4HMLGen.FOLLOW_EXTFIDIR2_in_extfidir24676); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_extfidir24695);
da=this.extfidir1();
this.state._fsp--;
// Ham4HMLGen.g:714:9: (db= extfidir1 )?
var alt48=2;
var LA48_0 = this.input.LA(1);
if ( (LA48_0==EXTFIDIR1) ) {
alt48=1;
}
switch (alt48) {
case 1 :
// Ham4HMLGen.g:714:11: db= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_extfidir24714);
db=this.extfidir1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd = hBuilder.newHMLElement("extfidir2");
refd.appendChild(da);
hBuilder.checkedAppendChild(refd, db);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd;
},
// Ham4HMLGen.g:723:1: extfidir1 returns [Element refd1 = null] : ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? ) ;
// $ANTLR start "extfidir1"
extfidir1: function() {
var refd1 =  null;
var efda = null;
var efdb = null;
var orirel = false;
try {
// Ham4HMLGen.g:729:5: ( ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? ) )
// Ham4HMLGen.g:730:5: ^( EXTFIDIR1 efda= extfidir (efdb= extfidir )? ( HamOrirelative )? )
this.match(this.input,EXTFIDIR1,Ham4HMLGen.FOLLOW_EXTFIDIR1_in_extfidir14767); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir_in_extfidir14784);
efda=this.extfidir();
this.state._fsp--;
// Ham4HMLGen.g:732:9: (efdb= extfidir )?
var alt49=2;
var LA49_0 = this.input.LA(1);
if ( (LA49_0==EXTFIDIR) ) {
alt49=1;
}
switch (alt49) {
case 1 :
// Ham4HMLGen.g:732:11: efdb= extfidir
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir_in_extfidir14801);
efdb=this.extfidir();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:733:9: ( HamOrirelative )?
var alt50=2;
var LA50_0 = this.input.LA(1);
if ( (LA50_0==HamOrirelative) ) {
alt50=1;
}
switch (alt50) {
case 1 :
// Ham4HMLGen.g:733:19: HamOrirelative
this.match(this.input,HamOrirelative,Ham4HMLGen.FOLLOW_HamOrirelative_in_extfidir14824); 
orirel = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd1 = hBuilder.newHMLElement("extfidir1");
refd1.setAttribute("extfidir", efda);
hBuilder.checkedSetAttr(refd1, "second_extfidir", efdb);
hBuilder.checkedSetFlagAttr(refd1, "rel_extfidir", orirel);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd1;
},
// Ham4HMLGen.g:743:1: extfidir returns [String refd = null] : ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) ) ;
// $ANTLR start "extfidir"
extfidir: function() {
var refd =  null;
var dir = null;
try {
// Ham4HMLGen.g:750:5: ( ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) ) )
// Ham4HMLGen.g:751:5: ^( EXTFIDIR ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) ) )
this.match(this.input,EXTFIDIR,Ham4HMLGen.FOLLOW_EXTFIDIR_in_extfidir4887); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:752:9: ( HamExtfingeru | HamExtfingerur | HamExtfingerr | HamExtfingerdr | HamExtfingerd | HamExtfingerdl | HamExtfingerl | HamExtfingerul | ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? ) | HamExtfingero | ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? ) | ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? ) | HamExtfingeri | ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? ) | ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? ) | ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? ) | ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? ) )
var alt59=18;
switch ( this.input.LA(1) ) {
case HamExtfingeru:
alt59=1;
break;
case HamExtfingerur:
alt59=2;
break;
case HamExtfingerr:
alt59=3;
break;
case HamExtfingerdr:
alt59=4;
break;
case HamExtfingerd:
alt59=5;
break;
case HamExtfingerdl:
alt59=6;
break;
case HamExtfingerl:
alt59=7;
break;
case HamExtfingerul:
alt59=8;
break;
case HamExtfingerol:
alt59=9;
break;
case HamExtfingero:
alt59=10;
break;
case HamExtfingeror:
alt59=11;
break;
case HamExtfingeril:
alt59=12;
break;
case HamExtfingeri:
alt59=13;
break;
case HamExtfingerir:
alt59=14;
break;
case HamExtfingeruo:
alt59=15;
break;
case HamExtfingerdo:
alt59=16;
break;
case HamExtfingerui:
alt59=17;
break;
case HamExtfingerdi:
alt59=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 59, 0, this.input);
throw nvae;
}
switch (alt59) {
case 1 :
// Ham4HMLGen.g:754:13: HamExtfingeru
this.match(this.input,HamExtfingeru,Ham4HMLGen.FOLLOW_HamExtfingeru_in_extfidir4921); 
dir = "u"; 
break;
case 2 :
// Ham4HMLGen.g:755:13: HamExtfingerur
this.match(this.input,HamExtfingerur,Ham4HMLGen.FOLLOW_HamExtfingerur_in_extfidir4951); 
dir = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:756:13: HamExtfingerr
this.match(this.input,HamExtfingerr,Ham4HMLGen.FOLLOW_HamExtfingerr_in_extfidir4980); 
dir = "r"; 
break;
case 4 :
// Ham4HMLGen.g:757:13: HamExtfingerdr
this.match(this.input,HamExtfingerdr,Ham4HMLGen.FOLLOW_HamExtfingerdr_in_extfidir5010); 
dir = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:758:13: HamExtfingerd
this.match(this.input,HamExtfingerd,Ham4HMLGen.FOLLOW_HamExtfingerd_in_extfidir5039); 
dir = "d"; 
break;
case 6 :
// Ham4HMLGen.g:759:13: HamExtfingerdl
this.match(this.input,HamExtfingerdl,Ham4HMLGen.FOLLOW_HamExtfingerdl_in_extfidir5069); 
dir = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:760:13: HamExtfingerl
this.match(this.input,HamExtfingerl,Ham4HMLGen.FOLLOW_HamExtfingerl_in_extfidir5098); 
dir = "l"; 
break;
case 8 :
// Ham4HMLGen.g:761:13: HamExtfingerul
this.match(this.input,HamExtfingerul,Ham4HMLGen.FOLLOW_HamExtfingerul_in_extfidir5128); 
dir = "ul"; 
break;
case 9 :
// Ham4HMLGen.g:763:13: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:763:13: ( HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:764:17: HamExtfingerol ( HamExtfingeruo | HamExtfingerdo )?
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir5185); 
dir = "ol"; 
// Ham4HMLGen.g:765:17: ( HamExtfingeruo | HamExtfingerdo )?
var alt51=3;
var LA51_0 = this.input.LA(1);
if ( (LA51_0==HamExtfingeruo) ) {
alt51=1;
}
else if ( (LA51_0==HamExtfingerdo) ) {
alt51=2;
}
switch (alt51) {
case 1 :
// Ham4HMLGen.g:766:21: HamExtfingeruo
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5236); 
dir = "uol"; 
break;
case 2 :
// Ham4HMLGen.g:767:21: HamExtfingerdo
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir5265); 
dir = "dol"; 
break;
}
break;
case 10 :
// Ham4HMLGen.g:770:13: HamExtfingero
this.match(this.input,HamExtfingero,Ham4HMLGen.FOLLOW_HamExtfingero_in_extfidir5319); 
dir = "o"; 
break;
case 11 :
// Ham4HMLGen.g:771:13: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:771:13: ( HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )? )
// Ham4HMLGen.g:772:17: HamExtfingeror ( HamExtfingeruo | HamExtfingerdo )?
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir5367); 
dir = "or"; 
// Ham4HMLGen.g:773:17: ( HamExtfingeruo | HamExtfingerdo )?
var alt52=3;
var LA52_0 = this.input.LA(1);
if ( (LA52_0==HamExtfingeruo) ) {
alt52=1;
}
else if ( (LA52_0==HamExtfingerdo) ) {
alt52=2;
}
switch (alt52) {
case 1 :
// Ham4HMLGen.g:774:21: HamExtfingeruo
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5418); 
dir = "uor"; 
break;
case 2 :
// Ham4HMLGen.g:775:21: HamExtfingerdo
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir5447); 
dir = "dor"; 
break;
}
break;
case 12 :
// Ham4HMLGen.g:778:13: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:778:13: ( HamExtfingeril ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:779:17: HamExtfingeril ( HamExtfingerui | HamExtfingerdi )?
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir5519); 
dir = "il"; 
// Ham4HMLGen.g:780:17: ( HamExtfingerui | HamExtfingerdi )?
var alt53=3;
var LA53_0 = this.input.LA(1);
if ( (LA53_0==HamExtfingerui) ) {
alt53=1;
}
else if ( (LA53_0==HamExtfingerdi) ) {
alt53=2;
}
switch (alt53) {
case 1 :
// Ham4HMLGen.g:781:21: HamExtfingerui
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir5570); 
dir = "uil"; 
break;
case 2 :
// Ham4HMLGen.g:782:21: HamExtfingerdi
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir5599); 
dir = "dil"; 
break;
}
break;
case 13 :
// Ham4HMLGen.g:785:13: HamExtfingeri
this.match(this.input,HamExtfingeri,Ham4HMLGen.FOLLOW_HamExtfingeri_in_extfidir5653); 
dir = "i"; 
break;
case 14 :
// Ham4HMLGen.g:786:13: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:786:13: ( HamExtfingerir ( HamExtfingerui | HamExtfingerdi )? )
// Ham4HMLGen.g:787:17: HamExtfingerir ( HamExtfingerui | HamExtfingerdi )?
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir5701); 
dir = "ir"; 
// Ham4HMLGen.g:788:17: ( HamExtfingerui | HamExtfingerdi )?
var alt54=3;
var LA54_0 = this.input.LA(1);
if ( (LA54_0==HamExtfingerui) ) {
alt54=1;
}
else if ( (LA54_0==HamExtfingerdi) ) {
alt54=2;
}
switch (alt54) {
case 1 :
// Ham4HMLGen.g:789:21: HamExtfingerui
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir5752); 
dir = "uir"; 
break;
case 2 :
// Ham4HMLGen.g:790:21: HamExtfingerdi
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir5781); 
dir = "dir"; 
break;
}
break;
case 15 :
// Ham4HMLGen.g:794:13: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:794:13: ( HamExtfingeruo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:795:17: HamExtfingeruo ( HamExtfingerol | HamExtfingeror )?
this.match(this.input,HamExtfingeruo,Ham4HMLGen.FOLLOW_HamExtfingeruo_in_extfidir5863); 
dir = "uo"; 
// Ham4HMLGen.g:796:17: ( HamExtfingerol | HamExtfingeror )?
var alt55=3;
var LA55_0 = this.input.LA(1);
if ( (LA55_0==HamExtfingerol) ) {
alt55=1;
}
else if ( (LA55_0==HamExtfingeror) ) {
alt55=2;
}
switch (alt55) {
case 1 :
// Ham4HMLGen.g:797:21: HamExtfingerol
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir5914); 
dir = "uol"; 
break;
case 2 :
// Ham4HMLGen.g:798:21: HamExtfingeror
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir5943); 
dir = "uor"; 
break;
}
break;
case 16 :
// Ham4HMLGen.g:801:13: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:801:13: ( HamExtfingerdo ( HamExtfingerol | HamExtfingeror )? )
// Ham4HMLGen.g:802:17: HamExtfingerdo ( HamExtfingerol | HamExtfingeror )?
this.match(this.input,HamExtfingerdo,Ham4HMLGen.FOLLOW_HamExtfingerdo_in_extfidir6015); 
dir = "do"; 
// Ham4HMLGen.g:803:17: ( HamExtfingerol | HamExtfingeror )?
var alt56=3;
var LA56_0 = this.input.LA(1);
if ( (LA56_0==HamExtfingerol) ) {
alt56=1;
}
else if ( (LA56_0==HamExtfingeror) ) {
alt56=2;
}
switch (alt56) {
case 1 :
// Ham4HMLGen.g:804:21: HamExtfingerol
this.match(this.input,HamExtfingerol,Ham4HMLGen.FOLLOW_HamExtfingerol_in_extfidir6066); 
dir = "dol"; 
break;
case 2 :
// Ham4HMLGen.g:805:21: HamExtfingeror
this.match(this.input,HamExtfingeror,Ham4HMLGen.FOLLOW_HamExtfingeror_in_extfidir6095); 
dir = "dor"; 
break;
}
break;
case 17 :
// Ham4HMLGen.g:808:13: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:808:13: ( HamExtfingerui ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:809:17: HamExtfingerui ( HamExtfingeril | HamExtfingerir )?
this.match(this.input,HamExtfingerui,Ham4HMLGen.FOLLOW_HamExtfingerui_in_extfidir6167); 
dir = "ui"; 
// Ham4HMLGen.g:810:17: ( HamExtfingeril | HamExtfingerir )?
var alt57=3;
var LA57_0 = this.input.LA(1);
if ( (LA57_0==HamExtfingeril) ) {
alt57=1;
}
else if ( (LA57_0==HamExtfingerir) ) {
alt57=2;
}
switch (alt57) {
case 1 :
// Ham4HMLGen.g:811:21: HamExtfingeril
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir6218); 
dir = "uil"; 
break;
case 2 :
// Ham4HMLGen.g:812:21: HamExtfingerir
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir6247); 
dir = "uir"; 
break;
}
break;
case 18 :
// Ham4HMLGen.g:815:13: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:815:13: ( HamExtfingerdi ( HamExtfingeril | HamExtfingerir )? )
// Ham4HMLGen.g:816:17: HamExtfingerdi ( HamExtfingeril | HamExtfingerir )?
this.match(this.input,HamExtfingerdi,Ham4HMLGen.FOLLOW_HamExtfingerdi_in_extfidir6319); 
dir = "di"; 
// Ham4HMLGen.g:817:17: ( HamExtfingeril | HamExtfingerir )?
var alt58=3;
var LA58_0 = this.input.LA(1);
if ( (LA58_0==HamExtfingeril) ) {
alt58=1;
}
else if ( (LA58_0==HamExtfingerir) ) {
alt58=2;
}
switch (alt58) {
case 1 :
// Ham4HMLGen.g:818:21: HamExtfingeril
this.match(this.input,HamExtfingeril,Ham4HMLGen.FOLLOW_HamExtfingeril_in_extfidir6370); 
dir = "dil"; 
break;
case 2 :
// Ham4HMLGen.g:819:21: HamExtfingerir
this.match(this.input,HamExtfingerir,Ham4HMLGen.FOLLOW_HamExtfingerir_in_extfidir6399); 
dir = "dir"; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
refd = "direction_" + dir;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return refd;
},
// Ham4HMLGen.g:832:1: palmor2 returns [Element rpo = null] : ^( PALMOR2 poa= palmor1 (pob= palmor1 )? ) ;
// $ANTLR start "palmor2"
palmor2: function() {
var rpo =  null;
var poa = null;
var pob = null;
try {
// Ham4HMLGen.g:835:5: ( ^( PALMOR2 poa= palmor1 (pob= palmor1 )? ) )
// Ham4HMLGen.g:836:5: ^( PALMOR2 poa= palmor1 (pob= palmor1 )? )
this.match(this.input,PALMOR2,Ham4HMLGen.FOLLOW_PALMOR2_in_palmor26500); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_palmor26518);
poa=this.palmor1();
this.state._fsp--;
// Ham4HMLGen.g:838:9: (pob= palmor1 )?
var alt60=2;
var LA60_0 = this.input.LA(1);
if ( (LA60_0==PALMOR1) ) {
alt60=1;
}
switch (alt60) {
case 1 :
// Ham4HMLGen.g:838:11: pob= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_palmor26536);
pob=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpo = hBuilder.newHMLElement("palmor2");
rpo.appendChild(poa);
hBuilder.checkedAppendChild(rpo, pob);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo;
},
// Ham4HMLGen.g:847:1: palmor1 returns [Element rpo1 = null] : ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? ) ;
// $ANTLR start "palmor1"
palmor1: function() {
var rpo1 =  null;
var poa = null;
var pob = null;
var approxpo = false;
var orirel = false;
try {
// Ham4HMLGen.g:854:5: ( ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? ) )
// Ham4HMLGen.g:855:5: ^( PALMOR1 poa= palmor (pob= palmor | HamEtc )? ( HamOrirelative )? )
this.match(this.input,PALMOR1,Ham4HMLGen.FOLLOW_PALMOR1_in_palmor16591); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_palmor_in_palmor16609);
poa=this.palmor();
this.state._fsp--;
// Ham4HMLGen.g:857:9: (pob= palmor | HamEtc )?
var alt61=3;
var LA61_0 = this.input.LA(1);
if ( ((LA61_0>=HamPalmu && LA61_0<=HamPalmul)) ) {
alt61=1;
}
else if ( (LA61_0==HamEtc) ) {
alt61=2;
}
switch (alt61) {
case 1 :
// Ham4HMLGen.g:858:13: pob= palmor
this.pushFollow(Ham4HMLGen.FOLLOW_palmor_in_palmor16637);
pob=this.palmor();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:860:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_palmor16667); 
approxpo = true; 
break;
}
// Ham4HMLGen.g:862:9: ( HamOrirelative )?
var alt62=2;
var LA62_0 = this.input.LA(1);
if ( (LA62_0==HamOrirelative) ) {
alt62=1;
}
switch (alt62) {
case 1 :
// Ham4HMLGen.g:862:19: HamOrirelative
this.match(this.input,HamOrirelative,Ham4HMLGen.FOLLOW_HamOrirelative_in_palmor16709); 
orirel = true; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpo1 = hBuilder.newHMLElement("palmor1");
rpo1.setAttribute("palmor", poa);
hBuilder.checkedSetAttr(rpo1, "second_palmor", pob);
hBuilder.checkedSetFlagAttr(rpo1, "approx_palmor", approxpo);
hBuilder.checkedSetFlagAttr(rpo1, "rel_palmor", orirel);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo1;
},
// Ham4HMLGen.g:874:1: palmor returns [String rpo = null] : ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul ) ;
// $ANTLR start "palmor"
palmor: function() {
var rpo =  null;
var  dir = null;
try {
// Ham4HMLGen.g:881:5: ( ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul ) )
// Ham4HMLGen.g:882:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
// Ham4HMLGen.g:882:5: ( HamPalmu | HamPalmur | HamPalmr | HamPalmdr | HamPalmd | HamPalmdl | HamPalml | HamPalmul )
var alt63=8;
switch ( this.input.LA(1) ) {
case HamPalmu:
alt63=1;
break;
case HamPalmur:
alt63=2;
break;
case HamPalmr:
alt63=3;
break;
case HamPalmdr:
alt63=4;
break;
case HamPalmd:
alt63=5;
break;
case HamPalmdl:
alt63=6;
break;
case HamPalml:
alt63=7;
break;
case HamPalmul:
alt63=8;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 63, 0, this.input);
throw nvae;
}
switch (alt63) {
case 1 :
// Ham4HMLGen.g:882:9: HamPalmu
this.match(this.input,HamPalmu,Ham4HMLGen.FOLLOW_HamPalmu_in_palmor6778); 
dir = "u"; 
break;
case 2 :
// Ham4HMLGen.g:883:9: HamPalmur
this.match(this.input,HamPalmur,Ham4HMLGen.FOLLOW_HamPalmur_in_palmor6801); 
dir = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:884:9: HamPalmr
this.match(this.input,HamPalmr,Ham4HMLGen.FOLLOW_HamPalmr_in_palmor6823); 
dir = "r"; 
break;
case 4 :
// Ham4HMLGen.g:885:9: HamPalmdr
this.match(this.input,HamPalmdr,Ham4HMLGen.FOLLOW_HamPalmdr_in_palmor6846); 
dir = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:886:9: HamPalmd
this.match(this.input,HamPalmd,Ham4HMLGen.FOLLOW_HamPalmd_in_palmor6868); 
dir = "d"; 
break;
case 6 :
// Ham4HMLGen.g:887:9: HamPalmdl
this.match(this.input,HamPalmdl,Ham4HMLGen.FOLLOW_HamPalmdl_in_palmor6891); 
dir = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:888:9: HamPalml
this.match(this.input,HamPalml,Ham4HMLGen.FOLLOW_HamPalml_in_palmor6913); 
dir = "l"; 
break;
case 8 :
// Ham4HMLGen.g:889:9: HamPalmul
this.match(this.input,HamPalmul,Ham4HMLGen.FOLLOW_HamPalmul_in_palmor6936); 
dir = "ul"; 
break;
}
rpo = "ham_palm_" + dir;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpo;
},
// Ham4HMLGen.g:899:1: location2 returns [Element rloc = null] : ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) ) ;
// $ANTLR start "location2"
location2: function() {
var rloc =  null;
var lc1 = null;
var lc1x = null;
var hc = null;
var lb = null;
var  ext = null;
try {
// Ham4HMLGen.g:905:5: ( ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) ) )
// Ham4HMLGen.g:906:5: ^( LOC2 (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? ) )
this.match(this.input,LOC2,Ham4HMLGen.FOLLOW_LOC2_in_location27001); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:907:9: (lc1= location1 (lc1x= location1 )? | hc= handconstellation ( HamArmextended | lb= locationbody )? )
var alt66=2;
var LA66_0 = this.input.LA(1);
if ( (LA66_0==LOC1) ) {
alt66=1;
}
else if ( (LA66_0==HCONSTLLN) ) {
alt66=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 66, 0, this.input);
throw nvae;
}
switch (alt66) {
case 1 :
// Ham4HMLGen.g:908:13: lc1= location1 (lc1x= location1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_location27033);
lc1=this.location1();
this.state._fsp--;
// Ham4HMLGen.g:909:13: (lc1x= location1 )?
var alt64=2;
var LA64_0 = this.input.LA(1);
if ( (LA64_0==LOC1) ) {
alt64=1;
}
switch (alt64) {
case 1 :
// Ham4HMLGen.g:909:15: lc1x= location1
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_location27054);
lc1x=this.location1();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:911:13: hc= handconstellation ( HamArmextended | lb= locationbody )?
this.pushFollow(Ham4HMLGen.FOLLOW_handconstellation_in_location27090);
hc=this.handconstellation();
this.state._fsp--;
// Ham4HMLGen.g:912:13: ( HamArmextended | lb= locationbody )?
var alt65=3;
var LA65_0 = this.input.LA(1);
if ( (LA65_0==HamArmextended) ) {
alt65=1;
}
else if ( (LA65_0==LOCTNBODY) ) {
alt65=2;
}
switch (alt65) {
case 1 :
// Ham4HMLGen.g:913:23: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_location27128); 
ext = "true"; 
break;
case 2 :
// Ham4HMLGen.g:915:17: lb= locationbody
this.pushFollow(Ham4HMLGen.FOLLOW_locationbody_in_location27174);
lb=this.locationbody();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rloc = hBuilder.newHMLElement("location2");
if (lc1 != null) {
rloc.appendChild(lc1);
hBuilder.checkedAppendChild(rloc, lc1x);
}
else {
rloc.appendChild(hc);
if (lb != null) {
rloc.appendChild(lb);
}
else if (ext != null) {
var neut = hBuilder.newHMLElement("hamneutral");
hBuilder.checkedSetAttr(neut, "armextended", ext);
rloc.appendChild(neut);
}
/* else nothing */
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rloc;
},
// Ham4HMLGen.g:940:1: location1 returns [Element rloc = null] : ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) ) ;
// $ANTLR start "location1"
location1: function() {
var rloc =  null;
var dig = null;
var loc = null;
try {
// Ham4HMLGen.g:943:5: ( ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) ) )
// Ham4HMLGen.g:944:5: ^( LOC1 (dig= digit | loc= locationhand | loc= locationbodyarm ) )
this.match(this.input,LOC1,Ham4HMLGen.FOLLOW_LOC1_in_location17245); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:945:9: (dig= digit | loc= locationhand | loc= locationbodyarm )
var alt67=3;
switch ( this.input.LA(1) ) {
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt67=1;
break;
case LOCTNHAND:
alt67=2;
break;
case LOCTNBODYARM:
alt67=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 67, 0, this.input);
throw nvae;
}
switch (alt67) {
case 1 :
// Ham4HMLGen.g:946:13: dig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_location17273);
dig=this.digit();
this.state._fsp--;
var dstr = dig.getAttribute("fingerid");
var ipos = "ham_digit_".length();
var locstr = "loc" + dstr.substring(ipos);
loc = hBuilder.newHMLElement("use_locname");
loc.setAttribute("use_locname", locstr);
break;
case 2 :
// Ham4HMLGen.g:955:13: loc= locationhand
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_location17315);
loc=this.locationhand();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:957:13: loc= locationbodyarm
this.pushFollow(Ham4HMLGen.FOLLOW_locationbodyarm_in_location17343);
loc=this.locationbodyarm();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rloc = hBuilder.newHMLElement("location1");
rloc.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rloc;
},
// Ham4HMLGen.g:967:1: locationbodyarm returns [Element rlba = null] : ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) ) ;
// $ANTLR start "locationbodyarm"
locationbodyarm: function() {
var rlba =  null;
var loc = null;
var  ext = null;
try {
// Ham4HMLGen.g:973:5: ( ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) ) )
// Ham4HMLGen.g:974:5: ^( LOCTNBODYARM (loc= locationbody | loc= locationarm | ( HamArmextended )? ) )
this.match(this.input,LOCTNBODYARM,Ham4HMLGen.FOLLOW_LOCTNBODYARM_in_locationbodyarm7397); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:975:9: (loc= locationbody | loc= locationarm | ( HamArmextended )? )
var alt69=3;
switch ( this.input.LA(1) ) {
case LOCTNBODY:
alt69=1;
break;
case LOCTNARM:
alt69=2;
break;
case UP:
case HamArmextended:
alt69=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 69, 0, this.input);
throw nvae;
}
switch (alt69) {
case 1 :
// Ham4HMLGen.g:976:13: loc= locationbody
this.pushFollow(Ham4HMLGen.FOLLOW_locationbody_in_locationbodyarm7425);
loc=this.locationbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:978:13: loc= locationarm
this.pushFollow(Ham4HMLGen.FOLLOW_locationarm_in_locationbodyarm7453);
loc=this.locationarm();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:980:13: ( HamArmextended )?
// Ham4HMLGen.g:980:13: ( HamArmextended )?
var alt68=2;
var LA68_0 = this.input.LA(1);
if ( (LA68_0==HamArmextended) ) {
alt68=1;
}
switch (alt68) {
case 1 :
// Ham4HMLGen.g:980:15: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_locationbodyarm7479); 
ext = "true"; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
if (loc == null) {
loc =  hBuilder.newHMLElement("hamneutral");
hBuilder.checkedSetAttr(loc, "armextended", ext);
}
rlba = hBuilder.newHMLElement("locationbodyarm");
rlba.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlba;
},
// Ham4HMLGen.g:993:1: locationbody returns [Element rlb = null] : ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? ) ;
// $ANTLR start "locationbody"
locationbody: function() {
var rlb =  null;
var lcb = null;
var cb = null;
var hb  = null;
try {
// Ham4HMLGen.g:999:5: ( ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? ) )
// Ham4HMLGen.g:1000:5: ^( LOCTNBODY lcb= levelcomplexbody ( HamBehind )? (cb= contactbody )? )
this.match(this.input,LOCTNBODY,Ham4HMLGen.FOLLOW_LOCTNBODY_in_locationbody7548); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexbody_in_locationbody7566);
lcb=this.levelcomplexbody();
this.state._fsp--;
// Ham4HMLGen.g:1002:9: ( HamBehind )?
var alt70=2;
var LA70_0 = this.input.LA(1);
if ( (LA70_0==HamBehind) ) {
alt70=1;
}
switch (alt70) {
case 1 :
// Ham4HMLGen.g:1002:19: HamBehind
this.match(this.input,HamBehind,Ham4HMLGen.FOLLOW_HamBehind_in_locationbody7586); 
hb = hBuilder.newHMLElement("hambehind"); 
break;
}
// Ham4HMLGen.g:1005:9: (cb= contactbody )?
var alt71=2;
var LA71_0 = this.input.LA(1);
if ( (LA71_0==CNTCTBODY) ) {
alt71=1;
}
switch (alt71) {
case 1 :
// Ham4HMLGen.g:1005:11: cb= contactbody
this.pushFollow(Ham4HMLGen.FOLLOW_contactbody_in_locationbody7642);
cb=this.contactbody();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlb = hBuilder.newHMLElement("locationbody");
rlb.appendChild(lcb);
hBuilder.checkedAppendChild(rlb, hb);
hBuilder.checkedAppendChild(rlb, cb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1015:1: locationhand returns [Element rlh = null] : ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? ) ;
// $ANTLR start "locationhand"
locationhand: function() {
var rlh =  null;
var lch = null;
var ch = null;
try {
// Ham4HMLGen.g:1018:5: ( ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? ) )
// Ham4HMLGen.g:1019:5: ^( LOCTNHAND lch= levelcomplexhand (ch= contacthand )? )
this.match(this.input,LOCTNHAND,Ham4HMLGen.FOLLOW_LOCTNHAND_in_locationhand7688); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexhand_in_locationhand7706);
lch=this.levelcomplexhand();
this.state._fsp--;
// Ham4HMLGen.g:1021:9: (ch= contacthand )?
var alt72=2;
var LA72_0 = this.input.LA(1);
if ( (LA72_0==CNTCTHAND) ) {
alt72=1;
}
switch (alt72) {
case 1 :
// Ham4HMLGen.g:1021:11: ch= contacthand
this.pushFollow(Ham4HMLGen.FOLLOW_contacthand_in_locationhand7725);
ch=this.contacthand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlh = hBuilder.newHMLElement("locationhand");
rlh.appendChild(lch);
hBuilder.checkedAppendChild(rlh, ch);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlh;
},
// Ham4HMLGen.g:1030:1: locationarm returns [Element rla = null] : ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? ) ;
// $ANTLR start "locationarm"
locationarm: function() {
var rla =  null;
var lca = null;
var cb = null;
var hb  = null;
try {
// Ham4HMLGen.g:1036:5: ( ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? ) )
// Ham4HMLGen.g:1037:5: ^( LOCTNARM lca= levelcomplexarm ( HamBehind )? (cb= contactbody )? )
this.match(this.input,LOCTNARM,Ham4HMLGen.FOLLOW_LOCTNARM_in_locationarm7776); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexarm_in_locationarm7794);
lca=this.levelcomplexarm();
this.state._fsp--;
// Ham4HMLGen.g:1039:9: ( HamBehind )?
var alt73=2;
var LA73_0 = this.input.LA(1);
if ( (LA73_0==HamBehind) ) {
alt73=1;
}
switch (alt73) {
case 1 :
// Ham4HMLGen.g:1039:19: HamBehind
this.match(this.input,HamBehind,Ham4HMLGen.FOLLOW_HamBehind_in_locationarm7814); 
hb = hBuilder.newHMLElement("hambehind"); 
break;
}
// Ham4HMLGen.g:1042:9: (cb= contactbody )?
var alt74=2;
var LA74_0 = this.input.LA(1);
if ( (LA74_0==CNTCTBODY) ) {
alt74=1;
}
switch (alt74) {
case 1 :
// Ham4HMLGen.g:1042:11: cb= contactbody
this.pushFollow(Ham4HMLGen.FOLLOW_contactbody_in_locationarm7870);
cb=this.contactbody();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rla = hBuilder.newHMLElement("locationarm");
rla.appendChild(lca);
hBuilder.checkedAppendChild(rla, hb);
hBuilder.checkedAppendChild(rla, cb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1052:1: levelcomplexbody returns [Element rlcb = null] : lba= levelbody (lbb= levelbody )? ;
// $ANTLR start "levelcomplexbody"
levelcomplexbody: function() {
var rlcb =  null;
var lba = null;
var lbb = null;
try {
// Ham4HMLGen.g:1055:5: (lba= levelbody (lbb= levelbody )? )
// Ham4HMLGen.g:1055:9: lba= levelbody (lbb= levelbody )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_levelcomplexbody7921);
lba=this.levelbody();
this.state._fsp--;
// Ham4HMLGen.g:1056:9: (lbb= levelbody )?
var alt75=2;
var LA75_0 = this.input.LA(1);
if ( (LA75_0==LEVBODY) ) {
alt75=1;
}
switch (alt75) {
case 1 :
// Ham4HMLGen.g:1056:11: lbb= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_levelcomplexbody7939);
lbb=this.levelbody();
this.state._fsp--;
break;
}
rlcb = hBuilder.newHMLElement("levelcomplexbody");
rlcb.appendChild(lba);
hBuilder.checkedAppendChild(rlcb, lbb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlcb;
},
// Ham4HMLGen.g:1064:1: levelcomplexhand returns [Element rlch = null] : lha= levelhand (lhb= levelhand )? ;
// $ANTLR start "levelcomplexhand"
levelcomplexhand: function() {
var rlch =  null;
var lha = null;
var lhb = null;
try {
// Ham4HMLGen.g:1067:5: (lha= levelhand (lhb= levelhand )? )
// Ham4HMLGen.g:1067:9: lha= levelhand (lhb= levelhand )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelhand_in_levelcomplexhand7984);
lha=this.levelhand();
this.state._fsp--;
// Ham4HMLGen.g:1068:9: (lhb= levelhand )?
var alt76=2;
var LA76_0 = this.input.LA(1);
if ( (LA76_0==LEVHAND) ) {
alt76=1;
}
switch (alt76) {
case 1 :
// Ham4HMLGen.g:1068:11: lhb= levelhand
this.pushFollow(Ham4HMLGen.FOLLOW_levelhand_in_levelcomplexhand8002);
lhb=this.levelhand();
this.state._fsp--;
break;
}
rlch = hBuilder.newHMLElement("levelcomplexhand");
rlch.appendChild(lha);
hBuilder.checkedAppendChild(rlch, lhb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlch;
},
// Ham4HMLGen.g:1076:1: levelcomplexarm returns [Element rlca = null] : laa= levelarm (lab= levelarm )? ;
// $ANTLR start "levelcomplexarm"
levelcomplexarm: function() {
var rlca =  null;
var laa = null;
var lab = null;
try {
// Ham4HMLGen.g:1079:5: (laa= levelarm (lab= levelarm )? )
// Ham4HMLGen.g:1079:9: laa= levelarm (lab= levelarm )?
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_levelcomplexarm8048);
laa=this.levelarm();
this.state._fsp--;
// Ham4HMLGen.g:1080:9: (lab= levelarm )?
var alt77=2;
var LA77_0 = this.input.LA(1);
if ( (LA77_0==LEVARM) ) {
alt77=1;
}
switch (alt77) {
case 1 :
// Ham4HMLGen.g:1080:11: lab= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_levelcomplexarm8066);
lab=this.levelarm();
this.state._fsp--;
break;
}
rlca = hBuilder.newHMLElement("levelcomplexarm");
rlca.appendChild(laa);
hBuilder.checkedAppendChild(rlca, lab);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlca;
},
// Ham4HMLGen.g:1088:1: levelbody returns [Element rlb = null] : ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelbody"
levelbody: function() {
var rlb =  null;
var sd = null;
var lb = null;
var approxlb = false;
try {
// Ham4HMLGen.g:1094:5: ( ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1095:5: ^( LEVBODY (sd= side[\"left\"] )? (lb= locbody | lb= locsided ) ( HamEtc )? (sd= side[\"right\"] )? )
this.match(this.input,LEVBODY,Ham4HMLGen.FOLLOW_LEVBODY_in_levelbody8113); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1096:9: (sd= side[\"left\"] )?
var alt78=2;
var LA78_0 = this.input.LA(1);
if ( ((LA78_0>=HamLrbeside && LA78_0<=HamLrat)) ) {
alt78=1;
}
switch (alt78) {
case 1 :
// Ham4HMLGen.g:1096:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelbody8132);
sd=this.side("left");
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1097:9: (lb= locbody | lb= locsided )
var alt79=2;
var LA79_0 = this.input.LA(1);
if ( (LA79_0==LOCBODY) ) {
alt79=1;
}
else if ( (LA79_0==HamEarlobe||(LA79_0>=HamEar && LA79_0<=HamCheek)) ) {
alt79=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 79, 0, this.input);
throw nvae;
}
switch (alt79) {
case 1 :
// Ham4HMLGen.g:1098:13: lb= locbody
this.pushFollow(Ham4HMLGen.FOLLOW_locbody_in_levelbody8165);
lb=this.locbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1100:13: lb= locsided
this.pushFollow(Ham4HMLGen.FOLLOW_locsided_in_levelbody8194);
lb=this.locsided();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1102:9: ( HamEtc )?
var alt80=2;
var LA80_0 = this.input.LA(1);
if ( (LA80_0==HamEtc) ) {
alt80=1;
}
switch (alt80) {
case 1 :
// Ham4HMLGen.g:1102:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_levelbody8224); 
approxlb = true; 
break;
}
// Ham4HMLGen.g:1103:9: (sd= side[\"right\"] )?
var alt81=2;
var LA81_0 = this.input.LA(1);
if ( ((LA81_0>=HamLrbeside && LA81_0<=HamLrat)) ) {
alt81=1;
}
switch (alt81) {
case 1 :
// Ham4HMLGen.g:1103:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelbody8259);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rlb = hBuilder.newHMLElement("levelbody");
rlb.setAttribute("locbody", lb);
hBuilder.checkedSetAttr(rlb, "side", sd);
hBuilder.checkedSetFlagAttr(rlb, "approx_location", approxlb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1113:1: levelhand returns [Element rlh = null] : ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelhand"
levelhand: function() {
var rlh =  null;
var sd = null;
var hp = null;
var fp = null;
var d = null;
var dp = null;
rlh = hBuilder.newHMLElement("levelhand");
try {
// Ham4HMLGen.g:1119:5: ( ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1120:5: ^( LEVHAND (sd= side[\"left\"] )? (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? ) (dp= dorsalorpalmar )? (sd= side[\"right\"] )? )
this.match(this.input,LEVHAND,Ham4HMLGen.FOLLOW_LEVHAND_in_levelhand8313); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1121:9: (sd= side[\"left\"] )?
var alt82=2;
var LA82_0 = this.input.LA(1);
if ( ((LA82_0>=HamLrbeside && LA82_0<=HamLrat)) ) {
alt82=1;
}
switch (alt82) {
case 1 :
// Ham4HMLGen.g:1121:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelhand8332);
sd=this.side("left");
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1122:9: (hp= handpart | fp= fingerpart (d= digit )* | (d= digit )+ (fp= fingerpart )? )
var alt86=3;
switch ( this.input.LA(1) ) {
case HamWristback:
case HamWristpulse:
case HamThumbball:
case HamPalm:
case HamHandback:
case HamThumbside:
case HamPinkyside:
alt86=1;
break;
case HamFingertip:
case HamFingernail:
case HamFingerpad:
case HamFingermidjoint:
case HamFingerbase:
case HamFingerside:
alt86=2;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
alt86=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 86, 0, this.input);
throw nvae;
}
switch (alt86) {
case 1 :
// Ham4HMLGen.g:1123:13: hp= handpart
this.pushFollow(Ham4HMLGen.FOLLOW_handpart_in_levelhand8365);
hp=this.handpart();
this.state._fsp--;
rlh.appendChild(hp); 
break;
case 2 :
// Ham4HMLGen.g:1126:13: fp= fingerpart (d= digit )*
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_levelhand8404);
fp=this.fingerpart();
this.state._fsp--;
rlh.appendChild(fp); 
// Ham4HMLGen.g:1127:13: (d= digit )*
loop83:
do {
var alt83=2;
var LA83_0 = this.input.LA(1);
if ( ((LA83_0>=HamThumb && LA83_0<=HamPinky)) ) {
alt83=1;
}
switch (alt83) {
case 1 :
// Ham4HMLGen.g:1127:15: d= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_levelhand8435);
d=this.digit();
this.state._fsp--;
rlh.appendChild(d); 
break;
default :
break loop83;
}
} while (true);
break;
case 3 :
// Ham4HMLGen.g:1129:13: (d= digit )+ (fp= fingerpart )?
// Ham4HMLGen.g:1129:13: (d= digit )+
var cnt84=0;
loop84:
do {
var alt84=2;
var LA84_0 = this.input.LA(1);
if ( ((LA84_0>=HamThumb && LA84_0<=HamPinky)) ) {
alt84=1;
}
switch (alt84) {
case 1 :
// Ham4HMLGen.g:1129:15: d= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_levelhand8478);
d=this.digit();
this.state._fsp--;
rlh.appendChild(d); 
break;
default :
if ( cnt84 >= 1 ) {
break loop84;
}
var eee = new org.antlr.runtime.EarlyExitException(84, this.input);
throw eee;
}
cnt84++;
} while (true);
// Ham4HMLGen.g:1130:13: (fp= fingerpart )?
var alt85=2;
var LA85_0 = this.input.LA(1);
if ( ((LA85_0>=HamFingertip && LA85_0<=HamFingerside)) ) {
alt85=1;
}
switch (alt85) {
case 1 :
// Ham4HMLGen.g:1130:15: fp= fingerpart
this.pushFollow(Ham4HMLGen.FOLLOW_fingerpart_in_levelhand8512);
fp=this.fingerpart();
this.state._fsp--;
rlh.appendChild(fp); 
break;
}
break;
}
// Ham4HMLGen.g:1141:9: (dp= dorsalorpalmar )?
var alt87=2;
var LA87_0 = this.input.LA(1);
if ( ((LA87_0>=HamPalm && LA87_0<=HamHandback)) ) {
alt87=1;
}
switch (alt87) {
case 1 :
// Ham4HMLGen.g:1141:11: dp= dorsalorpalmar
this.pushFollow(Ham4HMLGen.FOLLOW_dorsalorpalmar_in_levelhand8555);
dp=this.dorsalorpalmar();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1142:9: (sd= side[\"right\"] )?
var alt88=2;
var LA88_0 = this.input.LA(1);
if ( ((LA88_0>=HamLrbeside && LA88_0<=HamLrat)) ) {
alt88=1;
}
switch (alt88) {
case 1 :
// Ham4HMLGen.g:1142:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelhand8577);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
// Check for HNS-3 to HNS-4 conversion:
if (hp != null) {
if (hp.getAttribute("handpart") === "ham_wristpulse") {
hp.setAttribute("handpart", "ham_wristback");
rlh.setAttribute("dorsal_or_palmar", "palmar");
}
}
else
if (fp != null) {
if (fp.getAttribute("fingerpart") === "ham_finger_pad") {
fp.setAttribute("fingerpart", "ham_finger_nail");
rlh.setAttribute("dorsal_or_palmar", "palmar");
}
}
hBuilder.checkedSetAttr(rlh, "side", sd);
hBuilder.checkedSetAttr(rlh, "dorsal_or_palmar", dp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlh;
},
// Ham4HMLGen.g:1165:1: levelarm returns [Element rla = null] : ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) ;
// $ANTLR start "levelarm"
levelarm: function() {
var rla =  null;
var sd = null;
var la = null;
var dp = null;
var approxla = false;
try {
// Ham4HMLGen.g:1171:5: ( ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? ) )
// Ham4HMLGen.g:1172:5: ^( LEVARM (sd= side[\"left\"] )? la= locarm ( HamEtc )? (dp= dorsalorpalmar )? (sd= side[\"right\"] )? )
this.match(this.input,LEVARM,Ham4HMLGen.FOLLOW_LEVARM_in_levelarm8632); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1173:9: (sd= side[\"left\"] )?
var alt89=2;
var LA89_0 = this.input.LA(1);
if ( ((LA89_0>=HamLrbeside && LA89_0<=HamLrat)) ) {
alt89=1;
}
switch (alt89) {
case 1 :
// Ham4HMLGen.g:1173:11: sd= side[\"left\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelarm8651);
sd=this.side("left");
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_locarm_in_levelarm8674);
la=this.locarm();
this.state._fsp--;
// Ham4HMLGen.g:1175:9: ( HamEtc )?
var alt90=2;
var LA90_0 = this.input.LA(1);
if ( (LA90_0==HamEtc) ) {
alt90=1;
}
switch (alt90) {
case 1 :
// Ham4HMLGen.g:1175:19: HamEtc
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_levelarm8694); 
approxla = true; 
break;
}
// Ham4HMLGen.g:1176:9: (dp= dorsalorpalmar )?
var alt91=2;
var LA91_0 = this.input.LA(1);
if ( ((LA91_0>=HamPalm && LA91_0<=HamHandback)) ) {
alt91=1;
}
switch (alt91) {
case 1 :
// Ham4HMLGen.g:1176:11: dp= dorsalorpalmar
this.pushFollow(Ham4HMLGen.FOLLOW_dorsalorpalmar_in_levelarm8729);
dp=this.dorsalorpalmar();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1177:9: (sd= side[\"right\"] )?
var alt92=2;
var LA92_0 = this.input.LA(1);
if ( ((LA92_0>=HamLrbeside && LA92_0<=HamLrat)) ) {
alt92=1;
}
switch (alt92) {
case 1 :
// Ham4HMLGen.g:1177:11: sd= side[\"right\"]
this.pushFollow(Ham4HMLGen.FOLLOW_side_in_levelarm8751);
sd=this.side("right");
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rla = hBuilder.newHMLElement("levelarm");
rla.setAttribute("locarm", la);
hBuilder.checkedSetAttr(rla, "side", sd);
hBuilder.checkedSetAttr(rla, "dorsal_or_palmar", dp);
hBuilder.checkedSetFlagAttr(rla, "approx_location", approxla);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1188:1: contactbody returns [Element rcb = null] : ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) ) ;
// $ANTLR start "contactbody"
contactbody: function() {
var rcb =  null;
var cbsub = null;
try {
// Ham4HMLGen.g:1191:5: ( ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) ) )
// Ham4HMLGen.g:1192:5: ^( CNTCTBODY (cbsub= pcontact | HamArmextended | cbsub= contactofhand ) )
this.match(this.input,CNTCTBODY,Ham4HMLGen.FOLLOW_CNTCTBODY_in_contactbody8799); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1193:9: (cbsub= pcontact | HamArmextended | cbsub= contactofhand )
var alt93=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt93=1;
break;
case HamArmextended:
alt93=2;
break;
case CNTCTOFHAND:
alt93=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 93, 0, this.input);
throw nvae;
}
switch (alt93) {
case 1 :
// Ham4HMLGen.g:1194:13: cbsub= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contactbody8829);
cbsub=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1196:13: HamArmextended
this.match(this.input,HamArmextended,Ham4HMLGen.FOLLOW_HamArmextended_in_contactbody8853); 
cbsub = hBuilder.newHMLElement("hamarmextended"); 
break;
case 3 :
// Ham4HMLGen.g:1199:13: cbsub= contactofhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactofhand_in_contactbody8905);
cbsub=this.contactofhand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcb = hBuilder.wrapperEl("contactbody", cbsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcb;
},
// Ham4HMLGen.g:1207:1: contacthand returns [Element rch = null] : ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) ) ;
// $ANTLR start "contacthand"
contacthand: function() {
var rch =  null;
var chsub = null;
try {
// Ham4HMLGen.g:1210:5: ( ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) ) )
// Ham4HMLGen.g:1211:5: ^( CNTCTHAND (chsub= pcontact | chsub= ccontact | chsub= contactofhand ) )
this.match(this.input,CNTCTHAND,Ham4HMLGen.FOLLOW_CNTCTHAND_in_contacthand8959); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1212:9: (chsub= pcontact | chsub= ccontact | chsub= contactofhand )
var alt94=3;
switch ( this.input.LA(1) ) {
case HamClose:
case HamTouch:
alt94=1;
break;
case HamInterlock:
case HamCross:
alt94=2;
break;
case CNTCTOFHAND:
alt94=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 94, 0, this.input);
throw nvae;
}
switch (alt94) {
case 1 :
// Ham4HMLGen.g:1213:13: chsub= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contacthand8989);
chsub=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1215:13: chsub= ccontact
this.pushFollow(Ham4HMLGen.FOLLOW_ccontact_in_contacthand9019);
chsub=this.ccontact();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1217:13: chsub= contactofhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactofhand_in_contacthand9049);
chsub=this.contactofhand();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rch = hBuilder.wrapperEl("contacthand", chsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rch;
},
// Ham4HMLGen.g:1231:1: contactofhand returns [Element rcoh = null] : ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) ) ;
// $ANTLR start "contactofhand"
contactofhand: function() {
var rcoh =  null;
var pc = null;
var loc = null;
try {
// Ham4HMLGen.g:1234:5: ( ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) ) )
// Ham4HMLGen.g:1235:5: ^( CNTCTOFHAND (pc= pcontact | pc= ccontact ) (loc= contactohhand | loc= contactoharm ) )
this.match(this.input,CNTCTOFHAND,Ham4HMLGen.FOLLOW_CNTCTOFHAND_in_contactofhand9111); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1236:9: (pc= pcontact | pc= ccontact )
var alt95=2;
var LA95_0 = this.input.LA(1);
if ( ((LA95_0>=HamClose && LA95_0<=HamTouch)) ) {
alt95=1;
}
else if ( ((LA95_0>=HamInterlock && LA95_0<=HamCross)) ) {
alt95=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 95, 0, this.input);
throw nvae;
}
switch (alt95) {
case 1 :
// Ham4HMLGen.g:1237:13: pc= pcontact
this.pushFollow(Ham4HMLGen.FOLLOW_pcontact_in_contactofhand9144);
pc=this.pcontact();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1239:13: pc= ccontact
this.pushFollow(Ham4HMLGen.FOLLOW_ccontact_in_contactofhand9177);
pc=this.ccontact();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1241:9: (loc= contactohhand | loc= contactoharm )
var alt96=2;
var LA96_0 = this.input.LA(1);
if ( (LA96_0==CNTCTOHHAND) ) {
alt96=1;
}
else if ( (LA96_0==CNTCTOHARM) ) {
alt96=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 96, 0, this.input);
throw nvae;
}
switch (alt96) {
case 1 :
// Ham4HMLGen.g:1242:13: loc= contactohhand
this.pushFollow(Ham4HMLGen.FOLLOW_contactohhand_in_contactofhand9219);
loc=this.contactohhand();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1244:13: loc= contactoharm
this.pushFollow(Ham4HMLGen.FOLLOW_contactoharm_in_contactofhand9251);
loc=this.contactoharm();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcoh = hBuilder.newHMLElement("contactofhand");
rcoh.appendChild(pc);
rcoh.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcoh;
},
// Ham4HMLGen.g:1254:1: contactohhand returns [Element rcohh = null] : ^( CNTCTOHHAND cohh= levelcomplexhand ) ;
// $ANTLR start "contactohhand"
contactohhand: function() {
var rcohh =  null;
var cohh = null;
try {
// Ham4HMLGen.g:1258:5: ( ^( CNTCTOHHAND cohh= levelcomplexhand ) )
// Ham4HMLGen.g:1259:5: ^( CNTCTOHHAND cohh= levelcomplexhand )
this.match(this.input,CNTCTOHHAND,Ham4HMLGen.FOLLOW_CNTCTOHHAND_in_contactohhand9307); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexhand_in_contactohhand9321);
cohh=this.levelcomplexhand();
this.state._fsp--;
rcohh = cohh; 
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcohh;
},
// Ham4HMLGen.g:1264:1: contactoharm returns [Element rcoha = null] : ^( CNTCTOHARM coha= levelcomplexarm ) ;
// $ANTLR start "contactoharm"
contactoharm: function() {
var rcoha =  null;
var coha = null;
try {
// Ham4HMLGen.g:1268:5: ( ^( CNTCTOHARM coha= levelcomplexarm ) )
// Ham4HMLGen.g:1269:5: ^( CNTCTOHARM coha= levelcomplexarm )
this.match(this.input,CNTCTOHARM,Ham4HMLGen.FOLLOW_CNTCTOHARM_in_contactoharm9366); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_levelcomplexarm_in_contactoharm9380);
coha=this.levelcomplexarm();
this.state._fsp--;
rcoha = coha; 
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcoha;
},
// Ham4HMLGen.g:1274:1: handconstellation returns [Element rhc = null] : ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand ) ;
// $ANTLR start "handconstellation"
handconstellation: function() {
var rhc =  null;
var lha = null;
var lhb = null;
var ch = null;
try {
// Ham4HMLGen.g:1277:5: ( ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand ) )
// Ham4HMLGen.g:1278:5: ^( HCONSTLLN (lha= locationhand lhb= locationhand )? ch= contacthand )
this.match(this.input,HCONSTLLN,Ham4HMLGen.FOLLOW_HCONSTLLN_in_handconstellation9422); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1279:9: (lha= locationhand lhb= locationhand )?
var alt97=2;
var LA97_0 = this.input.LA(1);
if ( (LA97_0==LOCTNHAND) ) {
alt97=1;
}
switch (alt97) {
case 1 :
// Ham4HMLGen.g:1280:13: lha= locationhand lhb= locationhand
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_handconstellation9450);
lha=this.locationhand();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_locationhand_in_handconstellation9468);
lhb=this.locationhand();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_contacthand_in_handconstellation9498);
ch=this.contacthand();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rhc = hBuilder.newHMLElement("handconstellation");
hBuilder.checkedAppendChild(rhc, lha);
hBuilder.checkedAppendChild(rhc, lhb);
rhc.appendChild(ch);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhc;
},
// Ham4HMLGen.g:1296:1: locarm returns [String rla = null] : ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm ) ;
// $ANTLR start "locarm"
locarm: function() {
var rla =  null;
try {
// Ham4HMLGen.g:1298:5: ( ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm ) )
// Ham4HMLGen.g:1299:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
// Ham4HMLGen.g:1299:5: ( HamUpperarm | HamElbow | HamElbowinside | HamLowerarm )
var alt98=4;
switch ( this.input.LA(1) ) {
case HamUpperarm:
alt98=1;
break;
case HamElbow:
alt98=2;
break;
case HamElbowinside:
alt98=3;
break;
case HamLowerarm:
alt98=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 98, 0, this.input);
throw nvae;
}
switch (alt98) {
case 1 :
// Ham4HMLGen.g:1299:9: HamUpperarm
this.match(this.input,HamUpperarm,Ham4HMLGen.FOLLOW_HamUpperarm_in_locarm9553); 
rla = "ham_upperarm"; 
break;
case 2 :
// Ham4HMLGen.g:1300:9: HamElbow
this.match(this.input,HamElbow,Ham4HMLGen.FOLLOW_HamElbow_in_locarm9577); 
rla = "ham_elbow"; 
break;
case 3 :
// Ham4HMLGen.g:1301:9: HamElbowinside
this.match(this.input,HamElbowinside,Ham4HMLGen.FOLLOW_HamElbowinside_in_locarm9604); 
rla = "ham_elbowinside"; 
break;
case 4 :
// Ham4HMLGen.g:1302:9: HamLowerarm
this.match(this.input,HamLowerarm,Ham4HMLGen.FOLLOW_HamLowerarm_in_locarm9625); 
rla = "ham_lowerarm"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rla;
},
// Ham4HMLGen.g:1306:1: locbody returns [String rlb = null] : ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? ) ;
// $ANTLR start "locbody"
locbody: function() {
var rlb =  null;
var uprlwr = null;
try {
// Ham4HMLGen.g:1311:5: ( ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? ) )
// Ham4HMLGen.g:1312:5: ^( LOCBODY ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach ) ( HamDoublebent | HamDoublehooked )? )
this.match(this.input,LOCBODY,Ham4HMLGen.FOLLOW_LOCBODY_in_locbody9685); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1313:9: ( HamHead | HamHeadtop | HamForehead | HamEyebrows | HamEyes | HamNose | HamNostrils | HamLips | HamTongue | HamTeeth | HamChin | HamUnderchin | HamNeck | HamShouldertop | HamShoulders | HamChest | HamStomach | HamBelowstomach )
var alt99=18;
switch ( this.input.LA(1) ) {
case HamHead:
alt99=1;
break;
case HamHeadtop:
alt99=2;
break;
case HamForehead:
alt99=3;
break;
case HamEyebrows:
alt99=4;
break;
case HamEyes:
alt99=5;
break;
case HamNose:
alt99=6;
break;
case HamNostrils:
alt99=7;
break;
case HamLips:
alt99=8;
break;
case HamTongue:
alt99=9;
break;
case HamTeeth:
alt99=10;
break;
case HamChin:
alt99=11;
break;
case HamUnderchin:
alt99=12;
break;
case HamNeck:
alt99=13;
break;
case HamShouldertop:
alt99=14;
break;
case HamShoulders:
alt99=15;
break;
case HamChest:
alt99=16;
break;
case HamStomach:
alt99=17;
break;
case HamBelowstomach:
alt99=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 99, 0, this.input);
throw nvae;
}
switch (alt99) {
case 1 :
// Ham4HMLGen.g:1313:13: HamHead
this.match(this.input,HamHead,Ham4HMLGen.FOLLOW_HamHead_in_locbody9699); 
rlb = "ham_head"; 
break;
case 2 :
// Ham4HMLGen.g:1314:13: HamHeadtop
this.match(this.input,HamHeadtop,Ham4HMLGen.FOLLOW_HamHeadtop_in_locbody9731); 
rlb = "ham_headtop"; 
break;
case 3 :
// Ham4HMLGen.g:1315:13: HamForehead
this.match(this.input,HamForehead,Ham4HMLGen.FOLLOW_HamForehead_in_locbody9760); 
rlb = "ham_forehead"; 
break;
case 4 :
// Ham4HMLGen.g:1316:13: HamEyebrows
this.match(this.input,HamEyebrows,Ham4HMLGen.FOLLOW_HamEyebrows_in_locbody9788); 
rlb = "ham_eyebrows"; 
break;
case 5 :
// Ham4HMLGen.g:1317:13: HamEyes
this.match(this.input,HamEyes,Ham4HMLGen.FOLLOW_HamEyes_in_locbody9816); 
rlb = "ham_eyes"; 
break;
case 6 :
// Ham4HMLGen.g:1318:13: HamNose
this.match(this.input,HamNose,Ham4HMLGen.FOLLOW_HamNose_in_locbody9848); 
rlb = "ham_nose"; 
break;
case 7 :
// Ham4HMLGen.g:1319:13: HamNostrils
this.match(this.input,HamNostrils,Ham4HMLGen.FOLLOW_HamNostrils_in_locbody9880); 
rlb = "ham_nostrils"; 
break;
case 8 :
// Ham4HMLGen.g:1320:13: HamLips
this.match(this.input,HamLips,Ham4HMLGen.FOLLOW_HamLips_in_locbody9908); 
rlb = "ham_lips"; 
break;
case 9 :
// Ham4HMLGen.g:1321:13: HamTongue
this.match(this.input,HamTongue,Ham4HMLGen.FOLLOW_HamTongue_in_locbody9940); 
rlb = "ham_tongue"; 
break;
case 10 :
// Ham4HMLGen.g:1322:13: HamTeeth
this.match(this.input,HamTeeth,Ham4HMLGen.FOLLOW_HamTeeth_in_locbody9970); 
rlb = "ham_teeth"; 
break;
case 11 :
// Ham4HMLGen.g:1323:13: HamChin
this.match(this.input,HamChin,Ham4HMLGen.FOLLOW_HamChin_in_locbody10001); 
rlb = "ham_chin"; 
break;
case 12 :
// Ham4HMLGen.g:1324:13: HamUnderchin
this.match(this.input,HamUnderchin,Ham4HMLGen.FOLLOW_HamUnderchin_in_locbody10033); 
rlb = "ham_underchin"; 
break;
case 13 :
// Ham4HMLGen.g:1325:13: HamNeck
this.match(this.input,HamNeck,Ham4HMLGen.FOLLOW_HamNeck_in_locbody10060); 
rlb = "ham_neck"; 
break;
case 14 :
// Ham4HMLGen.g:1326:13: HamShouldertop
this.match(this.input,HamShouldertop,Ham4HMLGen.FOLLOW_HamShouldertop_in_locbody10092); 
rlb = "ham_shouldertop"; 
break;
case 15 :
// Ham4HMLGen.g:1327:13: HamShoulders
this.match(this.input,HamShoulders,Ham4HMLGen.FOLLOW_HamShoulders_in_locbody10117); 
rlb = "ham_shoulders"; 
break;
case 16 :
// Ham4HMLGen.g:1328:13: HamChest
this.match(this.input,HamChest,Ham4HMLGen.FOLLOW_HamChest_in_locbody10144); 
rlb = "ham_chest"; 
break;
case 17 :
// Ham4HMLGen.g:1329:13: HamStomach
this.match(this.input,HamStomach,Ham4HMLGen.FOLLOW_HamStomach_in_locbody10175); 
rlb = "ham_stomach"; 
break;
case 18 :
// Ham4HMLGen.g:1330:13: HamBelowstomach
this.match(this.input,HamBelowstomach,Ham4HMLGen.FOLLOW_HamBelowstomach_in_locbody10204); 
rlb = "ham_belowstomach"; 
break;
}
// Ham4HMLGen.g:1332:9: ( HamDoublebent | HamDoublehooked )?
var alt100=3;
var LA100_0 = this.input.LA(1);
if ( (LA100_0==HamDoublebent) ) {
alt100=1;
}
else if ( (LA100_0==HamDoublehooked) ) {
alt100=2;
}
switch (alt100) {
case 1 :
// Ham4HMLGen.g:1333:13: HamDoublebent
this.match(this.input,HamDoublebent,Ham4HMLGen.FOLLOW_HamDoublebent_in_locbody10248); 
uprlwr = "ham_upper"; 
break;
case 2 :
// Ham4HMLGen.g:1334:13: HamDoublehooked
this.match(this.input,HamDoublehooked,Ham4HMLGen.FOLLOW_HamDoublehooked_in_locbody10274); 
uprlwr = "ham_lower"; 
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (uprlwr != null) {
if (rlb === "ham_eyes") {
rlb = uprlwr + "eyelid";
}
else
if (rlb === "ham_lips") {
rlb = uprlwr + "lip";
}
else
if (rlb === "ham_teeth") {
rlb = uprlwr + "teeth";
}
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rlb;
},
// Ham4HMLGen.g:1354:1: locsided returns [String rls = null] : ( HamEar | HamEarlobe | HamCheek ) ;
// $ANTLR start "locsided"
locsided: function() {
var rls =  null;
try {
// Ham4HMLGen.g:1356:5: ( ( HamEar | HamEarlobe | HamCheek ) )
// Ham4HMLGen.g:1357:5: ( HamEar | HamEarlobe | HamCheek )
// Ham4HMLGen.g:1357:5: ( HamEar | HamEarlobe | HamCheek )
var alt101=3;
switch ( this.input.LA(1) ) {
case HamEar:
alt101=1;
break;
case HamEarlobe:
alt101=2;
break;
case HamCheek:
alt101=3;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 101, 0, this.input);
throw nvae;
}
switch (alt101) {
case 1 :
// Ham4HMLGen.g:1357:9: HamEar
this.match(this.input,HamEar,Ham4HMLGen.FOLLOW_HamEar_in_locsided10345); 
rls = "ham_ear"; 
break;
case 2 :
// Ham4HMLGen.g:1358:9: HamEarlobe
this.match(this.input,HamEarlobe,Ham4HMLGen.FOLLOW_HamEarlobe_in_locsided10374); 
rls = "ham_earlobe"; 
break;
case 3 :
// Ham4HMLGen.g:1359:9: HamCheek
this.match(this.input,HamCheek,Ham4HMLGen.FOLLOW_HamCheek_in_locsided10399); 
rls = "ham_cheek"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rls;
},
// Ham4HMLGen.g:1363:1: handpart returns [Element rhp = null] : ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside ) ;
// $ANTLR start "handpart"
handpart: function() {
var rhp =  null;
var  shp     = null;
try {
// Ham4HMLGen.g:1368:5: ( ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside ) )
// Ham4HMLGen.g:1369:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
// Ham4HMLGen.g:1369:5: ( HamWristback | HamWristpulse | HamThumbball | HamPalm | HamHandback | HamThumbside | HamPinkyside )
var alt102=7;
switch ( this.input.LA(1) ) {
case HamWristback:
alt102=1;
break;
case HamWristpulse:
alt102=2;
break;
case HamThumbball:
alt102=3;
break;
case HamPalm:
alt102=4;
break;
case HamHandback:
alt102=5;
break;
case HamThumbside:
alt102=6;
break;
case HamPinkyside:
alt102=7;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 102, 0, this.input);
throw nvae;
}
switch (alt102) {
case 1 :
// Ham4HMLGen.g:1369:9: HamWristback
this.match(this.input,HamWristback,Ham4HMLGen.FOLLOW_HamWristback_in_handpart10464); 
shp = "ham_wristback"; 
break;
case 2 :
// Ham4HMLGen.g:1370:9: HamWristpulse
this.match(this.input,HamWristpulse,Ham4HMLGen.FOLLOW_HamWristpulse_in_handpart10487); 
shp = "ham_wristpulse"; 
break;
case 3 :
// Ham4HMLGen.g:1371:9: HamThumbball
this.match(this.input,HamThumbball,Ham4HMLGen.FOLLOW_HamThumbball_in_handpart10509); 
shp = "ham_thumbball"; 
break;
case 4 :
// Ham4HMLGen.g:1372:9: HamPalm
this.match(this.input,HamPalm,Ham4HMLGen.FOLLOW_HamPalm_in_handpart10532); 
shp = "ham_palm"; 
break;
case 5 :
// Ham4HMLGen.g:1373:9: HamHandback
this.match(this.input,HamHandback,Ham4HMLGen.FOLLOW_HamHandback_in_handpart10560); 
shp = "ham_handback"; 
break;
case 6 :
// Ham4HMLGen.g:1374:9: HamThumbside
this.match(this.input,HamThumbside,Ham4HMLGen.FOLLOW_HamThumbside_in_handpart10584); 
shp = "ham_thumbside"; 
break;
case 7 :
// Ham4HMLGen.g:1375:9: HamPinkyside
this.match(this.input,HamPinkyside,Ham4HMLGen.FOLLOW_HamPinkyside_in_handpart10607); 
shp = "ham_pinkyside"; 
break;
}
rhp = hBuilder.newHMLElement("handpart");
rhp.setAttribute("handpart", shp);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rhp;
},
// Ham4HMLGen.g:1383:1: side[lh_or_rh] returns [String rs = null] : ( HamLrbeside | HamLrat ) ;
// $ANTLR start "side"
side: function(lh_or_rh) {
var rs =  null;
try {
// Ham4HMLGen.g:1388:5: ( ( HamLrbeside | HamLrat ) )
// Ham4HMLGen.g:1389:5: ( HamLrbeside | HamLrat )
// Ham4HMLGen.g:1389:5: ( HamLrbeside | HamLrat )
var alt103=2;
var LA103_0 = this.input.LA(1);
if ( (LA103_0==HamLrbeside) ) {
alt103=1;
}
else if ( (LA103_0==HamLrat) ) {
alt103=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 103, 0, this.input);
throw nvae;
}
switch (alt103) {
case 1 :
// Ham4HMLGen.g:1389:9: HamLrbeside
this.match(this.input,HamLrbeside,Ham4HMLGen.FOLLOW_HamLrbeside_in_side10692); 
rs = "beside"; 
break;
case 2 :
// Ham4HMLGen.g:1390:9: HamLrat
this.match(this.input,HamLrat,Ham4HMLGen.FOLLOW_HamLrat_in_side10716); 
rs = "at"; 
break;
}
rs = "ham_" + lh_or_rh + "_" + rs;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rs;
},
// Ham4HMLGen.g:1397:1: dorsalorpalmar returns [String rdp = null] : ( HamHandback | HamPalm ) ;
// $ANTLR start "dorsalorpalmar"
dorsalorpalmar: function() {
var rdp =  null;
try {
// Ham4HMLGen.g:1400:5: ( ( HamHandback | HamPalm ) )
// Ham4HMLGen.g:1401:5: ( HamHandback | HamPalm )
// Ham4HMLGen.g:1401:5: ( HamHandback | HamPalm )
var alt104=2;
var LA104_0 = this.input.LA(1);
if ( (LA104_0==HamHandback) ) {
alt104=1;
}
else if ( (LA104_0==HamPalm) ) {
alt104=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 104, 0, this.input);
throw nvae;
}
switch (alt104) {
case 1 :
// Ham4HMLGen.g:1401:9: HamHandback
this.match(this.input,HamHandback,Ham4HMLGen.FOLLOW_HamHandback_in_dorsalorpalmar10778); 
rdp = "dorsal"; 
break;
case 2 :
// Ham4HMLGen.g:1402:9: HamPalm
this.match(this.input,HamPalm,Ham4HMLGen.FOLLOW_HamPalm_in_dorsalorpalmar10802); 
rdp = "palmar"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rdp;
},
// Ham4HMLGen.g:1406:1: pcontact returns [Element rpc = null] : ( HamTouch | HamClose ) ;
// $ANTLR start "pcontact"
pcontact: function() {
var rpc =  null;
var  spc     = null;
try {
// Ham4HMLGen.g:1411:5: ( ( HamTouch | HamClose ) )
// Ham4HMLGen.g:1412:5: ( HamTouch | HamClose )
// Ham4HMLGen.g:1412:5: ( HamTouch | HamClose )
var alt105=2;
var LA105_0 = this.input.LA(1);
if ( (LA105_0==HamTouch) ) {
alt105=1;
}
else if ( (LA105_0==HamClose) ) {
alt105=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 105, 0, this.input);
throw nvae;
}
switch (alt105) {
case 1 :
// Ham4HMLGen.g:1412:9: HamTouch
this.match(this.input,HamTouch,Ham4HMLGen.FOLLOW_HamTouch_in_pcontact10868); 
spc = "ham_touch"; 
break;
case 2 :
// Ham4HMLGen.g:1413:9: HamClose
this.match(this.input,HamClose,Ham4HMLGen.FOLLOW_HamClose_in_pcontact10895); 
spc = "ham_close"; 
break;
}
rpc = hBuilder.newHMLElement("pcontact");
rpc.setAttribute("where", spc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpc;
},
// Ham4HMLGen.g:1421:1: ccontact returns [Element rcc = null] : ( HamInterlock | HamCross ) ;
// $ANTLR start "ccontact"
ccontact: function() {
var rcc =  null;
var  scc     = null;
try {
// Ham4HMLGen.g:1426:5: ( ( HamInterlock | HamCross ) )
// Ham4HMLGen.g:1427:5: ( HamInterlock | HamCross )
// Ham4HMLGen.g:1427:5: ( HamInterlock | HamCross )
var alt106=2;
var LA106_0 = this.input.LA(1);
if ( (LA106_0==HamInterlock) ) {
alt106=1;
}
else if ( (LA106_0==HamCross) ) {
alt106=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 106, 0, this.input);
throw nvae;
}
switch (alt106) {
case 1 :
// Ham4HMLGen.g:1427:9: HamInterlock
this.match(this.input,HamInterlock,Ham4HMLGen.FOLLOW_HamInterlock_in_ccontact10966); 
scc = "ham_interlock"; 
break;
case 2 :
// Ham4HMLGen.g:1428:9: HamCross
this.match(this.input,HamCross,Ham4HMLGen.FOLLOW_HamCross_in_ccontact10989); 
scc = "ham_cross"; 
break;
}
rcc = hBuilder.newHMLElement("ccontact");
rcc.setAttribute("crosskind", scc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcc;
},
// Ham4HMLGen.g:1439:1: a2tstar returns [Element[] ral = null] : ^( A2TLIST (a2t= action2t )* ) ;
// $ANTLR start "a2tstar"
a2tstar: function() {
var ral =  null;
var a2t = null;
alist   = [];
try {
// Ham4HMLGen.g:1445:5: ( ^( A2TLIST (a2t= action2t )* ) )
// Ham4HMLGen.g:1446:5: ^( A2TLIST (a2t= action2t )* )
this.match(this.input,A2TLIST,Ham4HMLGen.FOLLOW_A2TLIST_in_a2tstar11061); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1447:9: (a2t= action2t )*
loop107:
do {
var alt107=2;
var LA107_0 = this.input.LA(1);
if ( (LA107_0==ACTION2T) ) {
alt107=1;
}
switch (alt107) {
case 1 :
// Ham4HMLGen.g:1447:11: a2t= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_a2tstar11079);
a2t=this.action2t();
this.state._fsp--;
alist.push(a2t); 
break;
default :
break loop107;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
ral = alist;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ral;
},
// Ham4HMLGen.g:1454:1: a1tstar returns [Element[] ral = null] : ^( A1TLIST (a1t= action1t )* ) ;
// $ANTLR start "a1tstar"
a1tstar: function() {
var ral =  null;
var a1t = null;
var alist   = [];
try {
// Ham4HMLGen.g:1460:5: ( ^( A1TLIST (a1t= action1t )* ) )
// Ham4HMLGen.g:1461:5: ^( A1TLIST (a1t= action1t )* )
this.match(this.input,A1TLIST,Ham4HMLGen.FOLLOW_A1TLIST_in_a1tstar11141); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1462:9: (a1t= action1t )*
loop108:
do {
var alt108=2;
var LA108_0 = this.input.LA(1);
if ( (LA108_0==ACTION1T) ) {
alt108=1;
}
switch (alt108) {
case 1 :
// Ham4HMLGen.g:1462:11: a1t= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_a1tstar11159);
a1t=this.action1t();
this.state._fsp--;
alist.push(a1t); 
break;
default :
break loop108;
}
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
ral = alist;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ral;
},
// Ham4HMLGen.g:1469:1: action2t returns [Element ra = null] : ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? ) ;
// $ANTLR start "action2t"
action2t: function() {
var ra =  null;
var sub = null;
var a = null;
var loc = null;
var ra1 = null;
var ra2 = null;
try {
// Ham4HMLGen.g:1472:5: ( ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? ) )
// Ham4HMLGen.g:1473:5: ^( ACTION2T (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t ) ( repetitions[ra] )? )
this.match(this.input,ACTION2T,Ham4HMLGen.FOLLOW_ACTION2T_in_action2t11216); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1474:9: (sub= action1t | a= action1 loc= location2 | ra1= splitaction2loc2 | ra2= splitaction2t | sub= paraction2t | sub= seqaction2t | sub= seqfusedaction2t )
var alt109=7;
switch ( this.input.LA(1) ) {
case ACTION1T:
alt109=1;
break;
case ACTION1:
alt109=2;
break;
case SPLITACT2LOC2:
alt109=3;
break;
case SPLITACT2T:
alt109=4;
break;
case PARACT2T:
alt109=5;
break;
case SEQACT2T:
alt109=6;
break;
case SEQFUSEDACT2T:
alt109=7;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 109, 0, this.input);
throw nvae;
}
switch (alt109) {
case 1 :
// Ham4HMLGen.g:1475:13: sub= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_action2t11244);
sub=this.action1t();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1477:13: a= action1 loc= location2
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_action2t11274);
a=this.action1();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_action2t11292);
loc=this.location2();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1480:13: ra1= splitaction2loc2
this.pushFollow(Ham4HMLGen.FOLLOW_splitaction2loc2_in_action2t11321);
ra1=this.splitaction2loc2();
this.state._fsp--;
ra = ra1; 
break;
case 4 :
// Ham4HMLGen.g:1482:13: ra2= splitaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_splitaction2t_in_action2t11356);
ra2=this.splitaction2t();
this.state._fsp--;
ra = ra2; 
break;
case 5 :
// Ham4HMLGen.g:1484:13: sub= paraction2t
this.pushFollow(Ham4HMLGen.FOLLOW_paraction2t_in_action2t11393);
sub=this.paraction2t();
this.state._fsp--;
break;
case 6 :
// Ham4HMLGen.g:1486:13: sub= seqaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction2t_in_action2t11421);
sub=this.seqaction2t();
this.state._fsp--;
break;
case 7 :
// Ham4HMLGen.g:1488:13: sub= seqfusedaction2t
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction2t_in_action2t11449);
sub=this.seqfusedaction2t();
this.state._fsp--;
break;
}
if (ra == null) {
if (sub != null) {
ra = hBuilder.wrapperEl("action2t", sub);
}
else /* a != null */ {
ra = hBuilder.wrapPair("action2t", a, loc);
}
}
// Ham4HMLGen.g:1500:9: ( repetitions[ra] )?
var alt110=2;
var LA110_0 = this.input.LA(1);
if ( (LA110_0==REPETITIONS) ) {
alt110=1;
}
switch (alt110) {
case 1 :
// Ham4HMLGen.g:1500:11: repetitions[ra]
this.pushFollow(Ham4HMLGen.FOLLOW_repetitions_in_action2t11485);
this.repetitions(ra);
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
/*  TBD: allow location2? after repetitions, and in this case
*  wrap ra and the extra loc as a new action2t;
*/
ra = hBuilder.stripParentIfNotNeeded(ra);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1510:1: action1t returns [Element ra = null] : ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? ) ;
// $ANTLR start "action1t"
action1t: function() {
var ra =  null;
var a = null;
var tl = null;
var sub = null;
var ract = null;
var     bouncing= false;
try {
// Ham4HMLGen.g:1516:5: ( ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? ) )
// Ham4HMLGen.g:1517:5: ^( ACTION1T (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t ) ( repetitions[ra] )? )
this.match(this.input,ACTION1T,Ham4HMLGen.FOLLOW_ACTION1T_in_action1t11540); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1518:9: (a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )? | sub= paraction1t | sub= seqaction1t | sub= seqfusedaction1t | ract= nmaction1t )
var alt113=5;
switch ( this.input.LA(1) ) {
case ACTION1:
alt113=1;
break;
case PARACT1T:
alt113=2;
break;
case SEQACT1T:
alt113=3;
break;
case SEQFUSEDACT1T:
alt113=4;
break;
case NMACT1T:
alt113=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 113, 0, this.input);
throw nvae;
}
switch (alt113) {
case 1 :
// Ham4HMLGen.g:1519:13: a= action1 (tl= location1 ( HamLargemod )? | tl= handconstellation )?
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_action1t11574);
a=this.action1();
this.state._fsp--;
// Ham4HMLGen.g:1520:13: (tl= location1 ( HamLargemod )? | tl= handconstellation )?
var alt112=3;
var LA112_0 = this.input.LA(1);
if ( (LA112_0==LOC1) ) {
alt112=1;
}
else if ( (LA112_0==HCONSTLLN) ) {
alt112=2;
}
switch (alt112) {
case 1 :
// Ham4HMLGen.g:1521:17: tl= location1 ( HamLargemod )?
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_action1t11611);
tl=this.location1();
this.state._fsp--;
// Ham4HMLGen.g:1522:21: ( HamLargemod )?
var alt111=2;
var LA111_0 = this.input.LA(1);
if ( (LA111_0==HamLargemod) ) {
alt111=1;
}
switch (alt111) {
case 1 :
// Ham4HMLGen.g:1522:23: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_action1t11635); 
bouncing = true; 
break;
}
break;
case 2 :
// Ham4HMLGen.g:1524:17: tl= handconstellation
this.pushFollow(Ham4HMLGen.FOLLOW_handconstellation_in_action1t11679);
tl=this.handconstellation();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1527:13: sub= paraction1t
this.pushFollow(Ham4HMLGen.FOLLOW_paraction1t_in_action1t11726);
sub=this.paraction1t();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1529:13: sub= seqaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction1t_in_action1t11758);
sub=this.seqaction1t();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1531:13: sub= seqfusedaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction1t_in_action1t11790);
sub=this.seqfusedaction1t();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1533:13: ract= nmaction1t
this.pushFollow(Ham4HMLGen.FOLLOW_nmaction1t_in_action1t11821);
ract=this.nmaction1t();
this.state._fsp--;
ra = ract; 
break;
}
if (ra == null) {
if (sub != null) {
ra = hBuilder.wrapperEl("action1t", sub);
}
else /* a != null */ {
hBuilder.checkedSetFlagAttr(
a, "bouncing", bouncing);
ra = hBuilder.wrapperEl("action1t", a);
hBuilder.checkedAppendChild(ra, tl);
}
}
// Ham4HMLGen.g:1548:9: ( repetitions[ra] )?
var alt114=2;
var LA114_0 = this.input.LA(1);
if ( (LA114_0==REPETITIONS) ) {
alt114=1;
}
switch (alt114) {
case 1 :
// Ham4HMLGen.g:1548:11: repetitions[ra]
this.pushFollow(Ham4HMLGen.FOLLOW_repetitions_in_action1t11863);
this.repetitions(ra);
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
/*  TBD: allow location1? after repetitions, and in this case
*  wrap ra and the extra loc as a new action1t;
*/
ra = hBuilder.stripParentIfNotNeeded(ra);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1558:1: action1 returns [Element ra = null] : ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) ) ;
// $ANTLR start "action1"
action1: function() {
var ra =  null;
var sub = null;
var mod = null;
var     bouncing    = false;
try {
// Ham4HMLGen.g:1564:5: ( ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) ) )
// Ham4HMLGen.g:1565:5: ^( ACTION1 ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 ) )
this.match(this.input,ACTION1,Ham4HMLGen.FOLLOW_ACTION1_in_action111919); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1566:9: ( HamNomotion | sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )? | sub= paraction1 | sub= seqaction1 | sub= seqfusedaction1 )
var alt118=5;
switch ( this.input.LA(1) ) {
case HamNomotion:
alt118=1;
break;
case SIMPLEMVMT:
alt118=2;
break;
case PARACT1:
alt118=3;
break;
case SEQACT1:
alt118=4;
break;
case SEQFUSEDACT1:
alt118=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 118, 0, this.input);
throw nvae;
}
switch (alt118) {
case 1 :
// Ham4HMLGen.g:1567:23: HamNomotion
this.match(this.input,HamNomotion,Ham4HMLGen.FOLLOW_HamNomotion_in_action111953); 
sub = hBuilder.newHMLElement("hamnomotion"); 
break;
case 2 :
// Ham4HMLGen.g:1570:13: sub= simplemovement ( (mod= modifier )+ ( HamLargemod )? )?
this.pushFollow(Ham4HMLGen.FOLLOW_simplemovement_in_action112009);
sub=this.simplemovement();
this.state._fsp--;
// Ham4HMLGen.g:1571:13: ( (mod= modifier )+ ( HamLargemod )? )?
var alt117=2;
var LA117_0 = this.input.LA(1);
if ( ((LA117_0>=HamFast && LA117_0<=HamHalt)) ) {
alt117=1;
}
switch (alt117) {
case 1 :
// Ham4HMLGen.g:1572:17: (mod= modifier )+ ( HamLargemod )?
// Ham4HMLGen.g:1572:17: (mod= modifier )+
var cnt115=0;
loop115:
do {
var alt115=2;
var LA115_0 = this.input.LA(1);
if ( ((LA115_0>=HamFast && LA115_0<=HamHalt)) ) {
alt115=1;
}
switch (alt115) {
case 1 :
// Ham4HMLGen.g:1573:17: mod= modifier
this.pushFollow(Ham4HMLGen.FOLLOW_modifier_in_action112063);
mod=this.modifier();
this.state._fsp--;
sub.setAttribute(mod, "true"); 
break;
default :
if ( cnt115 >= 1 ) {
break loop115;
}
var eee = new org.antlr.runtime.EarlyExitException(115, this.input);
throw eee;
}
cnt115++;
} while (true);
// Ham4HMLGen.g:1576:21: ( HamLargemod )?
var alt116=2;
var LA116_0 = this.input.LA(1);
if ( (LA116_0==HamLargemod) ) {
alt116=1;
}
switch (alt116) {
case 1 :
// Ham4HMLGen.g:1576:23: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_action112130); 
bouncing = true; 
break;
}
break;
}
break;
case 3 :
// Ham4HMLGen.g:1579:13: sub= paraction1
this.pushFollow(Ham4HMLGen.FOLLOW_paraction1_in_action112184);
sub=this.paraction1();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1581:13: sub= seqaction1
this.pushFollow(Ham4HMLGen.FOLLOW_seqaction1_in_action112216);
sub=this.seqaction1();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1583:13: sub= seqfusedaction1
this.pushFollow(Ham4HMLGen.FOLLOW_seqfusedaction1_in_action112248);
sub=this.seqfusedaction1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
ra = hBuilder.wrapIfNeeded("action1", sub);
hBuilder.checkedSetFlagAttr(ra, "bouncing", bouncing);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:1595:1: paraction2t returns [Element rpa = null] : ^( PARACT2T (a= action2t )+ ) ;
// $ANTLR start "paraction2t"
paraction2t: function() {
var rpa =  null;
var a = null;
al  = [];
try {
// Ham4HMLGen.g:1601:5: ( ^( PARACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1602:5: ^( PARACT2T (a= action2t )+ )
this.match(this.input,PARACT2T,Ham4HMLGen.FOLLOW_PARACT2T_in_paraction2t12309); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1603:9: (a= action2t )+
var cnt119=0;
loop119:
do {
var alt119=2;
var LA119_0 = this.input.LA(1);
if ( (LA119_0==ACTION2T) ) {
alt119=1;
}
switch (alt119) {
case 1 :
// Ham4HMLGen.g:1604:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_paraction2t12339);
a=this.action2t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt119 >= 1 ) {
break loop119;
}
var eee = new org.antlr.runtime.EarlyExitException(119, this.input);
throw eee;
}
cnt119++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action2t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1612:1: seqaction2t returns [Element rsa = null] : ^( SEQACT2T (a= action2t )+ ) ;
// $ANTLR start "seqaction2t"
seqaction2t: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1618:5: ( ^( SEQACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1619:5: ^( SEQACT2T (a= action2t )+ )
this.match(this.input,SEQACT2T,Ham4HMLGen.FOLLOW_SEQACT2T_in_seqaction2t12405); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1620:9: (a= action2t )+
var cnt120=0;
loop120:
do {
var alt120=2;
var LA120_0 = this.input.LA(1);
if ( (LA120_0==ACTION2T) ) {
alt120=1;
}
switch (alt120) {
case 1 :
// Ham4HMLGen.g:1621:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_seqaction2t12435);
a=this.action2t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt120 >= 1 ) {
break loop120;
}
var eee = new org.antlr.runtime.EarlyExitException(120, this.input);
throw eee;
}
cnt120++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action2t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1629:1: seqfusedaction2t returns [Element rsfa = null] : ^( SEQFUSEDACT2T (a= action2t )+ ) ;
// $ANTLR start "seqfusedaction2t"
seqfusedaction2t: function() {
var rsfa =  null;
var a = null;
var al = [];
try {
// Ham4HMLGen.g:1636:5: ( ^( SEQFUSEDACT2T (a= action2t )+ ) )
// Ham4HMLGen.g:1637:5: ^( SEQFUSEDACT2T (a= action2t )+ )
this.match(this.input,SEQFUSEDACT2T,Ham4HMLGen.FOLLOW_SEQFUSEDACT2T_in_seqfusedaction2t12504); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1638:9: (a= action2t )+
var cnt121=0;
loop121:
do {
var alt121=2;
var LA121_0 = this.input.LA(1);
if ( (LA121_0==ACTION2T) ) {
alt121=1;
}
switch (alt121) {
case 1 :
// Ham4HMLGen.g:1639:13: a= action2t
this.pushFollow(Ham4HMLGen.FOLLOW_action2t_in_seqfusedaction2t12534);
a=this.action2t();
this.state._fsp--;
al.add(a); 
break;
default :
if ( cnt121 >= 1 ) {
break loop121;
}
var eee = new org.antlr.runtime.EarlyExitException(121, this.input);
throw eee;
}
cnt121++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action2t");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1650:1: splitaction2loc2 returns [Element rsal = null] : ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 ) ;
// $ANTLR start "splitaction2loc2"
splitaction2loc2: function() {
var rsal =  null;
var a = null;
var loc = null;
var sadom   = hBuilder.newHMLElement("seq_action1");
var sasub   = hBuilder.newHMLElement("seq_action1");
try {
// Ham4HMLGen.g:1657:5: ( ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 ) )
// Ham4HMLGen.g:1658:5: ^( SPLITACT2LOC2 (a= action1 )+ HamPlus (a= action1 )+ loc= location2 )
this.match(this.input,SPLITACT2LOC2,Ham4HMLGen.FOLLOW_SPLITACT2LOC2_in_splitaction2loc212599); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1659:9: (a= action1 )+
var cnt122=0;
loop122:
do {
var alt122=2;
var LA122_0 = this.input.LA(1);
if ( (LA122_0==ACTION1) ) {
alt122=1;
}
switch (alt122) {
case 1 :
// Ham4HMLGen.g:1659:11: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_splitaction2loc212619);
a=this.action1();
this.state._fsp--;
sadom.appendChild(a); 
break;
default :
if ( cnt122 >= 1 ) {
break loop122;
}
var eee = new org.antlr.runtime.EarlyExitException(122, this.input);
throw eee;
}
cnt122++;
} while (true);
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_splitaction2loc212642); 
// Ham4HMLGen.g:1661:9: (a= action1 )+
var cnt123=0;
loop123:
do {
var alt123=2;
var LA123_0 = this.input.LA(1);
if ( (LA123_0==ACTION1) ) {
alt123=1;
}
switch (alt123) {
case 1 :
// Ham4HMLGen.g:1661:11: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_splitaction2loc212662);
a=this.action1();
this.state._fsp--;
sasub.appendChild(a); 
break;
default :
if ( cnt123 >= 1 ) {
break loop123;
}
var eee = new org.antlr.runtime.EarlyExitException(123, this.input);
throw eee;
}
cnt123++;
} while (true);
this.pushFollow(Ham4HMLGen.FOLLOW_location2_in_splitaction2loc212693);
loc=this.location2();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
var a2  = hBuilder.newHMLElement("action2");
// A singleton sequence can be unwrapped, rather
// than being wrapped.
var adom =
sadom.childNodes.length==1 ?
sadom.firstChild :
hBuilder.wrapperEl("action1", sadom);
a2.appendChild(adom);
// Again, choose between unwrapping and wrapping.
var asub =
sasub.childNodes.length==1 ?
sasub.firstChild :
hBuilder.wrapperEl("action1", sasub);
a2.appendChild(asub);
rsal = hBuilder.newHMLElement("action2t");
rsal.appendChild(a2);
rsal.appendChild(loc);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsal;
},
// Ham4HMLGen.g:1688:1: splitaction2t returns [Element rsa = null] : ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ ) ;
// $ANTLR start "splitaction2t"
splitaction2t: function() {
var rsa =  null;
var at = null;
var satdom  = hBuilder.newHMLElement("seq_action1t");
var satsub  = hBuilder.newHMLElement("seq_action1t");
try {
// Ham4HMLGen.g:1695:5: ( ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ ) )
// Ham4HMLGen.g:1696:5: ^( SPLITACT2T (at= action1t )+ HamPlus (at= action1t )+ )
this.match(this.input,SPLITACT2T,Ham4HMLGen.FOLLOW_SPLITACT2T_in_splitaction2t12739); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1697:9: (at= action1t )+
var cnt124=0;
loop124:
do {
var alt124=2;
var LA124_0 = this.input.LA(1);
if ( (LA124_0==ACTION1T) ) {
alt124=1;
}
switch (alt124) {
case 1 :
// Ham4HMLGen.g:1697:11: at= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_splitaction2t12758);
at=this.action1t();
this.state._fsp--;
satdom.appendChild(at); 
break;
default :
if ( cnt124 >= 1 ) {
break loop124;
}
var eee = new org.antlr.runtime.EarlyExitException(124, this.input);
throw eee;
}
cnt124++;
} while (true);
this.match(this.input,HamPlus,Ham4HMLGen.FOLLOW_HamPlus_in_splitaction2t12780); 
// Ham4HMLGen.g:1699:9: (at= action1t )+
var cnt125=0;
loop125:
do {
var alt125=2;
var LA125_0 = this.input.LA(1);
if ( (LA125_0==ACTION1T) ) {
alt125=1;
}
switch (alt125) {
case 1 :
// Ham4HMLGen.g:1699:11: at= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_splitaction2t12799);
at=this.action1t();
this.state._fsp--;
satsub.appendChild(at); 
break;
default :
if ( cnt125 >= 1 ) {
break loop125;
}
var eee = new org.antlr.runtime.EarlyExitException(125, this.input);
throw eee;
}
cnt125++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.newHMLElement("action2t");
// A singleton sequence can be unwrapped, rather
// than being wrapped.
var atdom =
satdom.childNodes.length==1 ?
satdom.firstChild :
hBuilder.wrapperEl("action1t", satdom);
rsa.appendChild(atdom);
// Again, choose between unwrapping and wrapping.
var atsub =
satsub.childNodes.length==1 ?
satsub.firstChild :
hBuilder.wrapperEl("action1t", satsub);
rsa.appendChild(atsub);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1721:1: paraction1t returns [Element rpa = null] : ^( PARACT1T (a= action1t )+ ) ;
// $ANTLR start "paraction1t"
paraction1t: function() {
var rpa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1727:5: ( ^( PARACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1728:5: ^( PARACT1T (a= action1t )+ )
this.match(this.input,PARACT1T,Ham4HMLGen.FOLLOW_PARACT1T_in_paraction1t12859); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1729:9: (a= action1t )+
var cnt126=0;
loop126:
do {
var alt126=2;
var LA126_0 = this.input.LA(1);
if ( (LA126_0==ACTION1T) ) {
alt126=1;
}
switch (alt126) {
case 1 :
// Ham4HMLGen.g:1730:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_paraction1t12889);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt126 >= 1 ) {
break loop126;
}
var eee = new org.antlr.runtime.EarlyExitException(126, this.input);
throw eee;
}
cnt126++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action1t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1738:1: seqaction1t returns [Element rsa = null] : ^( SEQACT1T (a= action1t )+ ) ;
// $ANTLR start "seqaction1t"
seqaction1t: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1744:5: ( ^( SEQACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1745:5: ^( SEQACT1T (a= action1t )+ )
this.match(this.input,SEQACT1T,Ham4HMLGen.FOLLOW_SEQACT1T_in_seqaction1t12955); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1746:9: (a= action1t )+
var cnt127=0;
loop127:
do {
var alt127=2;
var LA127_0 = this.input.LA(1);
if ( (LA127_0==ACTION1T) ) {
alt127=1;
}
switch (alt127) {
case 1 :
// Ham4HMLGen.g:1747:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_seqaction1t12985);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt127 >= 1 ) {
break loop127;
}
var eee = new org.antlr.runtime.EarlyExitException(127, this.input);
throw eee;
}
cnt127++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action1t");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1755:1: seqfusedaction1t returns [Element rsfa = null] : ^( SEQFUSEDACT1T (a= action1t )+ ) ;
// $ANTLR start "seqfusedaction1t"
seqfusedaction1t: function() {
var rsfa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1762:5: ( ^( SEQFUSEDACT1T (a= action1t )+ ) )
// Ham4HMLGen.g:1763:5: ^( SEQFUSEDACT1T (a= action1t )+ )
this.match(this.input,SEQFUSEDACT1T,Ham4HMLGen.FOLLOW_SEQFUSEDACT1T_in_seqfusedaction1t13054); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1764:9: (a= action1t )+
var cnt128=0;
loop128:
do {
var alt128=2;
var LA128_0 = this.input.LA(1);
if ( (LA128_0==ACTION1T) ) {
alt128=1;
}
switch (alt128) {
case 1 :
// Ham4HMLGen.g:1765:13: a= action1t
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_seqfusedaction1t13084);
a=this.action1t();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt128 >= 1 ) {
break loop128;
}
var eee = new org.antlr.runtime.EarlyExitException(128, this.input);
throw eee;
}
cnt128++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action1t");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1776:1: nmaction1t returns [Element rnma = null] : ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t ) ;
// $ANTLR start "nmaction1t"
nmaction1t: function() {
var rnma =  null;
var hd = null;
var a = null;
try {
// Ham4HMLGen.g:1779:5: ( ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t ) )
// Ham4HMLGen.g:1780:5: ^( NMACT1T (hd= levelbody | hd= levelarm ) a= action1t )
this.match(this.input,NMACT1T,Ham4HMLGen.FOLLOW_NMACT1T_in_nmaction1t13147); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1781:9: (hd= levelbody | hd= levelarm )
var alt129=2;
var LA129_0 = this.input.LA(1);
if ( (LA129_0==LEVBODY) ) {
alt129=1;
}
else if ( (LA129_0==LEVARM) ) {
alt129=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 129, 0, this.input);
throw nvae;
}
switch (alt129) {
case 1 :
// Ham4HMLGen.g:1782:13: hd= levelbody
this.pushFollow(Ham4HMLGen.FOLLOW_levelbody_in_nmaction1t13176);
hd=this.levelbody();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1784:13: hd= levelarm
this.pushFollow(Ham4HMLGen.FOLLOW_levelarm_in_nmaction1t13205);
hd=this.levelarm();
this.state._fsp--;
break;
}
this.pushFollow(Ham4HMLGen.FOLLOW_action1t_in_nmaction1t13236);
a=this.action1t();
this.state._fsp--;
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rnma = hBuilder.newHMLElement("action1t");
rnma.appendChild(hd);
rnma.appendChild(a);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rnma;
},
// Ham4HMLGen.g:1796:1: paraction1 returns [Element rpa = null] : ^( PARACT1 (a= action1 )+ ) ;
// $ANTLR start "paraction1"
paraction1: function() {
var rpa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1802:5: ( ^( PARACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1803:5: ^( PARACT1 (a= action1 )+ )
this.match(this.input,PARACT1,Ham4HMLGen.FOLLOW_PARACT1_in_paraction113285); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1804:9: (a= action1 )+
var cnt130=0;
loop130:
do {
var alt130=2;
var LA130_0 = this.input.LA(1);
if ( (LA130_0==ACTION1) ) {
alt130=1;
}
switch (alt130) {
case 1 :
// Ham4HMLGen.g:1805:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_paraction113315);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt130 >= 1 ) {
break loop130;
}
var eee = new org.antlr.runtime.EarlyExitException(130, this.input);
throw eee;
}
cnt130++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rpa = hBuilder.elementFromList(al, "par_action1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rpa;
},
// Ham4HMLGen.g:1813:1: seqaction1 returns [Element rsa = null] : ^( SEQACT1 (a= action1 )+ ) ;
// $ANTLR start "seqaction1"
seqaction1: function() {
var rsa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1819:5: ( ^( SEQACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1820:5: ^( SEQACT1 (a= action1 )+ )
this.match(this.input,SEQACT1,Ham4HMLGen.FOLLOW_SEQACT1_in_seqaction113387); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1821:9: (a= action1 )+
var cnt131=0;
loop131:
do {
var alt131=2;
var LA131_0 = this.input.LA(1);
if ( (LA131_0==ACTION1) ) {
alt131=1;
}
switch (alt131) {
case 1 :
// Ham4HMLGen.g:1822:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_seqaction113417);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt131 >= 1 ) {
break loop131;
}
var eee = new org.antlr.runtime.EarlyExitException(131, this.input);
throw eee;
}
cnt131++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsa = hBuilder.elementFromList(al, "seq_action1");
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsa;
},
// Ham4HMLGen.g:1830:1: seqfusedaction1 returns [Element rsfa = null] : ^( SEQFUSEDACT1 (a= action1 )+ ) ;
// $ANTLR start "seqfusedaction1"
seqfusedaction1: function() {
var rsfa =  null;
var a = null;
var al  = [];
try {
// Ham4HMLGen.g:1837:5: ( ^( SEQFUSEDACT1 (a= action1 )+ ) )
// Ham4HMLGen.g:1838:5: ^( SEQFUSEDACT1 (a= action1 )+ )
this.match(this.input,SEQFUSEDACT1,Ham4HMLGen.FOLLOW_SEQFUSEDACT1_in_seqfusedaction113492); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1839:9: (a= action1 )+
var cnt132=0;
loop132:
do {
var alt132=2;
var LA132_0 = this.input.LA(1);
if ( (LA132_0==ACTION1) ) {
alt132=1;
}
switch (alt132) {
case 1 :
// Ham4HMLGen.g:1840:13: a= action1
this.pushFollow(Ham4HMLGen.FOLLOW_action1_in_seqfusedaction113522);
a=this.action1();
this.state._fsp--;
al.push(a); 
break;
default :
if ( cnt132 >= 1 ) {
break loop132;
}
var eee = new org.antlr.runtime.EarlyExitException(132, this.input);
throw eee;
}
cnt132++;
} while (true);
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsfa = hBuilder.elementFromList(al, "seq_action1");
if (al.length != 1) {
rsfa.setAttribute("fused", "true");
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsfa;
},
// Ham4HMLGen.g:1851:1: repetitions[action] : ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) ) ;
// $ANTLR start "repetitions"
repetitions: function(action) {
var r0 = null;
var ed = null;
var r1 = null;
var sc = null;
var sz = null;
var     approxrpt = false;
var     alta    = false;
var     altb    = false;
try {
// Ham4HMLGen.g:1858:5: ( ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) ) )
// Ham4HMLGen.g:1859:5: ^( REPETITIONS ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? ) )
this.match(this.input,REPETITIONS,Ham4HMLGen.FOLLOW_REPETITIONS_in_repetitions13595); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1860:9: ( (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )? | HamAlternatingmotion ( HamAlternatingmotion )? )
var alt141=2;
var LA141_0 = this.input.LA(1);
if ( ((LA141_0>=HamRepeatfromstart && LA141_0<=HamRepeatcontinueseveral)||LA141_0==HamRepeatreverse||LA141_0==MOVINGREPETITION) ) {
alt141=1;
}
else if ( (LA141_0==HamAlternatingmotion) ) {
alt141=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 141, 0, this.input);
throw nvae;
}
switch (alt141) {
case 1 :
// Ham4HMLGen.g:1861:13: (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] ) (sc= sizechange (sz= size )? )? ( HamAlternatingmotion ( HamAlternatingmotion )? )?
// Ham4HMLGen.g:1861:13: (r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )? | movingrepetition[action] )
var alt135=2;
var LA135_0 = this.input.LA(1);
if ( ((LA135_0>=HamRepeatfromstart && LA135_0<=HamRepeatcontinueseveral)||LA135_0==HamRepeatreverse) ) {
alt135=1;
}
else if ( (LA135_0==MOVINGREPETITION) ) {
alt135=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 135, 0, this.input);
throw nvae;
}
switch (alt135) {
case 1 :
// Ham4HMLGen.g:1862:21: r0= repetition ( HamEtc (ed= ellipsedirection )? | r1= repetition )?
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_repetitions13646);
r0=this.repetition();
this.state._fsp--;
// Ham4HMLGen.g:1863:17: ( HamEtc (ed= ellipsedirection )? | r1= repetition )?
var alt134=3;
var LA134_0 = this.input.LA(1);
if ( (LA134_0==HamEtc) ) {
alt134=1;
}
else if ( ((LA134_0>=HamRepeatfromstart && LA134_0<=HamRepeatcontinueseveral)||LA134_0==HamRepeatreverse) ) {
alt134=2;
}
switch (alt134) {
case 1 :
// Ham4HMLGen.g:1864:27: HamEtc (ed= ellipsedirection )?
this.match(this.input,HamEtc,Ham4HMLGen.FOLLOW_HamEtc_in_repetitions13692); 
approxrpt = true; 
// Ham4HMLGen.g:1865:20: (ed= ellipsedirection )?
var alt133=2;
var LA133_0 = this.input.LA(1);
if ( ((LA133_0>=HamEllipseh && LA133_0<=HamEllipseul)) ) {
alt133=1;
}
switch (alt133) {
case 1 :
// Ham4HMLGen.g:1865:22: ed= ellipsedirection
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_repetitions13736);
ed=this.ellipsedirection();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1867:22: r1= repetition
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_repetitions13784);
r1=this.repetition();
this.state._fsp--;
break;
}
break;
case 2 :
// Ham4HMLGen.g:1870:27: movingrepetition[action]
this.pushFollow(Ham4HMLGen.FOLLOW_movingrepetition_in_repetitions13845);
this.movingrepetition(action);
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1872:13: (sc= sizechange (sz= size )? )?
var alt137=2;
var LA137_0 = this.input.LA(1);
if ( ((LA137_0>=HamIncreasing && LA137_0<=HamDecreasing)) ) {
alt137=1;
}
switch (alt137) {
case 1 :
// Ham4HMLGen.g:1873:17: sc= sizechange (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_repetitions13901);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:1874:17: (sz= size )?
var alt136=2;
var LA136_0 = this.input.LA(1);
if ( ((LA136_0>=HamSmallmod && LA136_0<=HamLargemod)) ) {
alt136=1;
}
switch (alt136) {
case 1 :
// Ham4HMLGen.g:1874:19: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_repetitions13928);
sz=this.size();
this.state._fsp--;
break;
}
break;
}
// Ham4HMLGen.g:1876:13: ( HamAlternatingmotion ( HamAlternatingmotion )? )?
var alt139=2;
var LA139_0 = this.input.LA(1);
if ( (LA139_0==HamAlternatingmotion) ) {
alt139=1;
}
switch (alt139) {
case 1 :
// Ham4HMLGen.g:1877:27: HamAlternatingmotion ( HamAlternatingmotion )?
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions13988); 
alta = true; 
// Ham4HMLGen.g:1878:7: ( HamAlternatingmotion )?
var alt138=2;
var LA138_0 = this.input.LA(1);
if ( (LA138_0==HamAlternatingmotion) ) {
alt138=1;
}
switch (alt138) {
case 1 :
// Ham4HMLGen.g:1878:9: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14001); 
altb = true; 
break;
}
break;
}
break;
case 2 :
// Ham4HMLGen.g:1881:13: HamAlternatingmotion ( HamAlternatingmotion )?
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14046); 
alta = true; 
// Ham4HMLGen.g:1882:13: ( HamAlternatingmotion )?
var alt140=2;
var LA140_0 = this.input.LA(1);
if ( (LA140_0==HamAlternatingmotion) ) {
alt140=1;
}
switch (alt140) {
case 1 :
// Ham4HMLGen.g:1882:15: HamAlternatingmotion
this.match(this.input,HamAlternatingmotion,Ham4HMLGen.FOLLOW_HamAlternatingmotion_in_repetitions14067); 
altb = true; 
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
if (r0 != null) {
hBuilder.checkedSetAttr(action, "repetition", r0);
hBuilder.checkedSetAttr(action, "second_repetition", r1);
if (approxrpt && r0.endsWith("fromstartseveral")) {
hBuilder.checkedSetAttr(action, "approx_repetition", "true");
hBuilder.checkedSetAttr(action, "ellipsedirection", ed);
}
}
hBuilder.checkedSetAttr(action, "repetition_incrdecr", sc);
hBuilder.checkedSetAttr(action, "repetition_incrdecr_size", sz);
hBuilder.checkedSetFlagAttr(action, "alternating", alta);
hBuilder.checkedSetFlagAttr(action, "second_alternating", altb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:1901:1: movingrepetition[action] : ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? ) ;
// $ANTLR start "movingrepetition"
movingrepetition: function(action) {
var r = null;
var ma = null;
var sz = null;
var sc = null;
var idsz = null;
try {
// Ham4HMLGen.g:1903:5: ( ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? ) )
// Ham4HMLGen.g:1904:5: ^( MOVINGREPETITION r= repetition ma= movementarrow (sz= size )? (sc= sizechange (idsz= size )? )? )
this.match(this.input,MOVINGREPETITION,Ham4HMLGen.FOLLOW_MOVINGREPETITION_in_movingrepetition14124); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_repetition_in_movingrepetition14148);
r=this.repetition();
this.state._fsp--;
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_movingrepetition14171);
ma=this.movementarrow();
this.state._fsp--;
// Ham4HMLGen.g:1907:9: (sz= size )?
var alt142=2;
var LA142_0 = this.input.LA(1);
if ( ((LA142_0>=HamSmallmod && LA142_0<=HamLargemod)) ) {
alt142=1;
}
switch (alt142) {
case 1 :
// Ham4HMLGen.g:1907:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_movingrepetition14194);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1908:9: (sc= sizechange (idsz= size )? )?
var alt144=2;
var LA144_0 = this.input.LA(1);
if ( ((LA144_0>=HamIncreasing && LA144_0<=HamDecreasing)) ) {
alt144=1;
}
switch (alt144) {
case 1 :
// Ham4HMLGen.g:1909:13: sc= sizechange (idsz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_movingrepetition14230);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:1910:13: (idsz= size )?
var alt143=2;
var LA143_0 = this.input.LA(1);
if ( ((LA143_0>=HamSmallmod && LA143_0<=HamLargemod)) ) {
alt143=1;
}
switch (alt143) {
case 1 :
// Ham4HMLGen.g:1910:15: idsz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_movingrepetition14251);
idsz=this.size();
this.state._fsp--;
break;
}
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
hBuilder.checkedSetAttr(action, "repetition", r);
hBuilder.checkedSetAttr(action, "repetition_baseshift", ma);
hBuilder.checkedSetAttr(action, "baseshift_size", sz);
hBuilder.checkedSetAttr(action, "baseshift_incrdecr", sc);
hBuilder.checkedSetAttr(action, "baseshift_incrdecr_size", idsz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:1925:1: simplemovement returns [rsm = null] : ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? ) ;
// $ANTLR start "simplemovement"
simplemovement: function() {
var rsm =  null;
var mv = null;
var tmpdig = null;
var bl = null;
var dig = null;
var dl = null;
try {
// Ham4HMLGen.g:1931:5: ( ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? ) )
// Ham4HMLGen.g:1932:5: ^( SIMPLEMVMT (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay ) ( HamBrushing bl= location1 )? (dig= digit )? )
this.match(this.input,SIMPLEMVMT,Ham4HMLGen.FOLLOW_SIMPLEMVMT_in_simplemovement14313); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:1933:9: (mv= fullstraightmovement | mv= fullcircularmovement | mv= fullwristmovement | mv= fullmovementcross | mv= replacement | (tmpdig= digit )* HamFingerplay )
var alt146=6;
switch ( this.input.LA(1) ) {
case STRGHTMVMT:
alt146=1;
break;
case CRCLRMVMT:
alt146=2;
break;
case HamNodding:
case HamSwinging:
case HamTwisting:
case HamStircw:
case HamStirccw:
alt146=3;
break;
case HamMovecross:
case HamMovex:
alt146=4;
break;
case REPLACE:
alt146=5;
break;
case HamThumb:
case HamIndexfinger:
case HamMiddlefinger:
case HamRingfinger:
case HamPinky:
case HamFingerplay:
alt146=6;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 146, 0, this.input);
throw nvae;
}
switch (alt146) {
case 1 :
// Ham4HMLGen.g:1934:13: mv= fullstraightmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullstraightmovement_in_simplemovement14342);
mv=this.fullstraightmovement();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1936:13: mv= fullcircularmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullcircularmovement_in_simplemovement14371);
mv=this.fullcircularmovement();
this.state._fsp--;
break;
case 3 :
// Ham4HMLGen.g:1938:13: mv= fullwristmovement
this.pushFollow(Ham4HMLGen.FOLLOW_fullwristmovement_in_simplemovement14400);
mv=this.fullwristmovement();
this.state._fsp--;
break;
case 4 :
// Ham4HMLGen.g:1940:13: mv= fullmovementcross
this.pushFollow(Ham4HMLGen.FOLLOW_fullmovementcross_in_simplemovement14429);
mv=this.fullmovementcross();
this.state._fsp--;
break;
case 5 :
// Ham4HMLGen.g:1942:13: mv= replacement
this.pushFollow(Ham4HMLGen.FOLLOW_replacement_in_simplemovement14458);
mv=this.replacement();
this.state._fsp--;
break;
case 6 :
// Ham4HMLGen.g:1944:19: (tmpdig= digit )* HamFingerplay
// Ham4HMLGen.g:1944:19: (tmpdig= digit )*
loop145:
do {
var alt145=2;
var LA145_0 = this.input.LA(1);
if ( ((LA145_0>=HamThumb && LA145_0<=HamPinky)) ) {
alt145=1;
}
switch (alt145) {
case 1 :
// Ham4HMLGen.g:1945:23: tmpdig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_simplemovement14516);
tmpdig=this.digit();
this.state._fsp--;
if (dl == null) { dl = []; }
dl.push(tmpdig);
break;
default :
break loop145;
}
} while (true);
this.match(this.input,HamFingerplay,Ham4HMLGen.FOLLOW_HamFingerplay_in_simplemovement14581); 
mv = hBuilder.newHMLElement("hamfingerplay"); 
break;
}
// Ham4HMLGen.g:1954:9: ( HamBrushing bl= location1 )?
var alt147=2;
var LA147_0 = this.input.LA(1);
if ( (LA147_0==HamBrushing) ) {
alt147=1;
}
switch (alt147) {
case 1 :
// Ham4HMLGen.g:1955:19: HamBrushing bl= location1
this.match(this.input,HamBrushing,Ham4HMLGen.FOLLOW_HamBrushing_in_simplemovement14641); 
this.pushFollow(Ham4HMLGen.FOLLOW_location1_in_simplemovement14660);
bl=this.location1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1958:9: (dig= digit )?
var alt148=2;
var LA148_0 = this.input.LA(1);
if ( ((LA148_0>=HamThumb && LA148_0<=HamPinky)) ) {
alt148=1;
}
switch (alt148) {
case 1 :
// Ham4HMLGen.g:1958:13: dig= digit
this.pushFollow(Ham4HMLGen.FOLLOW_digit_in_simplemovement14689);
dig=this.digit();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsm = hBuilder.newHMLElement("simplemovement");
if (dl != null) {
for (var i = 0; i < dl.length; i++) { mv.appendChild(dl[i]); }
}
rsm.appendChild(mv);
hBuilder.checkedAppendChild(rsm, bl);
if (dig != null) {
var dstr = dig.getAttribute("fingerid");
var ipos = "ham_digit_".length();
var locstr = "loc" + dstr.substring(ipos);
hBuilder.checkedSetAttr(rsm, "def_locname", locstr);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsm;
},
// Ham4HMLGen.g:1976:1: fullstraightmovement returns [Element rfsm = null] : (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? ) ;
// $ANTLR start "fullstraightmovement"
fullstraightmovement: function() {
var rfsm =  null;
var fsm = null;
var sz = null;
try {
// Ham4HMLGen.g:1980:5: ( (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? ) )
// Ham4HMLGen.g:1981:5: (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? )
// Ham4HMLGen.g:1981:5: (fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )? )
// Ham4HMLGen.g:1982:9: fsm= straightmovement (sz= size )? ( arckind[rfsm] | zigzag[rfsm] )?
this.pushFollow(Ham4HMLGen.FOLLOW_straightmovement_in_fullstraightmovement14752);
fsm=this.straightmovement();
this.state._fsp--;
rfsm = fsm; 
// Ham4HMLGen.g:1983:9: (sz= size )?
var alt149=2;
var LA149_0 = this.input.LA(1);
if ( ((LA149_0>=HamSmallmod && LA149_0<=HamLargemod)) ) {
alt149=1;
}
switch (alt149) {
case 1 :
// Ham4HMLGen.g:1983:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullstraightmovement14777);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:1984:9: ( arckind[rfsm] | zigzag[rfsm] )?
var alt150=3;
var LA150_0 = this.input.LA(1);
if ( ((LA150_0>=HamArcl && LA150_0<=HamArcd)) ) {
alt150=1;
}
else if ( ((LA150_0>=HamWavy && LA150_0<=HamZigzag)) ) {
alt150=2;
}
switch (alt150) {
case 1 :
// Ham4HMLGen.g:1985:19: arckind[rfsm]
this.pushFollow(Ham4HMLGen.FOLLOW_arckind_in_fullstraightmovement14810);
this.arckind(rfsm);
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:1987:19: zigzag[rfsm]
this.pushFollow(Ham4HMLGen.FOLLOW_zigzag_in_fullstraightmovement14841);
this.zigzag(rfsm);
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(rfsm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfsm;
},
// Ham4HMLGen.g:1995:1: straightmovement returns [Element rsm = null] : ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? ) ;
// $ANTLR start "straightmovement"
straightmovement: function() {
var rsm =  null;
var ma = null;
var mb = null;
try {
// Ham4HMLGen.g:1998:5: ( ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? ) )
// Ham4HMLGen.g:1999:5: ^( STRGHTMVMT ma= movementarrow (mb= movementarrow )? )
this.match(this.input,STRGHTMVMT,Ham4HMLGen.FOLLOW_STRGHTMVMT_in_straightmovement14896); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_straightmovement14915);
ma=this.movementarrow();
this.state._fsp--;
// Ham4HMLGen.g:2001:9: (mb= movementarrow )?
var alt151=2;
var LA151_0 = this.input.LA(1);
if ( ((LA151_0>=HamMoveu && LA151_0<=HamMoveuo)) ) {
alt151=1;
}
switch (alt151) {
case 1 :
// Ham4HMLGen.g:2001:11: mb= movementarrow
this.pushFollow(Ham4HMLGen.FOLLOW_movementarrow_in_straightmovement14934);
mb=this.movementarrow();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsm = hBuilder.newHMLElement("straightmovement");
hBuilder.checkedSetAttr(rsm, "movement", ma);
hBuilder.checkedSetAttr(rsm, "second_movement", mb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsm;
},
// Ham4HMLGen.g:2010:1: arckind[ake] : (aa= arc (ab= arc )? (sz= size )? ) ;
// $ANTLR start "arckind"
arckind: function(ake) {
var aa = null;
var ab = null;
var sz = null;
try {
// Ham4HMLGen.g:2014:5: ( (aa= arc (ab= arc )? (sz= size )? ) )
// Ham4HMLGen.g:2015:5: (aa= arc (ab= arc )? (sz= size )? )
// Ham4HMLGen.g:2015:5: (aa= arc (ab= arc )? (sz= size )? )
// Ham4HMLGen.g:2016:9: aa= arc (ab= arc )? (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_arc_in_arckind15001);
aa=this.arc();
this.state._fsp--;
// Ham4HMLGen.g:2017:9: (ab= arc )?
var alt152=2;
var LA152_0 = this.input.LA(1);
if ( ((LA152_0>=HamArcl && LA152_0<=HamArcd)) ) {
alt152=1;
}
switch (alt152) {
case 1 :
// Ham4HMLGen.g:2017:11: ab= arc
this.pushFollow(Ham4HMLGen.FOLLOW_arc_in_arckind15020);
ab=this.arc();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2018:9: (sz= size )?
var alt153=2;
var LA153_0 = this.input.LA(1);
if ( ((LA153_0>=HamSmallmod && LA153_0<=HamLargemod)) ) {
alt153=1;
}
switch (alt153) {
case 1 :
// Ham4HMLGen.g:2018:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_arckind15043);
sz=this.size();
this.state._fsp--;
break;
}
if (ab != null) {
var   aax = aa.charAt(aa.length()-1);
var   abx = ab.charAt(ab.length()-1);
if (aax=='u' || aax=='d') {
if (abx=='l' || abx=='r') {
aa = aa + abx;
}
}
}
ake.setAttribute("arc", aa);
hBuilder.checkedSetAttr(ake, "arc_size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2035:1: zigzag[zze] : ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? ) ;
// $ANTLR start "zigzag"
zigzag: function(zze) {
var sz = null;
var ed = null;
var  style   = null;
try {
// Ham4HMLGen.g:2042:5: ( ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? ) )
// Ham4HMLGen.g:2043:5: ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? )
// Ham4HMLGen.g:2043:5: ( ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )? )
// Ham4HMLGen.g:2044:9: ( HamZigzag | HamWavy ) (sz= size )? (ed= ellipsedirection )? ( sizechangenonlinear[zze] )?
// Ham4HMLGen.g:2044:9: ( HamZigzag | HamWavy )
var alt154=2;
var LA154_0 = this.input.LA(1);
if ( (LA154_0==HamZigzag) ) {
alt154=1;
}
else if ( (LA154_0==HamWavy) ) {
alt154=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 154, 0, this.input);
throw nvae;
}
switch (alt154) {
case 1 :
// Ham4HMLGen.g:2045:19: HamZigzag
this.match(this.input,HamZigzag,Ham4HMLGen.FOLLOW_HamZigzag_in_zigzag15126); 
style = "ham_zigzag"; 
break;
case 2 :
// Ham4HMLGen.g:2047:19: HamWavy
this.match(this.input,HamWavy,Ham4HMLGen.FOLLOW_HamWavy_in_zigzag15162); 
style = "ham_wavy"; 
break;
}
// Ham4HMLGen.g:2049:9: (sz= size )?
var alt155=2;
var LA155_0 = this.input.LA(1);
if ( ((LA155_0>=HamSmallmod && LA155_0<=HamLargemod)) ) {
alt155=1;
}
switch (alt155) {
case 1 :
// Ham4HMLGen.g:2049:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_zigzag15199);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2050:9: (ed= ellipsedirection )?
var alt156=2;
var LA156_0 = this.input.LA(1);
if ( ((LA156_0>=HamEllipseh && LA156_0<=HamEllipseul)) ) {
alt156=1;
}
switch (alt156) {
case 1 :
// Ham4HMLGen.g:2050:11: ed= ellipsedirection
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_zigzag15221);
ed=this.ellipsedirection();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2051:9: ( sizechangenonlinear[zze] )?
var alt157=2;
var LA157_0 = this.input.LA(1);
if ( ((LA157_0>=HamIncreasing && LA157_0<=HamDecreasing)) ) {
alt157=1;
}
switch (alt157) {
case 1 :
// Ham4HMLGen.g:2051:19: sizechangenonlinear[zze]
this.pushFollow(Ham4HMLGen.FOLLOW_sizechangenonlinear_in_zigzag15244);
this.sizechangenonlinear(zze);
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(zze, "zigzagstyle", style);
hBuilder.checkedSetAttr(zze, "zigzag_size", sz);
hBuilder.checkedSetAttr(zze, "ellipsedirection", ed);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2060:1: sizechangenonlinear[sce] : (sc= sizechange (sz= size )? ) ;
// $ANTLR start "sizechangenonlinear"
sizechangenonlinear: function(sce) {
var sc = null;
var sz = null;
try {
// Ham4HMLGen.g:2064:5: ( (sc= sizechange (sz= size )? ) )
// Ham4HMLGen.g:2065:5: (sc= sizechange (sz= size )? )
// Ham4HMLGen.g:2065:5: (sc= sizechange (sz= size )? )
// Ham4HMLGen.g:2066:9: sc= sizechange (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_sizechangenonlinear15308);
sc=this.sizechange();
this.state._fsp--;
// Ham4HMLGen.g:2067:9: (sz= size )?
var alt158=2;
var LA158_0 = this.input.LA(1);
if ( ((LA158_0>=HamSmallmod && LA158_0<=HamLargemod)) ) {
alt158=1;
}
switch (alt158) {
case 1 :
// Ham4HMLGen.g:2067:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_sizechangenonlinear15327);
sz=this.size();
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(sce, "incrdecr", sc);
hBuilder.checkedSetAttr(sce, "incrdecr_size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2075:1: fullcircularmovement returns [Element rfcm = null] : (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? ) ;
// $ANTLR start "fullcircularmovement"
fullcircularmovement: function() {
var rfcm =  null;
var fcm = null;
var sz = null;
var el = null;
try {
// Ham4HMLGen.g:2079:5: ( (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? ) )
// Ham4HMLGen.g:2080:5: (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? )
// Ham4HMLGen.g:2080:5: (fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )? )
// Ham4HMLGen.g:2081:9: fcm= circularmovement (sz= size )? ( revolutions[rfcm] )? (el= ellipse )? ( sizechangenonlinear[rfcm] )?
this.pushFollow(Ham4HMLGen.FOLLOW_circularmovement_in_fullcircularmovement15390);
fcm=this.circularmovement();
this.state._fsp--;
rfcm = fcm; 
// Ham4HMLGen.g:2082:9: (sz= size )?
var alt159=2;
var LA159_0 = this.input.LA(1);
if ( ((LA159_0>=HamSmallmod && LA159_0<=HamLargemod)) ) {
alt159=1;
}
switch (alt159) {
case 1 :
// Ham4HMLGen.g:2082:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullcircularmovement15415);
sz=this.size();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2083:9: ( revolutions[rfcm] )?
var alt160=2;
var LA160_0 = this.input.LA(1);
if ( ((LA160_0>=HamClocku && LA160_0<=HamClockfull)) ) {
alt160=1;
}
switch (alt160) {
case 1 :
// Ham4HMLGen.g:2083:19: revolutions[rfcm]
this.pushFollow(Ham4HMLGen.FOLLOW_revolutions_in_fullcircularmovement15438);
this.revolutions(rfcm);
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2084:9: (el= ellipse )?
var alt161=2;
var LA161_0 = this.input.LA(1);
if ( ((LA161_0>=HamEllipseh && LA161_0<=HamEllipseul)) ) {
alt161=1;
}
switch (alt161) {
case 1 :
// Ham4HMLGen.g:2084:11: el= ellipse
this.pushFollow(Ham4HMLGen.FOLLOW_ellipse_in_fullcircularmovement15461);
el=this.ellipse();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2085:9: ( sizechangenonlinear[rfcm] )?
var alt162=2;
var LA162_0 = this.input.LA(1);
if ( ((LA162_0>=HamIncreasing && LA162_0<=HamDecreasing)) ) {
alt162=1;
}
switch (alt162) {
case 1 :
// Ham4HMLGen.g:2085:19: sizechangenonlinear[rfcm]
this.pushFollow(Ham4HMLGen.FOLLOW_sizechangenonlinear_in_fullcircularmovement15484);
this.sizechangenonlinear(rfcm);
this.state._fsp--;
break;
}
hBuilder.checkedAppendChild(rfcm, el);
hBuilder.checkedSetAttr(rfcm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfcm;
},
// Ham4HMLGen.g:2093:1: circularmovement returns [Element rcm = null] : ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? ) ;
// $ANTLR start "circularmovement"
circularmovement: function() {
var rcm =  null;
var mca = null;
var mcb = null;
try {
// Ham4HMLGen.g:2096:5: ( ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? ) )
// Ham4HMLGen.g:2097:5: ^( CRCLRMVMT mca= movementcircle (mcb= movementcircle )? )
this.match(this.input,CRCLRMVMT,Ham4HMLGen.FOLLOW_CRCLRMVMT_in_circularmovement15531); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_movementcircle_in_circularmovement15549);
mca=this.movementcircle();
this.state._fsp--;
// Ham4HMLGen.g:2099:9: (mcb= movementcircle )?
var alt163=2;
var LA163_0 = this.input.LA(1);
if ( ((LA163_0>=HamCircleo && LA163_0<=HamCircler)||(LA163_0>=HamCircleul && LA163_0<=HamCircleuo)) ) {
alt163=1;
}
switch (alt163) {
case 1 :
// Ham4HMLGen.g:2099:11: mcb= movementcircle
this.pushFollow(Ham4HMLGen.FOLLOW_movementcircle_in_circularmovement15567);
mcb=this.movementcircle();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rcm = hBuilder.newHMLElement("circularmovement");
hBuilder.checkedSetAttr(rcm, "movement", mca);
hBuilder.checkedSetAttr(rcm, "second_movement", mcb);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rcm;
},
// Ham4HMLGen.g:2108:1: ellipse returns [Element rell = null] : (ed= ellipsedirection (sz= size )? ) ;
// $ANTLR start "ellipse"
ellipse: function() {
var rell =  null;
var ed = null;
var sz = null;
try {
// Ham4HMLGen.g:2112:5: ( (ed= ellipsedirection (sz= size )? ) )
// Ham4HMLGen.g:2113:5: (ed= ellipsedirection (sz= size )? )
// Ham4HMLGen.g:2113:5: (ed= ellipsedirection (sz= size )? )
// Ham4HMLGen.g:2114:9: ed= ellipsedirection (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_ellipsedirection_in_ellipse15636);
ed=this.ellipsedirection();
this.state._fsp--;
// Ham4HMLGen.g:2115:9: (sz= size )?
var alt164=2;
var LA164_0 = this.input.LA(1);
if ( ((LA164_0>=HamSmallmod && LA164_0<=HamLargemod)) ) {
alt164=1;
}
switch (alt164) {
case 1 :
// Ham4HMLGen.g:2115:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_ellipse15655);
sz=this.size();
this.state._fsp--;
break;
}
rell = hBuilder.newHMLElement("ellipse");
hBuilder.checkedSetAttr(rell, "ellipsedirection", ed);
hBuilder.checkedSetAttr(rell, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rell;
},
// Ham4HMLGen.g:2124:1: revolutions[reve] : ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? ) ;
// $ANTLR start "revolutions"
revolutions: function(reve) {
var cs = null;
var ce = null;
var cfa = false;
var cfb = false;
try {
// Ham4HMLGen.g:2132:5: ( ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? ) )
// Ham4HMLGen.g:2133:5: ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? )
// Ham4HMLGen.g:2133:5: ( (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )? )
// Ham4HMLGen.g:2134:9: (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? ) (ce= clock )?
// Ham4HMLGen.g:2134:9: (cs= clock ( HamClockfull ( HamClockfull )? )? | HamClockfull ( HamClockfull )? )
var alt168=2;
var LA168_0 = this.input.LA(1);
if ( ((LA168_0>=HamClocku && LA168_0<=HamClockur)) ) {
alt168=1;
}
else if ( (LA168_0==HamClockfull) ) {
alt168=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 168, 0, this.input);
throw nvae;
}
switch (alt168) {
case 1 :
// Ham4HMLGen.g:2135:13: cs= clock ( HamClockfull ( HamClockfull )? )?
this.pushFollow(Ham4HMLGen.FOLLOW_clock_in_revolutions15736);
cs=this.clock();
this.state._fsp--;
// Ham4HMLGen.g:2136:13: ( HamClockfull ( HamClockfull )? )?
var alt166=2;
var LA166_0 = this.input.LA(1);
if ( (LA166_0==HamClockfull) ) {
alt166=1;
}
switch (alt166) {
case 1 :
// Ham4HMLGen.g:2137:17: HamClockfull ( HamClockfull )?
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15768); 
cfa = true; 
// Ham4HMLGen.g:2138:17: ( HamClockfull )?
var alt165=2;
var LA165_0 = this.input.LA(1);
if ( (LA165_0==HamClockfull) ) {
alt165=1;
}
switch (alt165) {
case 1 :
// Ham4HMLGen.g:2138:19: HamClockfull
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15797); 
cfb = true; 
break;
}
break;
}
break;
case 2 :
// Ham4HMLGen.g:2141:13: HamClockfull ( HamClockfull )?
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15846); 
cfa = true; 
// Ham4HMLGen.g:2142:13: ( HamClockfull )?
var alt167=2;
var LA167_0 = this.input.LA(1);
if ( (LA167_0==HamClockfull) ) {
alt167=1;
}
switch (alt167) {
case 1 :
// Ham4HMLGen.g:2142:15: HamClockfull
this.match(this.input,HamClockfull,Ham4HMLGen.FOLLOW_HamClockfull_in_revolutions15875); 
cfb = true; 
break;
}
break;
}
// Ham4HMLGen.g:2144:9: (ce= clock )?
var alt169=2;
var LA169_0 = this.input.LA(1);
if ( ((LA169_0>=HamClocku && LA169_0<=HamClockur)) ) {
alt169=1;
}
switch (alt169) {
case 1 :
// Ham4HMLGen.g:2144:13: ce= clock
this.pushFollow(Ham4HMLGen.FOLLOW_clock_in_revolutions15922);
ce=this.clock();
this.state._fsp--;
break;
}
hBuilder.checkedSetAttr(reve, "start", cs);
if (cfa) {
hBuilder.checkedSetAttr(reve, "clockfull", "true");
if (cfb) {
hBuilder.checkedSetAttr(reve, "second_clockfull", "true");
}
}
hBuilder.checkedSetAttr(reve, "end", ce);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ;
},
// Ham4HMLGen.g:2158:1: fullwristmovement returns [Element rfwm = null] : (wm= wristmovement (sz= size )? ) ;
// $ANTLR start "fullwristmovement"
fullwristmovement: function() {
var rfwm =  null;
var wm = null;
var sz = null;
try {
// Ham4HMLGen.g:2161:5: ( (wm= wristmovement (sz= size )? ) )
// Ham4HMLGen.g:2162:5: (wm= wristmovement (sz= size )? )
// Ham4HMLGen.g:2162:5: (wm= wristmovement (sz= size )? )
// Ham4HMLGen.g:2163:9: wm= wristmovement (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_wristmovement_in_fullwristmovement15985);
wm=this.wristmovement();
this.state._fsp--;
// Ham4HMLGen.g:2164:9: (sz= size )?
var alt170=2;
var LA170_0 = this.input.LA(1);
if ( ((LA170_0>=HamSmallmod && LA170_0<=HamLargemod)) ) {
alt170=1;
}
switch (alt170) {
case 1 :
// Ham4HMLGen.g:2164:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullwristmovement16004);
sz=this.size();
this.state._fsp--;
break;
}
rfwm = hBuilder.newHMLElement("wristmovement");
hBuilder.checkedSetAttr(rfwm, "movement", wm);
hBuilder.checkedSetAttr(rfwm, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfwm;
},
// Ham4HMLGen.g:2173:1: fullmovementcross returns [Element rfmc = null] : (smc= movementcross (sz= size )? ) ;
// $ANTLR start "fullmovementcross"
fullmovementcross: function() {
var rfmc =  null;
var smc = null;
var sz = null;
try {
// Ham4HMLGen.g:2177:5: ( (smc= movementcross (sz= size )? ) )
// Ham4HMLGen.g:2178:5: (smc= movementcross (sz= size )? )
// Ham4HMLGen.g:2178:5: (smc= movementcross (sz= size )? )
// Ham4HMLGen.g:2179:9: smc= movementcross (sz= size )?
this.pushFollow(Ham4HMLGen.FOLLOW_movementcross_in_fullmovementcross16067);
smc=this.movementcross();
this.state._fsp--;
// Ham4HMLGen.g:2180:9: (sz= size )?
var alt171=2;
var LA171_0 = this.input.LA(1);
if ( ((LA171_0>=HamSmallmod && LA171_0<=HamLargemod)) ) {
alt171=1;
}
switch (alt171) {
case 1 :
// Ham4HMLGen.g:2180:11: sz= size
this.pushFollow(Ham4HMLGen.FOLLOW_size_in_fullmovementcross16086);
sz=this.size();
this.state._fsp--;
break;
}
rfmc = hBuilder.newHMLElement("movementcross");
hBuilder.checkedSetAttr(rfmc, "movementcross", smc);
hBuilder.checkedSetAttr(rfmc, "size", sz);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rfmc;
},
// Ham4HMLGen.g:2190:1: replacement returns [Element rr = null] : ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? ) ;
// $ANTLR start "replacement"
replacement: function() {
var rr =  null;
var sc = null;
var hs = null;
var srt = null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:2193:5: ( ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? ) )
// Ham4HMLGen.g:2194:5: ^( REPLACE (sc= sizechange )? (hs= handshape1 )? (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )? )
this.match(this.input,REPLACE,Ham4HMLGen.FOLLOW_REPLACE_in_replacement16138); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:2195:9: (sc= sizechange )?
var alt172=2;
var LA172_0 = this.input.LA(1);
if ( ((LA172_0>=HamIncreasing && LA172_0<=HamDecreasing)) ) {
alt172=1;
}
switch (alt172) {
case 1 :
// Ham4HMLGen.g:2195:11: sc= sizechange
this.pushFollow(Ham4HMLGen.FOLLOW_sizechange_in_replacement16157);
sc=this.sizechange();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2196:9: (hs= handshape1 )?
var alt173=2;
var LA173_0 = this.input.LA(1);
if ( (LA173_0==HSHAPE1) ) {
alt173=1;
}
switch (alt173) {
case 1 :
// Ham4HMLGen.g:2196:11: hs= handshape1
this.pushFollow(Ham4HMLGen.FOLLOW_handshape1_in_replacement16179);
hs=this.handshape1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2197:9: (srt= splitreplacetail | efd= extfidir1 (po= palmor1 )? | po= palmor1 )?
var alt175=4;
switch ( this.input.LA(1) ) {
case SPLITREPLACETL:
alt175=1;
break;
case EXTFIDIR1:
alt175=2;
break;
case PALMOR1:
alt175=3;
break;
}
switch (alt175) {
case 1 :
// Ham4HMLGen.g:2198:13: srt= splitreplacetail
this.pushFollow(Ham4HMLGen.FOLLOW_splitreplacetail_in_replacement16214);
srt=this.splitreplacetail();
this.state._fsp--;
break;
case 2 :
// Ham4HMLGen.g:2200:13: efd= extfidir1 (po= palmor1 )?
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_replacement16246);
efd=this.extfidir1();
this.state._fsp--;
// Ham4HMLGen.g:2201:13: (po= palmor1 )?
var alt174=2;
var LA174_0 = this.input.LA(1);
if ( (LA174_0==PALMOR1) ) {
alt174=1;
}
switch (alt174) {
case 1 :
// Ham4HMLGen.g:2201:15: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacement16269);
po=this.palmor1();
this.state._fsp--;
break;
}
break;
case 3 :
// Ham4HMLGen.g:2203:13: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacement16305);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rr = hBuilder.newHMLElement("replacement");
hBuilder.checkedSetAttr(rr, "replace_incrdecr", sc);
hBuilder.checkedAppendChild(rr, hs);
if (srt == null) {
hBuilder.checkedAppendChild(rr, efd);
hBuilder.checkedAppendChild(rr, po);
}
else {
rr.appendChild(srt);
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rr;
},
// Ham4HMLGen.g:2220:1: splitreplacetail returns [Element rsrt = null] : ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? ) ;
// $ANTLR start "splitreplacetail"
splitreplacetail: function() {
var rsrt =  null;
var drt = null;
var srt = null;
try {
// Ham4HMLGen.g:2223:5: ( ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? ) )
// Ham4HMLGen.g:2224:5: ^( SPLITREPLACETL drt= replacetail1 (srt= replacetail1 )? )
this.match(this.input,SPLITREPLACETL,Ham4HMLGen.FOLLOW_SPLITREPLACETL_in_splitreplacetail16359); 
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
this.pushFollow(Ham4HMLGen.FOLLOW_replacetail1_in_splitreplacetail16377);
drt=this.replacetail1();
this.state._fsp--;
// Ham4HMLGen.g:2226:9: (srt= replacetail1 )?
var alt176=2;
var LA176_0 = this.input.LA(1);
if ( (LA176_0==REPLACETAIL1) ) {
alt176=1;
}
switch (alt176) {
case 1 :
// Ham4HMLGen.g:2226:11: srt= replacetail1
this.pushFollow(Ham4HMLGen.FOLLOW_replacetail1_in_splitreplacetail16395);
srt=this.replacetail1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
rsrt = hBuilder.newHMLElement("splitreplacetail");
hBuilder.checkedAppendChild(rsrt, drt);
hBuilder.checkedAppendChild(rsrt, srt);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsrt;
},
// Ham4HMLGen.g:2235:1: replacetail1 returns [Element rrt = null] : ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) ) ;
// $ANTLR start "replacetail1"
replacetail1: function() {
var rrt =  null;
var efd = null;
var po = null;
try {
// Ham4HMLGen.g:2238:5: ( ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) ) )
// Ham4HMLGen.g:2239:5: ^( REPLACETAIL1 ( (efd= extfidir1 )? (po= palmor1 )? ) )
this.match(this.input,REPLACETAIL1,Ham4HMLGen.FOLLOW_REPLACETAIL1_in_replacetail116445); 
if ( this.input.LA(1)==org.antlr.runtime.Token.DOWN ) {
this.match(this.input, org.antlr.runtime.Token.DOWN, null); 
// Ham4HMLGen.g:2240:9: ( (efd= extfidir1 )? (po= palmor1 )? )
// Ham4HMLGen.g:2241:13: (efd= extfidir1 )? (po= palmor1 )?
// Ham4HMLGen.g:2241:13: (efd= extfidir1 )?
var alt177=2;
var LA177_0 = this.input.LA(1);
if ( (LA177_0==EXTFIDIR1) ) {
alt177=1;
}
switch (alt177) {
case 1 :
// Ham4HMLGen.g:2241:15: efd= extfidir1
this.pushFollow(Ham4HMLGen.FOLLOW_extfidir1_in_replacetail116477);
efd=this.extfidir1();
this.state._fsp--;
break;
}
// Ham4HMLGen.g:2242:13: (po= palmor1 )?
var alt178=2;
var LA178_0 = this.input.LA(1);
if ( (LA178_0==PALMOR1) ) {
alt178=1;
}
switch (alt178) {
case 1 :
// Ham4HMLGen.g:2242:15: po= palmor1
this.pushFollow(Ham4HMLGen.FOLLOW_palmor1_in_replacetail116503);
po=this.palmor1();
this.state._fsp--;
break;
}
this.match(this.input, org.antlr.runtime.Token.UP, null); 
}
rrt = hBuilder.newHMLElement("replacetail1");
hBuilder.checkedAppendChild(rrt, efd);
hBuilder.checkedAppendChild(rrt, po);
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rrt;
},
// Ham4HMLGen.g:2255:1: repetition returns [String rr = null] : ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse ) ;
// $ANTLR start "repetition"
repetition: function() {
var rr =  null;
try {
// Ham4HMLGen.g:2257:5: ( ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse ) )
// Ham4HMLGen.g:2258:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
// Ham4HMLGen.g:2258:5: ( HamRepeatfromstart | HamRepeatfromstartseveral | HamRepeatcontinue | HamRepeatcontinueseveral | HamRepeatreverse )
var alt179=5;
switch ( this.input.LA(1) ) {
case HamRepeatfromstart:
alt179=1;
break;
case HamRepeatfromstartseveral:
alt179=2;
break;
case HamRepeatcontinue:
alt179=3;
break;
case HamRepeatcontinueseveral:
alt179=4;
break;
case HamRepeatreverse:
alt179=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 179, 0, this.input);
throw nvae;
}
switch (alt179) {
case 1 :
// Ham4HMLGen.g:2258:9: HamRepeatfromstart
this.match(this.input,HamRepeatfromstart,Ham4HMLGen.FOLLOW_HamRepeatfromstart_in_repetition16567); 
rr = "ham_repeat_fromstart"; 
break;
case 2 :
// Ham4HMLGen.g:2259:9: HamRepeatfromstartseveral
this.match(this.input,HamRepeatfromstartseveral,Ham4HMLGen.FOLLOW_HamRepeatfromstartseveral_in_repetition16580); 
rr = "ham_repeat_fromstartseveral"; 
break;
case 3 :
// Ham4HMLGen.g:2261:9: HamRepeatcontinue
this.match(this.input,HamRepeatcontinue,Ham4HMLGen.FOLLOW_HamRepeatcontinue_in_repetition16620); 
rr = "ham_repeat_continue"; 
break;
case 4 :
// Ham4HMLGen.g:2262:9: HamRepeatcontinueseveral
this.match(this.input,HamRepeatcontinueseveral,Ham4HMLGen.FOLLOW_HamRepeatcontinueseveral_in_repetition16634); 
rr = "ham_repeat_continueseveral"; 
break;
case 5 :
// Ham4HMLGen.g:2264:9: HamRepeatreverse
this.match(this.input,HamRepeatreverse,Ham4HMLGen.FOLLOW_HamRepeatreverse_in_repetition16674); 
rr = "ham_repeat_reverse"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rr;
},
// Ham4HMLGen.g:2268:1: movementarrow returns [String rma = null] : ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo ) ;
// $ANTLR start "movementarrow"
movementarrow: function() {
var rma =  null;
try {
// Ham4HMLGen.g:2270:5: ( ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo ) )
// Ham4HMLGen.g:2271:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
// Ham4HMLGen.g:2271:5: ( HamMoveu | HamMoveur | HamMover | HamMovedr | HamMoved | HamMovedl | HamMovel | HamMoveul | HamMoveol | HamMoveo | HamMoveor | HamMoveil | HamMovei | HamMoveir | HamMoveui | HamMovedi | HamMovedo | HamMoveuo )
var alt180=18;
switch ( this.input.LA(1) ) {
case HamMoveu:
alt180=1;
break;
case HamMoveur:
alt180=2;
break;
case HamMover:
alt180=3;
break;
case HamMovedr:
alt180=4;
break;
case HamMoved:
alt180=5;
break;
case HamMovedl:
alt180=6;
break;
case HamMovel:
alt180=7;
break;
case HamMoveul:
alt180=8;
break;
case HamMoveol:
alt180=9;
break;
case HamMoveo:
alt180=10;
break;
case HamMoveor:
alt180=11;
break;
case HamMoveil:
alt180=12;
break;
case HamMovei:
alt180=13;
break;
case HamMoveir:
alt180=14;
break;
case HamMoveui:
alt180=15;
break;
case HamMovedi:
alt180=16;
break;
case HamMovedo:
alt180=17;
break;
case HamMoveuo:
alt180=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 180, 0, this.input);
throw nvae;
}
switch (alt180) {
case 1 :
// Ham4HMLGen.g:2271:9: HamMoveu
this.match(this.input,HamMoveu,Ham4HMLGen.FOLLOW_HamMoveu_in_movementarrow16718); 
rma = "u"; 
break;
case 2 :
// Ham4HMLGen.g:2272:9: HamMoveur
this.match(this.input,HamMoveur,Ham4HMLGen.FOLLOW_HamMoveur_in_movementarrow16741); 
rma = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:2273:9: HamMover
this.match(this.input,HamMover,Ham4HMLGen.FOLLOW_HamMover_in_movementarrow16763); 
rma = "r"; 
break;
case 4 :
// Ham4HMLGen.g:2274:9: HamMovedr
this.match(this.input,HamMovedr,Ham4HMLGen.FOLLOW_HamMovedr_in_movementarrow16786); 
rma = "dr"; 
break;
case 5 :
// Ham4HMLGen.g:2275:9: HamMoved
this.match(this.input,HamMoved,Ham4HMLGen.FOLLOW_HamMoved_in_movementarrow16808); 
rma = "d"; 
break;
case 6 :
// Ham4HMLGen.g:2276:9: HamMovedl
this.match(this.input,HamMovedl,Ham4HMLGen.FOLLOW_HamMovedl_in_movementarrow16831); 
rma = "dl"; 
break;
case 7 :
// Ham4HMLGen.g:2277:9: HamMovel
this.match(this.input,HamMovel,Ham4HMLGen.FOLLOW_HamMovel_in_movementarrow16853); 
rma = "l"; 
break;
case 8 :
// Ham4HMLGen.g:2278:9: HamMoveul
this.match(this.input,HamMoveul,Ham4HMLGen.FOLLOW_HamMoveul_in_movementarrow16876); 
rma = "ul"; 
break;
case 9 :
// Ham4HMLGen.g:2279:9: HamMoveol
this.match(this.input,HamMoveol,Ham4HMLGen.FOLLOW_HamMoveol_in_movementarrow16898); 
rma = "ol"; 
break;
case 10 :
// Ham4HMLGen.g:2280:9: HamMoveo
this.match(this.input,HamMoveo,Ham4HMLGen.FOLLOW_HamMoveo_in_movementarrow16920); 
rma = "o"; 
break;
case 11 :
// Ham4HMLGen.g:2281:9: HamMoveor
this.match(this.input,HamMoveor,Ham4HMLGen.FOLLOW_HamMoveor_in_movementarrow16943); 
rma = "or"; 
break;
case 12 :
// Ham4HMLGen.g:2282:9: HamMoveil
this.match(this.input,HamMoveil,Ham4HMLGen.FOLLOW_HamMoveil_in_movementarrow16965); 
rma = "il"; 
break;
case 13 :
// Ham4HMLGen.g:2283:9: HamMovei
this.match(this.input,HamMovei,Ham4HMLGen.FOLLOW_HamMovei_in_movementarrow16987); 
rma = "i"; 
break;
case 14 :
// Ham4HMLGen.g:2284:9: HamMoveir
this.match(this.input,HamMoveir,Ham4HMLGen.FOLLOW_HamMoveir_in_movementarrow17010); 
rma = "ir"; 
break;
case 15 :
// Ham4HMLGen.g:2285:9: HamMoveui
this.match(this.input,HamMoveui,Ham4HMLGen.FOLLOW_HamMoveui_in_movementarrow17032); 
rma = "ui"; 
break;
case 16 :
// Ham4HMLGen.g:2286:9: HamMovedi
this.match(this.input,HamMovedi,Ham4HMLGen.FOLLOW_HamMovedi_in_movementarrow17054); 
rma = "di"; 
break;
case 17 :
// Ham4HMLGen.g:2287:9: HamMovedo
this.match(this.input,HamMovedo,Ham4HMLGen.FOLLOW_HamMovedo_in_movementarrow17076); 
rma = "do"; 
break;
case 18 :
// Ham4HMLGen.g:2288:9: HamMoveuo
this.match(this.input,HamMoveuo,Ham4HMLGen.FOLLOW_HamMoveuo_in_movementarrow17098); 
rma = "uo"; 
break;
}
rma = "ham_move_" + rma;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rma;
},
// Ham4HMLGen.g:2295:1: movementcross returns [String rmc = null] : ( HamMovecross | HamMovex ) ;
// $ANTLR start "movementcross"
movementcross: function() {
var rmc =  null;
try {
// Ham4HMLGen.g:2297:5: ( ( HamMovecross | HamMovex ) )
// Ham4HMLGen.g:2298:5: ( HamMovecross | HamMovex )
// Ham4HMLGen.g:2298:5: ( HamMovecross | HamMovex )
var alt181=2;
var LA181_0 = this.input.LA(1);
if ( (LA181_0==HamMovecross) ) {
alt181=1;
}
else if ( (LA181_0==HamMovex) ) {
alt181=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 181, 0, this.input);
throw nvae;
}
switch (alt181) {
case 1 :
// Ham4HMLGen.g:2298:9: HamMovecross
this.match(this.input,HamMovecross,Ham4HMLGen.FOLLOW_HamMovecross_in_movementcross17155); 
rmc = "ham_move_cross"; 
break;
case 2 :
// Ham4HMLGen.g:2299:9: HamMovex
this.match(this.input,HamMovex,Ham4HMLGen.FOLLOW_HamMovex_in_movementcross17174); 
rmc = "ham_move_x"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmc;
},
// Ham4HMLGen.g:2303:1: wristmovement returns [String rwm = null] : ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw ) ;
// $ANTLR start "wristmovement"
wristmovement: function() {
var rwm =  null;
try {
// Ham4HMLGen.g:2305:5: ( ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw ) )
// Ham4HMLGen.g:2306:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
// Ham4HMLGen.g:2306:5: ( HamNodding | HamSwinging | HamTwisting | HamStircw | HamStirccw )
var alt182=5;
switch ( this.input.LA(1) ) {
case HamNodding:
alt182=1;
break;
case HamSwinging:
alt182=2;
break;
case HamTwisting:
alt182=3;
break;
case HamStircw:
alt182=4;
break;
case HamStirccw:
alt182=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 182, 0, this.input);
throw nvae;
}
switch (alt182) {
case 1 :
// Ham4HMLGen.g:2306:9: HamNodding
this.match(this.input,HamNodding,Ham4HMLGen.FOLLOW_HamNodding_in_wristmovement17226); 
rwm = "ham_wrist_nodding"; 
break;
case 2 :
// Ham4HMLGen.g:2307:9: HamSwinging
this.match(this.input,HamSwinging,Ham4HMLGen.FOLLOW_HamSwinging_in_wristmovement17247); 
rwm = "ham_wrist_swinging"; 
break;
case 3 :
// Ham4HMLGen.g:2308:9: HamTwisting
this.match(this.input,HamTwisting,Ham4HMLGen.FOLLOW_HamTwisting_in_wristmovement17267); 
rwm = "ham_wrist_twisting"; 
break;
case 4 :
// Ham4HMLGen.g:2309:9: HamStircw
this.match(this.input,HamStircw,Ham4HMLGen.FOLLOW_HamStircw_in_wristmovement17287); 
rwm = "ham_wrist_stircw"; 
break;
case 5 :
// Ham4HMLGen.g:2310:9: HamStirccw
this.match(this.input,HamStirccw,Ham4HMLGen.FOLLOW_HamStirccw_in_wristmovement17309); 
rwm = "ham_wrist_stirccw"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rwm;
},
// Ham4HMLGen.g:2314:1: movementcircle returns [String rmc = null] : ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo ) ;
// $ANTLR start "movementcircle"
movementcircle: function() {
var rmc =  null;
try {
// Ham4HMLGen.g:2318:5: ( ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo ) )
// Ham4HMLGen.g:2319:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
// Ham4HMLGen.g:2319:5: ( HamCircleo | HamCirclei | HamCircled | HamCircleu | HamCirclel | HamCircler | HamCircleul | HamCircledr | HamCircleur | HamCircledl | HamCircleol | HamCircleir | HamCircleor | HamCircleil | HamCircleui | HamCircledo | HamCircledi | HamCircleuo )
var alt183=18;
switch ( this.input.LA(1) ) {
case HamCircleo:
alt183=1;
break;
case HamCirclei:
alt183=2;
break;
case HamCircled:
alt183=3;
break;
case HamCircleu:
alt183=4;
break;
case HamCirclel:
alt183=5;
break;
case HamCircler:
alt183=6;
break;
case HamCircleul:
alt183=7;
break;
case HamCircledr:
alt183=8;
break;
case HamCircleur:
alt183=9;
break;
case HamCircledl:
alt183=10;
break;
case HamCircleol:
alt183=11;
break;
case HamCircleir:
alt183=12;
break;
case HamCircleor:
alt183=13;
break;
case HamCircleil:
alt183=14;
break;
case HamCircleui:
alt183=15;
break;
case HamCircledo:
alt183=16;
break;
case HamCircledi:
alt183=17;
break;
case HamCircleuo:
alt183=18;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 183, 0, this.input);
throw nvae;
}
switch (alt183) {
case 1 :
// Ham4HMLGen.g:2319:9: HamCircleo
this.match(this.input,HamCircleo,Ham4HMLGen.FOLLOW_HamCircleo_in_movementcircle17358); 
rmc = "o"; 
break;
case 2 :
// Ham4HMLGen.g:2320:9: HamCirclei
this.match(this.input,HamCirclei,Ham4HMLGen.FOLLOW_HamCirclei_in_movementcircle17379); 
rmc = "i"; 
break;
case 3 :
// Ham4HMLGen.g:2321:9: HamCircled
this.match(this.input,HamCircled,Ham4HMLGen.FOLLOW_HamCircled_in_movementcircle17400); 
rmc = "d"; 
break;
case 4 :
// Ham4HMLGen.g:2322:9: HamCircleu
this.match(this.input,HamCircleu,Ham4HMLGen.FOLLOW_HamCircleu_in_movementcircle17421); 
rmc = "u"; 
break;
case 5 :
// Ham4HMLGen.g:2323:9: HamCirclel
this.match(this.input,HamCirclel,Ham4HMLGen.FOLLOW_HamCirclel_in_movementcircle17442); 
rmc = "l"; 
break;
case 6 :
// Ham4HMLGen.g:2324:9: HamCircler
this.match(this.input,HamCircler,Ham4HMLGen.FOLLOW_HamCircler_in_movementcircle17463); 
rmc = "r"; 
break;
case 7 :
// Ham4HMLGen.g:2325:9: HamCircleul
this.match(this.input,HamCircleul,Ham4HMLGen.FOLLOW_HamCircleul_in_movementcircle17484); 
rmc = "ul"; 
break;
case 8 :
// Ham4HMLGen.g:2326:9: HamCircledr
this.match(this.input,HamCircledr,Ham4HMLGen.FOLLOW_HamCircledr_in_movementcircle17504); 
rmc = "dr"; 
break;
case 9 :
// Ham4HMLGen.g:2327:9: HamCircleur
this.match(this.input,HamCircleur,Ham4HMLGen.FOLLOW_HamCircleur_in_movementcircle17524); 
rmc = "ur"; 
break;
case 10 :
// Ham4HMLGen.g:2328:9: HamCircledl
this.match(this.input,HamCircledl,Ham4HMLGen.FOLLOW_HamCircledl_in_movementcircle17544); 
rmc = "dl"; 
break;
case 11 :
// Ham4HMLGen.g:2329:9: HamCircleol
this.match(this.input,HamCircleol,Ham4HMLGen.FOLLOW_HamCircleol_in_movementcircle17564); 
rmc = "ol"; 
break;
case 12 :
// Ham4HMLGen.g:2330:9: HamCircleir
this.match(this.input,HamCircleir,Ham4HMLGen.FOLLOW_HamCircleir_in_movementcircle17584); 
rmc = "ir"; 
break;
case 13 :
// Ham4HMLGen.g:2331:9: HamCircleor
this.match(this.input,HamCircleor,Ham4HMLGen.FOLLOW_HamCircleor_in_movementcircle17604); 
rmc = "or"; 
break;
case 14 :
// Ham4HMLGen.g:2332:9: HamCircleil
this.match(this.input,HamCircleil,Ham4HMLGen.FOLLOW_HamCircleil_in_movementcircle17624); 
rmc = "il"; 
break;
case 15 :
// Ham4HMLGen.g:2333:9: HamCircleui
this.match(this.input,HamCircleui,Ham4HMLGen.FOLLOW_HamCircleui_in_movementcircle17644); 
rmc = "ui"; 
break;
case 16 :
// Ham4HMLGen.g:2334:9: HamCircledo
this.match(this.input,HamCircledo,Ham4HMLGen.FOLLOW_HamCircledo_in_movementcircle17664); 
rmc = "do"; 
break;
case 17 :
// Ham4HMLGen.g:2335:9: HamCircledi
this.match(this.input,HamCircledi,Ham4HMLGen.FOLLOW_HamCircledi_in_movementcircle17684); 
rmc = "di"; 
break;
case 18 :
// Ham4HMLGen.g:2336:9: HamCircleuo
this.match(this.input,HamCircleuo,Ham4HMLGen.FOLLOW_HamCircleuo_in_movementcircle17704); 
rmc = "uo"; 
break;
}
rmc = "ham_circle_" + rmc;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmc;
},
// Ham4HMLGen.g:2343:1: ellipsedirection returns [String red = null] : ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul ) ;
// $ANTLR start "ellipsedirection"
ellipsedirection: function() {
var red =  null;
try {
// Ham4HMLGen.g:2347:5: ( ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul ) )
// Ham4HMLGen.g:2348:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
// Ham4HMLGen.g:2348:5: ( HamEllipseh | HamEllipseur | HamEllipsev | HamEllipseul )
var alt184=4;
switch ( this.input.LA(1) ) {
case HamEllipseh:
alt184=1;
break;
case HamEllipseur:
alt184=2;
break;
case HamEllipsev:
alt184=3;
break;
case HamEllipseul:
alt184=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 184, 0, this.input);
throw nvae;
}
switch (alt184) {
case 1 :
// Ham4HMLGen.g:2348:9: HamEllipseh
this.match(this.input,HamEllipseh,Ham4HMLGen.FOLLOW_HamEllipseh_in_ellipsedirection17760); 
red = "h"; 
break;
case 2 :
// Ham4HMLGen.g:2349:9: HamEllipseur
this.match(this.input,HamEllipseur,Ham4HMLGen.FOLLOW_HamEllipseur_in_ellipsedirection17780); 
red = "ur"; 
break;
case 3 :
// Ham4HMLGen.g:2350:9: HamEllipsev
this.match(this.input,HamEllipsev,Ham4HMLGen.FOLLOW_HamEllipsev_in_ellipsedirection17799); 
red = "v"; 
break;
case 4 :
// Ham4HMLGen.g:2351:9: HamEllipseul
this.match(this.input,HamEllipseul,Ham4HMLGen.FOLLOW_HamEllipseul_in_ellipsedirection17819); 
red = "ul"; 
break;
}
red = "ham_ellipse_" + red;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return red;
},
// Ham4HMLGen.g:2358:1: clock returns [String rclk = null] : ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur ) ;
// $ANTLR start "clock"
clock: function() {
var rclk =  null;
try {
// Ham4HMLGen.g:2362:5: ( ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur ) )
// Ham4HMLGen.g:2363:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
// Ham4HMLGen.g:2363:5: ( HamClocku | HamClockul | HamClockl | HamClockdl | HamClockd | HamClockdr | HamClockr | HamClockur )
var alt185=8;
switch ( this.input.LA(1) ) {
case HamClocku:
alt185=1;
break;
case HamClockul:
alt185=2;
break;
case HamClockl:
alt185=3;
break;
case HamClockdl:
alt185=4;
break;
case HamClockd:
alt185=5;
break;
case HamClockdr:
alt185=6;
break;
case HamClockr:
alt185=7;
break;
case HamClockur:
alt185=8;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 185, 0, this.input);
throw nvae;
}
switch (alt185) {
case 1 :
// Ham4HMLGen.g:2363:9: HamClocku
this.match(this.input,HamClocku,Ham4HMLGen.FOLLOW_HamClocku_in_clock17881); 
rclk = "u"; 
break;
case 2 :
// Ham4HMLGen.g:2364:9: HamClockul
this.match(this.input,HamClockul,Ham4HMLGen.FOLLOW_HamClockul_in_clock17903); 
rclk = "ul"; 
break;
case 3 :
// Ham4HMLGen.g:2365:9: HamClockl
this.match(this.input,HamClockl,Ham4HMLGen.FOLLOW_HamClockl_in_clock17924); 
rclk = "l"; 
break;
case 4 :
// Ham4HMLGen.g:2366:9: HamClockdl
this.match(this.input,HamClockdl,Ham4HMLGen.FOLLOW_HamClockdl_in_clock17946); 
rclk = "dl"; 
break;
case 5 :
// Ham4HMLGen.g:2367:9: HamClockd
this.match(this.input,HamClockd,Ham4HMLGen.FOLLOW_HamClockd_in_clock17967); 
rclk = "d"; 
break;
case 6 :
// Ham4HMLGen.g:2368:9: HamClockdr
this.match(this.input,HamClockdr,Ham4HMLGen.FOLLOW_HamClockdr_in_clock17989); 
rclk = "dr"; 
break;
case 7 :
// Ham4HMLGen.g:2369:9: HamClockr
this.match(this.input,HamClockr,Ham4HMLGen.FOLLOW_HamClockr_in_clock18010); 
rclk = "r"; 
break;
case 8 :
// Ham4HMLGen.g:2370:9: HamClockur
this.match(this.input,HamClockur,Ham4HMLGen.FOLLOW_HamClockur_in_clock18032); 
rclk = "ur"; 
break;
}
rclk = "ham_clock_" + rclk;
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rclk;
},
// Ham4HMLGen.g:2377:1: modifier returns [String rmod = null] : ( HamFast | HamSlow | HamTense | HamRest | HamHalt ) ;
// $ANTLR start "modifier"
modifier: function() {
var rmod =  null;
try {
// Ham4HMLGen.g:2379:5: ( ( HamFast | HamSlow | HamTense | HamRest | HamHalt ) )
// Ham4HMLGen.g:2380:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
// Ham4HMLGen.g:2380:5: ( HamFast | HamSlow | HamTense | HamRest | HamHalt )
var alt186=5;
switch ( this.input.LA(1) ) {
case HamFast:
alt186=1;
break;
case HamSlow:
alt186=2;
break;
case HamTense:
alt186=3;
break;
case HamRest:
alt186=4;
break;
case HamHalt:
alt186=5;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 186, 0, this.input);
throw nvae;
}
switch (alt186) {
case 1 :
// Ham4HMLGen.g:2380:9: HamFast
this.match(this.input,HamFast,Ham4HMLGen.FOLLOW_HamFast_in_modifier18093); 
rmod = "ham_fast"; 
break;
case 2 :
// Ham4HMLGen.g:2381:9: HamSlow
this.match(this.input,HamSlow,Ham4HMLGen.FOLLOW_HamSlow_in_modifier18117); 
rmod = "ham_slow"; 
break;
case 3 :
// Ham4HMLGen.g:2382:9: HamTense
this.match(this.input,HamTense,Ham4HMLGen.FOLLOW_HamTense_in_modifier18141); 
rmod = "ham_tense"; 
break;
case 4 :
// Ham4HMLGen.g:2383:9: HamRest
this.match(this.input,HamRest,Ham4HMLGen.FOLLOW_HamRest_in_modifier18164); 
rmod = "ham_rest"; 
break;
case 5 :
// Ham4HMLGen.g:2384:9: HamHalt
this.match(this.input,HamHalt,Ham4HMLGen.FOLLOW_HamHalt_in_modifier18188); 
rmod = "ham_halt"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rmod;
},
// Ham4HMLGen.g:2388:1: arc returns [String ra = null] : ( HamArcl | HamArcu | HamArcr | HamArcd ) ;
// $ANTLR start "arc"
arc: function() {
var ra =  null;
try {
// Ham4HMLGen.g:2390:5: ( ( HamArcl | HamArcu | HamArcr | HamArcd ) )
// Ham4HMLGen.g:2391:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
// Ham4HMLGen.g:2391:5: ( HamArcl | HamArcu | HamArcr | HamArcd )
var alt187=4;
switch ( this.input.LA(1) ) {
case HamArcl:
alt187=1;
break;
case HamArcu:
alt187=2;
break;
case HamArcr:
alt187=3;
break;
case HamArcd:
alt187=4;
break;
default:
var nvae =
new org.antlr.runtime.NoViableAltException("", 187, 0, this.input);
throw nvae;
}
switch (alt187) {
case 1 :
// Ham4HMLGen.g:2391:9: HamArcl
this.match(this.input,HamArcl,Ham4HMLGen.FOLLOW_HamArcl_in_arc18251); 
ra = "ham_arc_l"; 
break;
case 2 :
// Ham4HMLGen.g:2392:9: HamArcu
this.match(this.input,HamArcu,Ham4HMLGen.FOLLOW_HamArcu_in_arc18275); 
ra = "ham_arc_u"; 
break;
case 3 :
// Ham4HMLGen.g:2393:9: HamArcr
this.match(this.input,HamArcr,Ham4HMLGen.FOLLOW_HamArcr_in_arc18299); 
ra = "ham_arc_r"; 
break;
case 4 :
// Ham4HMLGen.g:2394:9: HamArcd
this.match(this.input,HamArcd,Ham4HMLGen.FOLLOW_HamArcd_in_arc18323); 
ra = "ham_arc_d"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return ra;
},
// Ham4HMLGen.g:2398:1: size returns [String rsz = null] : ( HamSmallmod | HamLargemod ) ;
// $ANTLR start "size"
size: function() {
var rsz =  null;
try {
// Ham4HMLGen.g:2402:5: ( ( HamSmallmod | HamLargemod ) )
// Ham4HMLGen.g:2403:5: ( HamSmallmod | HamLargemod )
// Ham4HMLGen.g:2403:5: ( HamSmallmod | HamLargemod )
var alt188=2;
var LA188_0 = this.input.LA(1);
if ( (LA188_0==HamSmallmod) ) {
alt188=1;
}
else if ( (LA188_0==HamLargemod) ) {
alt188=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 188, 0, this.input);
throw nvae;
}
switch (alt188) {
case 1 :
// Ham4HMLGen.g:2403:9: HamSmallmod
this.match(this.input,HamSmallmod,Ham4HMLGen.FOLLOW_HamSmallmod_in_size18385); 
rsz = "small"; 
break;
case 2 :
// Ham4HMLGen.g:2404:9: HamLargemod
this.match(this.input,HamLargemod,Ham4HMLGen.FOLLOW_HamLargemod_in_size18405); 
rsz = "large"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsz;
},
// Ham4HMLGen.g:2408:1: sizechange returns [String rsc = null] : ( HamIncreasing | HamDecreasing ) ;
// $ANTLR start "sizechange"
sizechange: function() {
var rsc =  null;
try {
// Ham4HMLGen.g:2410:5: ( ( HamIncreasing | HamDecreasing ) )
// Ham4HMLGen.g:2411:5: ( HamIncreasing | HamDecreasing )
// Ham4HMLGen.g:2411:5: ( HamIncreasing | HamDecreasing )
var alt189=2;
var LA189_0 = this.input.LA(1);
if ( (LA189_0==HamIncreasing) ) {
alt189=1;
}
else if ( (LA189_0==HamDecreasing) ) {
alt189=2;
}
else {
var nvae =
new org.antlr.runtime.NoViableAltException("", 189, 0, this.input);
throw nvae;
}
switch (alt189) {
case 1 :
// Ham4HMLGen.g:2411:9: HamIncreasing
this.match(this.input,HamIncreasing,Ham4HMLGen.FOLLOW_HamIncreasing_in_sizechange18457); 
rsc = "ham_increasing"; 
break;
case 2 :
// Ham4HMLGen.g:2412:9: HamDecreasing
this.match(this.input,HamDecreasing,Ham4HMLGen.FOLLOW_HamDecreasing_in_sizechange18475); 
rsc = "ham_decreasing"; 
break;
}
}
catch (re) {
if (re instanceof org.antlr.runtime.RecognitionException) {
this.reportError(re);
this.recover(this.input,re);
} else {
throw re;
}
}
finally {
}
return rsc;
}
// Delegated rules
}, true); // important to pass true to overwrite default implementations
// public class variables
org.antlr.lang.augmentObject(Ham4HMLGen, {
tokenNames: ["<invalid>", "<EOR>", "<DOWN>", "<UP>", "WS", "HamTab", "HamLinefeed", "HamPagebreak", "HamReturn", "HamVersion40", "HamSpace", "HamExclaim", "HamQuery", "HamFullstop", "HamComma", "HamPlus", "HamMetaalt", "HamClocku", "HamClockul", "HamClockl", "HamClockdl", "HamClockd", "HamClockdr", "HamClockr", "HamClockur", "HamClockfull", "HamSymmpar", "HamSymmlr", "HamFist", "HamFlathand", "HamFinger2", "HamFinger23", "HamFinger23spread", "HamFinger2345", "HamThumboutmod", "HamThumbacrossmod", "HamPinch12", "HamPinchall", "HamPinch12open", "HamCee12", "HamCeeall", "HamCee12open", "HamThumbopenmod", "HamFingerstraightmod", "HamFingerbendmod", "HamFingerhookedmod", "HamNondominant", "HamDoublebent", "HamDoublehooked", "HamExtfingeru", "HamExtfingerur", "HamExtfingerr", "HamExtfingerdr", "HamExtfingerd", "HamExtfingerdl", "HamExtfingerl", "HamExtfingerul", "HamExtfingerol", "HamExtfingero", "HamExtfingeror", "HamExtfingeril", "HamExtfingeri", "HamExtfingerir", "HamExtfingerui", "HamExtfingerdi", "HamExtfingerdo", "HamExtfingeruo", "HamEarlobe", "HamNostrils", "HamShouldertop", "HamPalmu", "HamPalmur", "HamPalmr", "HamPalmdr", "HamPalmd", "HamPalmdl", "HamPalml", "HamPalmul", "HamReplace", "HamArmextended", "HamBehind", "HamEtc", "HamOrirelative", "HamTongue", "HamTeeth", "HamStomach", "HamNeutralspace", "HamHead", "HamHeadtop", "HamForehead", "HamEyebrows", "HamEyes", "HamNose", "HamEar", "HamCheek", "HamLips", "HamChin", "HamUnderchin", "HamNeck", "HamShoulders", "HamChest", "HamBelowstomach", "HamLrbeside", "HamLrat", "HamUpperarm", "HamElbow", "HamElbowinside", "HamLowerarm", "HamWristback", "HamWristpulse", "HamThumbball", "HamPalm", "HamHandback", "HamThumb", "HamIndexfinger", "HamMiddlefinger", "HamRingfinger", "HamPinky", "HamThumbside", "HamPinkyside", "HamBetween", "HamFingertip", "HamFingernail", "HamFingerpad", "HamFingermidjoint", "HamFingerbase", "HamFingerside", "HamWristtopulse", "HamWristtoback", "HamWristtothumb", "HamWristtopinky", "HamCoreftag", "HamCorefref", "HamNomotion", "HamMoveu", "HamMoveur", "HamMover", "HamMovedr", "HamMoved", "HamMovedl", "HamMovel", "HamMoveul", "HamMoveol", "HamMoveo", "HamMoveor", "HamMoveil", "HamMovei", "HamMoveir", "HamMoveui", "HamMovedi", "HamMovedo", "HamMoveuo", "HamMovecross", "HamMovex", "HamSmallmod", "HamLargemod", "HamArcl", "HamArcu", "HamArcr", "HamArcd", "HamWavy", "HamZigzag", "HamFingerplay", "HamParbegin", "HamParend", "HamCircleo", "HamCirclei", "HamCircled", "HamCircleu", "HamCirclel", "HamCircler", "HamIncreasing", "HamDecreasing", "HamClose", "HamTouch", "HamInterlock", "HamCross", "HamFast", "HamSlow", "HamTense", "HamRest", "HamHalt", "HamRepeatfromstart", "HamRepeatfromstartseveral", "HamRepeatcontinue", "HamRepeatcontinueseveral", "HamSeqbegin", "HamSeqend", "HamAlternatingmotion", "HamRepeatreverse", "HamBrushing", "HamNonipsi", "HamEllipseh", "HamEllipseur", "HamEllipsev", "HamEllipseul", "HamMime", "HamAltbegin", "HamAltend", "HamNodding", "HamSwinging", "HamTwisting", "HamStircw", "HamStirccw", "HamFusionbegin", "HamFusionend", "HamCircleul", "HamCircledr", "HamCircleur", "HamCircledl", "HamCircleol", "HamCircleir", "HamCircleor", "HamCircleil", "HamCircledo", "HamCircleui", "HamCircledi", "HamCircleuo", "HamNbs", "HAMSIGNS", "SIGN2", "SIGN1", "ICFG2", "ICFG1", "NMICLIST", "NMICUNIT", "MICFG2", "MICFG1", "HDCONFIG2", "HDCONFIG1", "SPLITHDCFG2", "HDCFGTAIL2", "HSHAPE2", "HSHAPE1", "BASICHDSHP1", "BASICHDSHP", "HSCLASS", "FIBENDING", "THUMBPOS", "FINGERLIST", "FISHPLIST", "FICRSSLIST", "FSHAPE", "FCROSSING", "THSPECIAL", "EXTFIDIR2", "EXTFIDIR1", "EXTFIDIR", "PALMOR2", "PALMOR1", "LOC2", "LOC1", "LOCTNBODYARM", "LOCTNBODY", "LOCTNHAND", "LOCTNARM", "LEVBODY", "LEVHAND", "LEVARM", "HCONSTLLN", "CNTCTBODY", "CNTCTHAND", "CNTCTOFHAND", "A2TLIST", "A1TLIST", "A1LIST", "ACTION2T", "ACTION1T", "ACTION2", "ACTION1", "PARACT2T", "SEQACT2T", "SPLITACT2LOC2", "SPLITACT2T", "PARACT1T", "SEQACT1T", "NMACT1T", "PARACT1", "REPETITIONS", "SIMPLEMVMT", "STRGHTMVMT", "CRCLRMVMT", "REPLACE", "SPLITREPLACETL", "REPLACETAIL1", "HSFINGERITEM", "LOCBODY", "MOVINGREPETITION", "SEQACT1", "SEQFUSEDACT2T", "SEQFUSEDACT1T", "SEQFUSEDACT1", "CNTCTOHHAND", "CNTCTOHARM"],
FOLLOW_HAMSIGNS_in_hamsignseq149: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_sign2or1_in_hamsignseq164: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x30000000, 0x00000000]),
FOLLOW_sign2_in_sign2or1246: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_nondomsign1_in_sign2or1273: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_SIGN2_in_sign2324: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_symmoperator_in_sign2356: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
FOLLOW_initialconfig2_in_sign2375: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000080, 0x00000000]),
FOLLOW_a2tstar_in_sign2395: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_initialconfig2_in_sign2424: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_sign2444: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamNomotion_in_sign2481: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_HamNondominant_in_sign2515: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_initialconfig1_in_sign2550: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_sign2570: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SIGN1_in_nondomsign1624: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamNondominant_in_nondomsign1644: new org.antlr.runtime.BitSet([0x00000000, 0x00004000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x80000000, 0x00000000]),
FOLLOW_initialconfig1_in_nondomsign1659: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000100, 0x00000000]),
FOLLOW_a1tstar_in_nondomsign1675: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamSymmpar_in_symmoperator745: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamSymmlr_in_symmoperator780: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator828: new org.antlr.runtime.BitSet([0x00000002, 0x00000800,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator863: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamFingerstraightmod_in_symmoperator897: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x90000000]),
FOLLOW_HamLargemod_in_symmoperator920: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x90000000]),
FOLLOW_HamAlternatingmotion_in_symmoperator965: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x80000000]),
FOLLOW_HamNonipsi_in_symmoperator987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_ICFG2_in_initialconfig21048: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig21065: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000004]),
FOLLOW_minitialconfig2_in_initialconfig21086: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ICFG1_in_initialconfig11127: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nminitialconfig_in_initialconfig11144: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000008]),
FOLLOW_minitialconfig1_in_initialconfig11165: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_NMICLIST_in_nminitialconfig1213: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_nmicunit_in_nminitialconfig1242: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000002]),
FOLLOW_NMICUNIT_in_nmicunit1308: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelbody_in_nmicunit1336: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_levelarm_in_nmicunit1364: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_action1_in_nmicunit1388: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MICFG2_in_minitialconfig21428: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig2_in_minitialconfig21460: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_location2_in_minitialconfig21481: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig21516: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig21536: new org.antlr.runtime.BitSet([0x00008000, 0x00000000]),
FOLLOW_HamPlus_in_minitialconfig21563: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig21583: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MICFG1_in_minitialconfig11636: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig1_in_minitialconfig11654: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_minitialconfig11671: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCONFIG2_in_handconfig21721: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape2_in_handconfig21757: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000080]),
FOLLOW_handconfigtail2_in_handconfig21778: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_splithandconfig2_in_handconfig21817: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCONFIG1_in_handconfig11871: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape1_in_handconfig11890: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400000]),
FOLLOW_extfidir1_in_handconfig11908: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfig11930: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITHDCFG2_in_splithandconfig21985: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handconfig1_in_splithandconfig22001: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000020]),
FOLLOW_handconfig1_in_splithandconfig22017: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HDCFGTAIL2_in_handconfigtail22061: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir2_in_handconfigtail22095: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x01000000]),
FOLLOW_palmor2_in_handconfigtail22127: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_extfidir1_in_handconfigtail22169: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfigtail22192: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00400000]),
FOLLOW_extfidir1_in_handconfigtail22214: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_handconfigtail22237: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSHAPE2_in_handshape22295: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshape1_in_handshape22313: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000200]),
FOLLOW_handshape1_in_handshape22331: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSHAPE1_in_handshape12379: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_basichandshape1_in_handshape12398: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00138000]),
FOLLOW_fingerlist_in_handshape12417: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00130000]),
FOLLOW_fingershapelist_in_handshape12439: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00120000]),
FOLLOW_fingercrossinglist_in_handshape12461: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00100000]),
FOLLOW_thumbspecial_in_handshape12484: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_BASICHDSHP1_in_basichandshape12527: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_basichandshape_in_basichandshape12545: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000800]),
FOLLOW_basichandshape_in_basichandshape12568: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_BASICHDSHP_in_basichandshape2617: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_handshapeclass_in_basichandshape2639: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_HamNondominant_in_basichandshape2668: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_HamEtc_in_basichandshape2695: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_thumbpos_in_basichandshape2778: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_fingerbending_in_basichandshape2811: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_fingerbending_in_basichandshape2852: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00004000]),
FOLLOW_thumbpos_in_basichandshape2880: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HSCLASS_in_handshapeclass2939: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamFist_in_handshapeclass2953: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFlathand_in_handshapeclass2981: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger2_in_handshapeclass3005: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger23_in_handshapeclass3030: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger23spread_in_handshapeclass3054: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFinger2345_in_handshapeclass3072: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinch12_in_handshapeclass3094: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinchall_in_handshapeclass3119: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPinch12open_in_handshapeclass3143: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCee12_in_handshapeclass3164: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCeeall_in_handshapeclass3191: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamCee12open_in_handshapeclass3217: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_FIBENDING_in_fingerbending3272: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamFingerstraightmod_in_fingerbending3286: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingerbendmod_in_fingerbending3305: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingerhookedmod_in_fingerbending3328: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublebent_in_fingerbending3349: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublehooked_in_fingerbending3375: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_THUMBPOS_in_thumbpos3436: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamThumboutmod_in_thumbpos3450: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumbacrossmod_in_thumbpos3471: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumbopenmod_in_thumbpos3489: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamThumb_in_thumb3546: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamIndexfinger_in_finger3596: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMiddlefinger_in_finger3617: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRingfinger_in_finger3637: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPinky_in_finger3659: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HSFINGERITEM_in_hsfingeritem3723: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_finger_in_hsfingeritem3737: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000]),
FOLLOW_HamLargemod_in_hsfingeritem3757: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_thumb_in_digit3825: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_finger_in_digit3839: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_FINGERLIST_in_fingerlist3888: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_hsfingeritem_in_fingerlist3904: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x20000000, 0x00000000]),
FOLLOW_FISHPLIST_in_fingershapelist3968: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fingershape_in_fingershapelist3984: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00040000]),
FOLLOW_FICRSSLIST_in_fingercrossinglist4047: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fingercrossing_in_fingercrossinglist4063: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00080000]),
FOLLOW_FSHAPE_in_fingershape4118: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_fingershape4133: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00006000]),
FOLLOW_fingerbending_in_fingershape4147: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_FCROSSING_in_fingercrossing4188: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_fingercrossing4202: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7E000000]),
FOLLOW_fingerpart_in_fingercrossing4216: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_fingercrossing4230: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_THSPECIAL_in_thumbspecial4276: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamBetween_in_thumbspecial4291: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_finger_in_thumbspecial4317: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_finger_in_thumbspecial4343: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_thumb_in_thumbspecial4408: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_fingerpart_in_thumbspecial4441: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamFingertip_in_fingerpart4507: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingernail_in_fingerpart4530: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerpad_in_fingerpart4552: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingermidjoint_in_fingerpart4575: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerbase_in_fingerpart4593: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFingerside_in_fingerpart4615: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_EXTFIDIR2_in_extfidir24676: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir1_in_extfidir24695: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00400000]),
FOLLOW_extfidir1_in_extfidir24714: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_EXTFIDIR1_in_extfidir14767: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir_in_extfidir14784: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00800000]),
FOLLOW_extfidir_in_extfidir14801: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_extfidir14824: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_EXTFIDIR_in_extfidir4887: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamExtfingeru_in_extfidir4921: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerur_in_extfidir4951: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerr_in_extfidir4980: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdr_in_extfidir5010: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerd_in_extfidir5039: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdl_in_extfidir5069: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerl_in_extfidir5098: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerul_in_extfidir5128: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerol_in_extfidir5185: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5236: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir5265: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingero_in_extfidir5319: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir5367: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000006, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5418: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir5447: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeril_in_extfidir5519: new org.antlr.runtime.BitSet([0x00000008, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir5570: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir5599: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeri_in_extfidir5653: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir5701: new org.antlr.runtime.BitSet([0x00000008, 0x80000000,0x00000001, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir5752: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir5781: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeruo_in_extfidir5863: new org.antlr.runtime.BitSet([0x00000008, 0x0A000000]),
FOLLOW_HamExtfingerol_in_extfidir5914: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir5943: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdo_in_extfidir6015: new org.antlr.runtime.BitSet([0x00000008, 0x0A000000]),
FOLLOW_HamExtfingerol_in_extfidir6066: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingeror_in_extfidir6095: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerui_in_extfidir6167: new org.antlr.runtime.BitSet([0x00000008, 0x50000000]),
FOLLOW_HamExtfingeril_in_extfidir6218: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir6247: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerdi_in_extfidir6319: new org.antlr.runtime.BitSet([0x00000008, 0x50000000]),
FOLLOW_HamExtfingeril_in_extfidir6370: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamExtfingerir_in_extfidir6399: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PALMOR2_in_palmor26500: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_palmor1_in_palmor26518: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_palmor26536: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PALMOR1_in_palmor16591: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_palmor_in_palmor16609: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00063FC0, 0x00000000]),
FOLLOW_palmor_in_palmor16637: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamEtc_in_palmor16667: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00040000, 0x00000000]),
FOLLOW_HamOrirelative_in_palmor16709: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamPalmu_in_palmor6778: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmur_in_palmor6801: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmr_in_palmor6823: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmdr_in_palmor6846: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmd_in_palmor6868: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmdl_in_palmor6891: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalml_in_palmor6913: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalmul_in_palmor6936: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LOC2_in_location27001: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_location1_in_location27033: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_location27054: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_handconstellation_in_location27090: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x20000000]),
FOLLOW_HamArmextended_in_location27128: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationbody_in_location27174: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOC1_in_location17245: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_digit_in_location17273: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationhand_in_location17315: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationbodyarm_in_location17343: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNBODYARM_in_locationbodyarm7397: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_locationbody_in_locationbodyarm7425: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_locationarm_in_locationbodyarm7453: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamArmextended_in_locationbodyarm7479: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNBODY_in_locationbody7548: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexbody_in_locationbody7566: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00010000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamBehind_in_locationbody7586: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_contactbody_in_locationbody7642: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNHAND_in_locationhand7688: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexhand_in_locationhand7706: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_contacthand_in_locationhand7725: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LOCTNARM_in_locationarm7776: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexarm_in_locationarm7794: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00010000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_HamBehind_in_locationarm7814: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000010, 0x00000000]),
FOLLOW_contactbody_in_locationarm7870: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody7921: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000001, 0x00000000]),
FOLLOW_levelbody_in_levelcomplexbody7939: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand7984: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000002, 0x00000000]),
FOLLOW_levelhand_in_levelcomplexhand8002: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm8048: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000004, 0x00000000]),
FOLLOW_levelarm_in_levelcomplexarm8066: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LEVBODY_in_levelbody8113: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelbody8132: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x60000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x40000000, 0x00000000]),
FOLLOW_locbody_in_levelbody8165: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000000C0]),
FOLLOW_locsided_in_levelbody8194: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000000C0]),
FOLLOW_HamEtc_in_levelbody8224: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelbody8259: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LEVHAND_in_levelhand8313: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelhand8332: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x7EFFF000]),
FOLLOW_handpart_in_levelhand8365: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_fingerpart_in_levelhand8404: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003F80C0]),
FOLLOW_digit_in_levelhand8435: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003F80C0]),
FOLLOW_digit_in_levelhand8478: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x7E3F80C0]),
FOLLOW_fingerpart_in_levelhand8512: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_dorsalorpalmar_in_levelhand8555: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelhand8577: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_LEVARM_in_levelarm8632: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_side_in_levelarm8651: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000F00]),
FOLLOW_locarm_in_levelarm8674: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x000180C0]),
FOLLOW_HamEtc_in_levelarm8694: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000180C0]),
FOLLOW_dorsalorpalmar_in_levelarm8729: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x000000C0]),
FOLLOW_side_in_levelarm8751: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTBODY_in_contactbody8799: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contactbody8829: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamArmextended_in_contactbody8853: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactofhand_in_contactbody8905: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTHAND_in_contacthand8959: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contacthand8989: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ccontact_in_contacthand9019: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactofhand_in_contacthand9049: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOFHAND_in_contactofhand9111: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_pcontact_in_contactofhand9144: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000030]),
FOLLOW_ccontact_in_contactofhand9177: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000030]),
FOLLOW_contactohhand_in_contactofhand9219: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_contactoharm_in_contactofhand9251: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOHHAND_in_contactohhand9307: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexhand_in_contactohhand9321: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_CNTCTOHARM_in_contactoharm9366: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelcomplexarm_in_contactoharm9380: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HCONSTLLN_in_handconstellation9422: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_locationhand_in_handconstellation9450: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x40000000]),
FOLLOW_locationhand_in_handconstellation9468: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000020, 0x00000000]),
FOLLOW_contacthand_in_handconstellation9498: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamUpperarm_in_locarm9553: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamElbow_in_locarm9577: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamElbowinside_in_locarm9604: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLowerarm_in_locarm9625: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_LOCBODY_in_locbody9685: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamHead_in_locbody9699: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamHeadtop_in_locbody9731: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamForehead_in_locbody9760: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamEyebrows_in_locbody9788: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamEyes_in_locbody9816: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNose_in_locbody9848: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNostrils_in_locbody9880: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamLips_in_locbody9908: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamTongue_in_locbody9940: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamTeeth_in_locbody9970: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamChin_in_locbody10001: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamUnderchin_in_locbody10033: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamNeck_in_locbody10060: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamShouldertop_in_locbody10092: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamShoulders_in_locbody10117: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamChest_in_locbody10144: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamStomach_in_locbody10175: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamBelowstomach_in_locbody10204: new org.antlr.runtime.BitSet([0x00000008, 0x00018000]),
FOLLOW_HamDoublebent_in_locbody10248: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamDoublehooked_in_locbody10274: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamEar_in_locsided10345: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEarlobe_in_locsided10374: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCheek_in_locsided10399: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamWristback_in_handpart10464: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamWristpulse_in_handpart10487: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumbball_in_handpart10509: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalm_in_handpart10532: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHandback_in_handpart10560: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamThumbside_in_handpart10584: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPinkyside_in_handpart10607: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLrbeside_in_side10692: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLrat_in_side10716: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHandback_in_dorsalorpalmar10778: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamPalm_in_dorsalorpalmar10802: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTouch_in_pcontact10868: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClose_in_pcontact10895: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamInterlock_in_ccontact10966: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCross_in_ccontact10989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_A2TLIST_in_a2tstar11061: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_a2tstar11079: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_A1TLIST_in_a1tstar11141: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_a1tstar11159: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_ACTION2T_in_action2t11216: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_action2t11244: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_action1_in_action2t11274: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000]),
FOLLOW_location2_in_action2t11292: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_splitaction2loc2_in_action2t11321: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_splitaction2t_in_action2t11356: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_paraction2t_in_action2t11393: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqaction2t_in_action2t11421: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqfusedaction2t_in_action2t11449: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_repetitions_in_action2t11485: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ACTION1T_in_action1t11540: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_action1t11574: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000,0x00400008, 0x00000000]),
FOLLOW_location1_in_action1t11611: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_HamLargemod_in_action1t11635: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_handconstellation_in_action1t11679: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_paraction1t_in_action1t11726: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqaction1t_in_action1t11758: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_seqfusedaction1t_in_action1t11790: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_nmaction1t_in_action1t11821: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00400000, 0x00000000]),
FOLLOW_repetitions_in_action1t11863: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ACTION1_in_action111919: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_HamNomotion_in_action111953: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_simplemovement_in_action112009: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_modifier_in_action112063: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x08000000, 0x003E0000]),
FOLLOW_HamLargemod_in_action112130: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_paraction1_in_action112184: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_seqaction1_in_action112216: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_seqfusedaction1_in_action112248: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PARACT2T_in_paraction2t12309: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_paraction2t12339: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SEQACT2T_in_seqaction2t12405: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_seqaction2t12435: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SEQFUSEDACT2T_in_seqfusedaction2t12504: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action2t_in_seqfusedaction2t12534: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000400, 0x00000000]),
FOLLOW_SPLITACT2LOC2_in_splitaction2loc212599: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_splitaction2loc212619: new org.antlr.runtime.BitSet([0x00008000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2loc212642: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_action1_in_splitaction2loc212662: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x04000000,0x00002000, 0x00000000]),
FOLLOW_location2_in_splitaction2loc212693: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITACT2T_in_splitaction2t12739: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_splitaction2t12758: new org.antlr.runtime.BitSet([0x00008008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_HamPlus_in_splitaction2t12780: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_action1t_in_splitaction2t12799: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_PARACT1T_in_paraction1t12859: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_paraction1t12889: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_SEQACT1T_in_seqaction1t12955: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_seqaction1t12985: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_SEQFUSEDACT1T_in_seqfusedaction1t13054: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1t_in_seqfusedaction1t13084: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_NMACT1T_in_nmaction1t13147: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_levelbody_in_nmaction1t13176: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_levelarm_in_nmaction1t13205: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000800, 0x00000000]),
FOLLOW_action1t_in_nmaction1t13236: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_PARACT1_in_paraction113285: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_paraction113315: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_SEQACT1_in_seqaction113387: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_seqaction113417: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_SEQFUSEDACT1_in_seqfusedaction113492: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_action1_in_seqfusedaction113522: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00002000, 0x00000000]),
FOLLOW_REPETITIONS_in_repetitions13595: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_repetition_in_repetitions13646: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00020000, 0x00000000,0x00000000, 0x33C01800]),
FOLLOW_HamEtc_in_repetitions13692: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_repetitions13736: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_repetition_in_repetitions13784: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_movingrepetition_in_repetitions13845: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10001800]),
FOLLOW_sizechange_in_repetitions13901: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x10000000]),
FOLLOW_size_in_repetitions13928: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions13988: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14001: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14046: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x10000000]),
FOLLOW_HamAlternatingmotion_in_repetitions14067: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_MOVINGREPETITION_in_movingrepetition14124: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_repetition_in_movingrepetition14148: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_movingrepetition14171: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800]),
FOLLOW_size_in_movingrepetition14194: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechange_in_movingrepetition14230: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_movingrepetition14251: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SIMPLEMVMT_in_simplemovement14313: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_fullstraightmovement_in_simplemovement14342: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullcircularmovement_in_simplemovement14371: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullwristmovement_in_simplemovement14400: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_fullmovementcross_in_simplemovement14429: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_replacement_in_simplemovement14458: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_digit_in_simplemovement14516: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x00000004]),
FOLLOW_HamFingerplay_in_simplemovement14581: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000,0x00000000, 0x40000000]),
FOLLOW_HamBrushing_in_simplemovement14641: new org.antlr.runtime.BitSet([0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x08000000]),
FOLLOW_location1_in_simplemovement14660: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x003E0000]),
FOLLOW_digit_in_simplemovement14689: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_straightmovement_in_fullstraightmovement14752: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000003]),
FOLLOW_size_in_fullstraightmovement14777: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xF0000000, 0x00000003]),
FOLLOW_arckind_in_fullstraightmovement14810: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_zigzag_in_fullstraightmovement14841: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_STRGHTMVMT_in_straightmovement14896: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement14915: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00FFFFC0, 0x00000000]),
FOLLOW_movementarrow_in_straightmovement14934: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_arc_in_arckind15001: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0xFC000000, 0x00000000]),
FOLLOW_arc_in_arckind15020: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_arckind15043: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamZigzag_in_zigzag15126: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_HamWavy_in_zigzag15162: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_zigzag15199: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipsedirection_in_zigzag15221: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_zigzag15244: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_sizechange_in_sizechangenonlinear15308: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_sizechangenonlinear15327: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_circularmovement_in_fullcircularmovement15390: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_size_in_fullcircularmovement15415: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_revolutions_in_fullcircularmovement15438: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800,0x0000000F, 0x00000000]),
FOLLOW_ellipse_in_fullcircularmovement15461: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00001800]),
FOLLOW_sizechangenonlinear_in_fullcircularmovement15484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_CRCLRMVMT_in_circularmovement15531: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement15549: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x000007E0,0x03FFC000, 0x00000000]),
FOLLOW_movementcircle_in_circularmovement15567: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_ellipsedirection_in_ellipse15636: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_ellipse15655: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_clock_in_revolutions15736: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15768: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15797: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15846: new org.antlr.runtime.BitSet([0x03FE0002, 0x00000000]),
FOLLOW_HamClockfull_in_revolutions15875: new org.antlr.runtime.BitSet([0x01FE0002, 0x00000000]),
FOLLOW_clock_in_revolutions15922: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_wristmovement_in_fullwristmovement15985: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_fullwristmovement16004: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_movementcross_in_fullmovementcross16067: new org.antlr.runtime.BitSet([0x00000002, 0x00000000,0x00000000, 0x00000000,0x0C000000, 0x00000000]),
FOLLOW_size_in_fullmovementcross16086: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_REPLACE_in_replacement16138: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_sizechange_in_replacement16157: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400200,0x08000000, 0x00000000]),
FOLLOW_handshape1_in_replacement16179: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02400000,0x08000000, 0x00000000]),
FOLLOW_splitreplacetail_in_replacement16214: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_extfidir1_in_replacement16246: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_replacement16269: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_palmor1_in_replacement16305: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_SPLITREPLACETL_in_splitreplacetail16359: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail16377: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x10000000, 0x00000000]),
FOLLOW_replacetail1_in_splitreplacetail16395: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_REPLACETAIL1_in_replacetail116445: new org.antlr.runtime.BitSet([0x00000004, 0x00000000]),
FOLLOW_extfidir1_in_replacetail116477: new org.antlr.runtime.BitSet([0x00000008, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x00000000,0x00000000, 0x02000000]),
FOLLOW_palmor1_in_replacetail116503: new org.antlr.runtime.BitSet([0x00000008, 0x00000000]),
FOLLOW_HamRepeatfromstart_in_repetition16567: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatfromstartseveral_in_repetition16580: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatcontinue_in_repetition16620: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatcontinueseveral_in_repetition16634: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRepeatreverse_in_repetition16674: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveu_in_movementarrow16718: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveur_in_movementarrow16741: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMover_in_movementarrow16763: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedr_in_movementarrow16786: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoved_in_movementarrow16808: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedl_in_movementarrow16831: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovel_in_movementarrow16853: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveul_in_movementarrow16876: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveol_in_movementarrow16898: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveo_in_movementarrow16920: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveor_in_movementarrow16943: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveil_in_movementarrow16965: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovei_in_movementarrow16987: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveir_in_movementarrow17010: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveui_in_movementarrow17032: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedi_in_movementarrow17054: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovedo_in_movementarrow17076: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMoveuo_in_movementarrow17098: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovecross_in_movementcross17155: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamMovex_in_movementcross17174: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamNodding_in_wristmovement17226: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSwinging_in_wristmovement17247: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTwisting_in_wristmovement17267: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStircw_in_wristmovement17287: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamStirccw_in_wristmovement17309: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleo_in_movementcircle17358: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCirclei_in_movementcircle17379: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircled_in_movementcircle17400: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleu_in_movementcircle17421: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCirclel_in_movementcircle17442: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircler_in_movementcircle17463: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleul_in_movementcircle17484: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledr_in_movementcircle17504: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleur_in_movementcircle17524: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledl_in_movementcircle17544: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleol_in_movementcircle17564: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleir_in_movementcircle17584: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleor_in_movementcircle17604: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleil_in_movementcircle17624: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleui_in_movementcircle17644: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledo_in_movementcircle17664: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircledi_in_movementcircle17684: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamCircleuo_in_movementcircle17704: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseh_in_ellipsedirection17760: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseur_in_ellipsedirection17780: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipsev_in_ellipsedirection17799: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamEllipseul_in_ellipsedirection17819: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClocku_in_clock17881: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockul_in_clock17903: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockl_in_clock17924: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockdl_in_clock17946: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockd_in_clock17967: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockdr_in_clock17989: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockr_in_clock18010: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamClockur_in_clock18032: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamFast_in_modifier18093: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSlow_in_modifier18117: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamTense_in_modifier18141: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamRest_in_modifier18164: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamHalt_in_modifier18188: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcl_in_arc18251: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcu_in_arc18275: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcr_in_arc18299: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamArcd_in_arc18323: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamSmallmod_in_size18385: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamLargemod_in_size18405: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamIncreasing_in_sizechange18457: new org.antlr.runtime.BitSet([0x00000002, 0x00000000]),
FOLLOW_HamDecreasing_in_sizechange18475: new org.antlr.runtime.BitSet([0x00000002, 0x00000000])
});
})();//-------- js/Coffee-fix.js --------
// Exports
this.getCWAEnv().add(Ham4Parser, "Ham4Parser");
//-------- js/HamLexer.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   A TokenStream lexer for ANTLR
var CommonToken, EOF, HamLexer, Logger, Token, cwaenv, document, hamLimit, lggr, ttMap, ttUnused;
cwaenv = this.getCWAEnv();
Logger = cwaenv.get("Logger");
// Enhanced if run from HtoG tool
lggr = Logger.get("SiGML");
document = this.document;
EOF = 1;
ttUnused = -1;
hamLimit = 256;
ttMap = [
ttUnused, // 00   0
ttUnused, // 01   1
ttUnused, // 02   2
ttUnused, // 03   3
ttUnused, // 04   4
ttUnused, // 05   5
ttUnused, // 06   6
ttUnused, // 07   7
ttUnused, // 08   8
Ham4Parser.HamTab, // 09   9
Ham4Parser.HamLinefeed, // 0a  10
ttUnused, // 0b  11
Ham4Parser.HamPagebreak, // 0c  12
Ham4Parser.HamReturn, // 0d  13
ttUnused, // 0e  14
ttUnused, // 0f  15
ttUnused, // 10  16
ttUnused, // 11  17
ttUnused, // 12  18
ttUnused, // 13  19
Ham4Parser.HamVersion40, // 14  20
ttUnused, // 15  21
ttUnused, // 16  22
ttUnused, // 17  23
ttUnused, // 18  24
ttUnused, // 19  25
ttUnused, // 1a  26
ttUnused, // 1b  27
ttUnused, // 1c  28
ttUnused, // 1d  29
ttUnused, // 1e  30
ttUnused, // 1f  31
Ham4Parser.HamSpace, // 20  32
Ham4Parser.HamExclaim, // 21  33
Ham4Parser.HamQuery, // 22  34
Ham4Parser.HamFullstop, // 23  35
Ham4Parser.HamComma, // 24  36
Ham4Parser.HamPlus, // 25  37
Ham4Parser.HamMetaalt, // 26  38
Ham4Parser.HamClocku, // 27  39
Ham4Parser.HamClockul, // 28  40
Ham4Parser.HamClockl, // 29  41
Ham4Parser.HamClockdl, // 2a  42
Ham4Parser.HamClockd, // 2b  43
Ham4Parser.HamClockdr, // 2c  44
Ham4Parser.HamClockr, // 2d  45
Ham4Parser.HamClockur, // 2e  46
Ham4Parser.HamClockfull, // 2f  47
Ham4Parser.HamSymmpar, // 30  48
Ham4Parser.HamSymmlr, // 31  49
Ham4Parser.HamFist, // 32  50
Ham4Parser.HamFlathand, // 33  51
Ham4Parser.HamFinger2, // 34  52
Ham4Parser.HamFinger23, // 35  53
Ham4Parser.HamFinger23spread, // 36  54
Ham4Parser.HamFinger2345, // 37  55
Ham4Parser.HamThumboutmod, // 38  56
Ham4Parser.HamThumbacrossmod, // 39  57
Ham4Parser.HamPinch12, // 3a  58
Ham4Parser.HamPinchall, // 3b  59
Ham4Parser.HamPinch12open, // 3c  60
Ham4Parser.HamCee12, // 3d  61
Ham4Parser.HamCeeall, // 3e  62
Ham4Parser.HamCee12open, // 3f  63
Ham4Parser.HamThumbopenmod, // 40  64
Ham4Parser.HamFingerstraightmod, // 41  65
Ham4Parser.HamFingerbendmod, // 42  66
Ham4Parser.HamFingerhookedmod, // 43  67
Ham4Parser.HamNondominant, // 44  68
Ham4Parser.HamDoublebent, // 45  69
Ham4Parser.HamDoublehooked, // 46  70
ttUnused, // 47  71
Ham4Parser.HamExtfingeru, // 48  72
Ham4Parser.HamExtfingerur, // 49  73
Ham4Parser.HamExtfingerr, // 4a  74
Ham4Parser.HamExtfingerdr, // 4b  75
Ham4Parser.HamExtfingerd, // 4c  76
Ham4Parser.HamExtfingerdl, // 4d  77
Ham4Parser.HamExtfingerl, // 4e  78
Ham4Parser.HamExtfingerul, // 4f  79
Ham4Parser.HamExtfingerol, // 50  80
Ham4Parser.HamExtfingero, // 51  81
Ham4Parser.HamExtfingeror, // 52  82
Ham4Parser.HamExtfingeril, // 53  83
Ham4Parser.HamExtfingeri, // 54  84
Ham4Parser.HamExtfingerir, // 55  85
Ham4Parser.HamExtfingerui, // 56  86
Ham4Parser.HamExtfingerdi, // 57  87
Ham4Parser.HamExtfingerdo, // 58  88
Ham4Parser.HamExtfingeruo, // 59  89
ttUnused, // 5a  90
ttUnused, // 5b  91
ttUnused, // 5c  92
Ham4Parser.HamEarlobe, // 5d  93
Ham4Parser.HamNostrils, // 5e  94
Ham4Parser.HamShouldertop, // 5f  95
Ham4Parser.HamPalmu, // 60  96
Ham4Parser.HamPalmur, // 61  97
Ham4Parser.HamPalmr, // 62  98
Ham4Parser.HamPalmdr, // 63  99
Ham4Parser.HamPalmd, // 64 100
Ham4Parser.HamPalmdl, // 65 101
Ham4Parser.HamPalml, // 66 102
Ham4Parser.HamPalmul, // 67 103
Ham4Parser.HamReplace, // 68 104
Ham4Parser.HamArmextended, // 69 105
Ham4Parser.HamBehind, // 6a 106
Ham4Parser.HamEtc, // 6b 107
Ham4Parser.HamOrirelative, // 6c 108
Ham4Parser.HamTongue, // 6d 109
Ham4Parser.HamTeeth, // 6e 110
Ham4Parser.HamStomach, // 6f 111
Ham4Parser.HamNeutralspace, // 70 112
Ham4Parser.HamHead, // 71 113
Ham4Parser.HamHeadtop, // 72 114
Ham4Parser.HamForehead, // 73 115
Ham4Parser.HamEyebrows, // 74 116
Ham4Parser.HamEyes, // 75 117
Ham4Parser.HamNose, // 76 118
Ham4Parser.HamEar, // 77 119
Ham4Parser.HamCheek, // 78 120
Ham4Parser.HamLips, // 79 121
Ham4Parser.HamChin, // 7a 122
Ham4Parser.HamUnderchin, // 7b 123
Ham4Parser.HamNeck, // 7c 124
Ham4Parser.HamShoulders, // 7d 125
Ham4Parser.HamChest, // 7e 126
Ham4Parser.HamStomach, // 7f 127
Ham4Parser.HamBelowstomach, // 80 128
Ham4Parser.HamLrbeside, // 129
Ham4Parser.HamLrat, // 130
Ham4Parser.HamUpperarm, // 131
Ham4Parser.HamElbow, // 132
Ham4Parser.HamElbowinside, // 133
Ham4Parser.HamLowerarm, // 134
Ham4Parser.HamWristback, // 135
Ham4Parser.HamWristpulse, // 136
Ham4Parser.HamThumbball, // 137
Ham4Parser.HamPalm, // 138
Ham4Parser.HamHandback, // 139
Ham4Parser.HamThumb, // 140
Ham4Parser.HamIndexfinger, // 141
Ham4Parser.HamMiddlefinger, // 142
Ham4Parser.HamRingfinger, // 143
Ham4Parser.HamPinky, // 144
Ham4Parser.HamThumbside, // 145
Ham4Parser.HamPinkyside, // 146
Ham4Parser.HamBetween, // 147
Ham4Parser.HamFingertip, // 148
Ham4Parser.HamFingernail, // 149
Ham4Parser.HamFingerpad, // 150
Ham4Parser.HamFingermidjoint, // 151
Ham4Parser.HamFingerbase, // 152
Ham4Parser.HamFingerside, // 153
Ham4Parser.HamWristtopulse, // 154
Ham4Parser.HamWristtoback, // 155
Ham4Parser.HamWristtothumb, // 156
Ham4Parser.HamWristtopinky, // 157
Ham4Parser.HamCoreftag, // 158
Ham4Parser.HamCorefref, // 159
Ham4Parser.HamNomotion, // 160
Ham4Parser.HamMoveu, // 161
Ham4Parser.HamMoveur, // 162
Ham4Parser.HamMover, // 163
Ham4Parser.HamMovedr, // 164
Ham4Parser.HamMoved, // 165
Ham4Parser.HamMovedl, // 166
Ham4Parser.HamMovel, // 167
Ham4Parser.HamMoveul, // 168
Ham4Parser.HamMoveol, // 169
Ham4Parser.HamMoveo, // 170
Ham4Parser.HamMoveor, // 171
Ham4Parser.HamMoveil, // 172
Ham4Parser.HamMovei, // 173
Ham4Parser.HamMoveir, // 174
Ham4Parser.HamMoveui, // 175
Ham4Parser.HamMovedi, // 176
Ham4Parser.HamMovedo, // 177
Ham4Parser.HamMoveuo, // 178
Ham4Parser.HamMovecross, // 179
Ham4Parser.HamMovex, // 180
Ham4Parser.HamSmallmod, // 181
Ham4Parser.HamLargemod, // 182
Ham4Parser.HamArcl, // 183
Ham4Parser.HamArcu, // 184
Ham4Parser.HamArcr, // 185
Ham4Parser.HamArcd, // 186
Ham4Parser.HamWavy, // 187
Ham4Parser.HamZigzag, // 188
Ham4Parser.HamFingerplay, // 189
Ham4Parser.HamParbegin, // 190
Ham4Parser.HamParend, // 191
Ham4Parser.HamCircleo, // 192
Ham4Parser.HamCirclei, // 193
Ham4Parser.HamCircled, // 194
Ham4Parser.HamCircleu, // 195
Ham4Parser.HamCirclel, // 196
Ham4Parser.HamCircler, // 197
Ham4Parser.HamIncreasing, // 198
Ham4Parser.HamDecreasing, // 199
Ham4Parser.HamClose, // 200
Ham4Parser.HamTouch, // 201
Ham4Parser.HamInterlock, // 202
Ham4Parser.HamCross, // 203
Ham4Parser.HamFast, // 204
Ham4Parser.HamSlow, // 205
Ham4Parser.HamTense, // 206
Ham4Parser.HamRest, // 207
Ham4Parser.HamHalt, // 208
Ham4Parser.HamRepeatfromstart, // 209
Ham4Parser.HamRepeatfromstartseveral, // 210
Ham4Parser.HamRepeatcontinue, // 211
Ham4Parser.HamRepeatcontinueseveral, // 212
Ham4Parser.HamSeqbegin, // 213
Ham4Parser.HamSeqend, // 214
Ham4Parser.HamAlternatingmotion, // 215
Ham4Parser.HamRepeatreverse, // 216
Ham4Parser.HamBrushing, // 217
Ham4Parser.HamNonipsi, // 218
ttUnused, // 219
Ham4Parser.HamEllipseh, // 220
Ham4Parser.HamEllipseur, // 221
Ham4Parser.HamEllipsev, // 222
Ham4Parser.HamEllipseul, // 223
Ham4Parser.HamMime, // 224
Ham4Parser.HamAltbegin, // 225
Ham4Parser.HamAltend, // 226
Ham4Parser.HamNodding, // 227
Ham4Parser.HamSwinging, // 228
Ham4Parser.HamTwisting, // 229
Ham4Parser.HamStircw, // 230
Ham4Parser.HamStirccw, // 231
ttUnused, // 232
ttUnused, // 233
ttUnused, // 234
ttUnused, // 235
Ham4Parser.HamFusionbegin, // 236
Ham4Parser.HamFusionend, // 237
ttUnused, // 238
ttUnused, // 239
Ham4Parser.HamCircleul, // 240
Ham4Parser.HamCircledr, // 241
Ham4Parser.HamCircleur, // 242
Ham4Parser.HamCircledl, // 243
Ham4Parser.HamCircleol, // 244
Ham4Parser.HamCircleir, // 245
Ham4Parser.HamCircleor, // 246
Ham4Parser.HamCircleil, // 247
Ham4Parser.HamCircledo, // 248
Ham4Parser.HamCircleui, // 249
Ham4Parser.HamCircledi, // 250
Ham4Parser.HamCircleuo, // 251
ttUnused, // 252
ttUnused, // 253
Ham4Parser.HamNbs, // 254
ttUnused // 255
];
Token = org.antlr.runtime.Token;
CommonToken = org.antlr.runtime.CommonToken;
HamLexer = class HamLexer {
constructor(hamSignCharCodes, tokenNames) {
this.hamSignCharCodes = hamSignCharCodes;
this.tokenNames = tokenNames;
this.hamSignLength = this.hamSignCharCodes.length;
if (typeof lggr.debug === "function") {
lggr.debug(`Lex: Overridden Input: ${this.hamSignCharCodes} length=${this.hamSignLength}`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: Tokens: ${this.tokenNames}`);
}
this.iScan = 0;
this.lMark = -1;
}
seek(ix) {
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: seek(${ix}) called`);
}
return this.iScan = ix;
}
rewind(ix) {
if (ix != null) {
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: rewind(${ix}) called`);
}
return this.iScan = ix;
} else {
if (typeof lggr.trace === "function") {
lggr.trace("Lex: rewind() called");
}
if (this.lMark >= 0) {
return this.iScan = this.lMark;
}
}
}
mark() {
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: mark() yeilds ${this.iScan}`);
}
this.lMark = this.iScan;
return this.iScan;
}
index() {
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: index() yeilds ${this.iScan}`);
}
return this.iScan;
}
tokName(i) {
if (i === EOF) {
return "<EOF>";
} else if (i === ttUnused) {
return "<UNUSED>";
} else {
return this.tokenNames[i];
}
}
getType(i, tag) {
var ich, res;
res = Token.EOF;
if (i >= 0 && i < this.hamSignLength) {
ich = this.hamSignCharCodes.charCodeAt(i);
res = ich < hamLimit ? ttMap[ich] : ttUnused;
}
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: at ${this.iScan} getType(${i}) for ${tag} yeilds ${res}=${this.tokName(res)}`);
}
return res;
}
getToken(i) {
var ttype;
ttype = this.getType(i, "getToken");
return new CommonToken(ttype, `${this.tokName(ttype)}{${i}}`);
}
LA(ah) {
var typ;
typ = ah === 0 ? EOF : ah < 0 ? getType(this.iScan + ah, "LA") : this.getType(this.iScan + ah - 1, "LA");
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: LA(${ah}) yeilds ${typ}`);
}
return typ;
}
LT(ah) {
if (typeof lggr.trace === "function") {
lggr.trace(`Lex: LT(${ah}) calls getToken`);
}
if (ah === 0 || (this.iScan + ah) < 0) {
return null;
} else if (ah < 0) {
return this.getToken(this.iScan + ah);
} else {
return this.getToken(this.iScan + ah - 1);
}
}
consume() {
this.iScan++;
return typeof lggr.trace === "function" ? lggr.trace(`Lex: consume() now ${this.iScan}`) : void 0;
}
};
// Export
cwaenv.add(HamLexer, "HamLexer");
// (End HamLexer.coffee)
}).call(this);
//-------- js/HNSSign.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   A DOM parser for h-SiGML creating an HNSSign object
//		Combines HNSSign and HNSSignSAXHandler
var Defs, HNSSign, Logger, Node, cwaenv, lggr;
cwaenv = this.getCWAEnv();
Node = cwaenv.get("Node");
Defs = cwaenv.get("HNSDefs");
Logger = cwaenv.get("Logger");
lggr = Logger.get("SiGML");
HNSSign = class HNSSign {
// Static
// Class
constructor(hnsEl) {
this.hnsEl = hnsEl;
this.hnsMan = "";
this.hnsNonMan = "";
this.hnsGloss = null;
this.hnsDuration = null;
this.hnsSpeed = null;
this.hnsTimeScale = null;
this.hnsSignElText = null;
this.hnsErr = null;
this.scanRoot();
if (typeof lggr.debug === "function") {
lggr.debug(`HNSSign: Sign object created for [${this.hnsGloss}]`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: Manual:    [${this.hnsMan}]`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: Nonmanual: [${this.hnsNonMan}]`);
}
}
scanRoot() {
var ref, ref1, ref2, ref3;
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: Root Name ${this.hnsEl.nodeName}`);
}
if (this.hnsEl.nodeName === "hns_sign") {
this.hnsGloss = (ref = this.hnsEl.attributes.getNamedItem("gloss")) != null ? ref.value : void 0;
this.hnsDuration = (ref1 = this.hnsEl.attributes.getNamedItem("duration")) != null ? ref1.value : void 0;
this.hnsSpeed = (ref2 = this.hnsEl.attributes.getNamedItem("speed")) != null ? ref2.value : void 0;
this.hnsTimeScale = (ref3 = this.hnsEl.attributes.getNamedItem("timescale")) != null ? ref3.value : void 0;
return this._scanSign(this.hnsEl);
}
}
_scanSign(el) {
var i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: Sign Name ${nd.nodeName}`);
}
if (nd.nodeName === "hamnosys_manual") {
results.push(this._scanMan(nd));
} else if (nd.nodeName === "hamnosys_nonmanual") {
results.push(this._scanNonMan(nd));
} else {
results.push(void 0);
}
}
return results;
}
_scanMan(el) {
var hamVal, i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (!(nd.nodeType === Node.ELEMENT_NODE)) {
continue;
}
hamVal = Defs.hamMap[nd.nodeName];
if (hamVal != null) {
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: Man Element Name ${nd.nodeName}=${hamVal.charCodeAt(0)}`);
}
this.hnsMan += hamVal;
} else {
if (typeof lggr.info === "function") {
lggr.info(`HNSSign: Manual Element not recognised: ${nd.nodeName}`);
}
}
// Nothing expected
results.push(this._scanMan(nd));
}
return results;
}
_nonManVal(el) {
var currTag, i, ix, j, k, len, len1, len2, newTok, ref, ref1, ref2, tagMatch, tagVal, tags, testTag, theTag, tok;
theTag = el.tagName;
if (theTag === Defs.HNS_MOUTHPICTURE_TAG) {
tok = Defs.MOUTH_PICTURE_LETTER + el.getAttribute(Defs.PICTURE_ATTR);
} else {
// Treat missing tag attributes as empty string
tagVal = (ref = el.getAttribute(Defs.TAG_ATTR)) != null ? ref : "";
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: NMs: ${theTag} ${tagVal}`);
}
if (theTag === Defs.HNS_MOUTHGESTURE_TAG) {
tok = tagVal;
} else {
tok = "";
// Handle multiple tags separated by |
tags = (tagVal.replace(/\s/g, "")).split("|");
for (i = 0, len = tags.length; i < len; i++) {
currTag = tags[i];
tagMatch = -1;
ref1 = Defs.EYE_RELATED_HML_TAGS;
// Check for an Eye teir
for (ix = j = 0, len1 = ref1.length; j < len1; ix = ++j) {
testTag = ref1[ix];
if (theTag === testTag) {
tagMatch = ix;
}
}
if (tagMatch >= 0) {
newTok = Defs.EYES_LETTER + currTag;
} else {
ref2 = Defs.NON_MOUTH_RELATED_HML_TAGS;
for (ix = k = 0, len2 = ref2.length; k < len2; ix = ++k) {
testTag = ref2[ix];
if (theTag === testTag) {
tagMatch = ix;
}
}
if (tagMatch >= 0) {
newTok = (Defs.NON_MOUTH_RELATED_LETTERS.charAt(tagMatch)) + currTag;
} else {
newTok = currTag;
}
}
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: Tk: ${newTok}`);
}
tok = (tok === "" ? "" : tok + " ") + newTok;
}
}
}
return tok;
}
_scanNonMan(el) {
var hamVal, i, len, nd, ref, results;
ref = el.childNodes;
results = [];
for (i = 0, len = ref.length; i < len; i++) {
nd = ref[i];
if (!(nd.nodeType === Node.ELEMENT_NODE)) {
continue;
}
hamVal = this._nonManVal(nd);
if (typeof lggr.trace === "function") {
lggr.trace(`HNSSign: NonMan Element Name ${nd.nodeName}: ${hamVal}`);
}
if (this.hnsNonMan.length > 0) {
this.hnsNonMan += " ";
}
this.hnsNonMan += hamVal;
// Nothing expected
results.push(this._scanNonMan(nd));
}
return results;
}
man() {
return this.hnsMan;
}
nonman() {
return this.hnsNonMan;
}
gloss() {
return this.hnsGloss;
}
duration() {
return this.hnsDuration;
}
speed() {
return this.hnsSpeed;
}
timeScale() {
return this.hnsTimeScale;
}
};
// Export
cwaenv.add(HNSSign, "HNSSign");
// (End HNSSign.coffee)
}).call(this);
//-------- js/XSLT.Node.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   Wrapper for XSLT processing
var Data, LibXSLT, Logger, XSLT, cwaenv, lggr, logLev;
cwaenv = this.getCWAEnv();
Data = cwaenv.get("Data");
Logger = cwaenv.get("Logger");
lggr = Logger.get("XSLT"); // , "trace", "force"
LibXSLT = require("libxslt");
logLev = 0; // Set to 440 for initial testing
XSLT = class XSLT {
// Static
// Class Methods
constructor(_xslURI) {
this._xslURI = _xslURI;
this._xsltProc = null;
this.load = (Data.promiseURIText(this._xslURI)).then((xslText) => {
return new Promise((resolve, reject) => {
var ssResCB;
if (typeof lggr.debug === "function") {
lggr.debug(`Stylesheet fetched: ${this._xslURI}`);
}
ssResCB = (err, res) => {
if (err) {
if (typeof lggr.debug === "function") {
lggr.debug(`Stylesheet error: ${this._xslURI}: ${err}`);
}
}
this._xsltProc = res;
if (typeof lggr.debug === "function") {
lggr.debug(`Stylesheet loaded: ${this._xslURI}`);
}
return resolve(true);
};
LibXSLT.parse(xslText, ssResCB);
return null;
});
}).catch((err) => {
if (typeof lggr.debug === "function") {
lggr.debug(`XSLT load failure: ${err}`);
}
return false;
});
if (typeof lggr.debug === "function") {
lggr.debug(`Processor created: ${this._xslURI}`);
}
}
// Assumes that @_xsltProc is defined if possible via syncXSLT
apply(theXML) {
var err, txtRes, txtXML;
if (typeof lggr.trace === "function") {
lggr.trace(`Stylesheet applying ${this._xslURI}`);
}
txtXML = Data.mnDOM(theXML);
if (this._xsltProc) {
try {
txtRes = this._xsltProc.apply(txtXML);
if (typeof lggr.trace === "function") {
lggr.trace(`Stylesheet applied: ${this._xslURI}`);
}
return Data.toDOM(txtRes);
} catch (error) {
err = error;
lggr.warn(`Transform failure: ${err}`);
return null;
}
} else {
return null;
}
}
};
// Export
cwaenv.add(XSLT, "XSLT");
// (End XSLT.node.coffee)
}).call(this);
//-------- js/HtoG.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   Convert HamNoSys SiGML to Gestural SiGML
var Data, HMLBuilder, HNSSign, Ham4Parser, HamLexer, HtoG, Logger, Node, XSLT, cwaenv, lggr;
cwaenv = this.getCWAEnv();
Data = cwaenv.get("Data");
Node = cwaenv.get("Node");
HNSSign = cwaenv.get("HNSSign");
HamLexer = cwaenv.get("HamLexer");
Ham4Parser = cwaenv.get("Ham4Parser");
HMLBuilder = cwaenv.get("HMLBuilder");
XSLT = cwaenv.get("XSLT");
Logger = cwaenv.get("Logger");
lggr = Logger.get("SiGML"); // , "trace"
HtoG = class HtoG {
constructor(XSLTURI, hmlLog = false) {
this.XSLTURI = XSLTURI;
this.hmlLog = hmlLog;
this.XSLTProc = new XSLT(this.XSLTURI);
if (typeof lggr.info === "function") {
lggr.info(`HtoG: HtoG processor created for \"${this.XSLTURI}\"`);
}
}
treeString(el) {
var i, j, n, ref, res;
res = "";
if (el) {
res = `(${el}`;
n = el.getChildCount();
for (i = j = 0, ref = n; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
res += " " + this.treeString(el.getChild(i));
}
res += ")";
}
return res;
}
// Sort attributes into name order
_sortAttrs(el) {
var attList, attr, j, k, l, len, len1, len2, nd, newList, ref, results;
if (el.hasChildNodes()) {
ref = el.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
nd = ref[j];
if (nd.nodeType === Node.ELEMENT_NODE || nd.nodeType === Node.DOCUMENT_NODE) {
this._sortAttrs(nd);
}
}
}
if (el.nodeType === Node.ELEMENT_NODE && el.hasAttributes() && el.attributes.length > 1) {
attList = (function() {
var k, len1, ref1, results;
ref1 = el.attributes;
results = [];
for (k = 0, len1 = ref1.length; k < len1; k++) {
attr = ref1[k];
results.push(attr);
}
return results;
})();
newList = attList.sort(function(a, b) {
return a.name > b.name;
});
for (k = 0, len1 = attList.length; k < len1; k++) {
attr = attList[k];
el.removeAttribute(attr.name);
}
results = [];
for (l = 0, len2 = newList.length; l < len2; l++) {
attr = newList[l];
results.push(el.setAttribute(attr.name, attr.value));
}
return results;
}
}
sortDocAttrs(doc) {
this._sortAttrs(doc.documentElement);
return doc;
}
// Process an a hns_sign element to hamgestural_sign
_parseHSign(sigDoc) {
var builder, errReport, hamString, hmlDoc, lexer, parser, root, sigtrans, sigtree, treewalker;
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: SiGML: ${sigDoc} ${Data.ppDOM(sigDoc)}`);
}
hmlDoc = new HNSSign(sigDoc);
hamString = hmlDoc.man();
lexer = new HamLexer(hamString, Ham4Parser.tokenNames);
parser = new Ham4Parser(lexer);
// parser.setLogLevel 440 # Set Logging
root = (parser.hamsinglesign()).getTree();
errReport = parser.checkErrors();
if (errReport != null) {
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Parse errors: ${errReport.errCount}: ${errReport.errText}`);
}
return errReport;
} else {
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: After parsing: ${this.treeString(root)}`);
}
treewalker = new Ham4HMLGen(new org.antlr.runtime.tree.CommonTreeNodeStream(root));
// treewalker.setLogLevel 440
builder = new HMLBuilder();
try {
sigtree = treewalker.hamsignseq(builder);
// Add nonmanuals
builder.insertNonManual(sigtree.documentElement, hmlDoc.nonman());
// Set sign attributes
builder.checkedSetAttr(sigtree.documentElement, "gloss", hmlDoc.gloss());
builder.checkedSetAttr(sigtree.documentElement, "duration", hmlDoc.duration());
builder.checkedSetAttr(sigtree.documentElement, "speed", hmlDoc.speed());
builder.checkedSetAttr(sigtree.documentElement, "timescale", hmlDoc.timeScale());
if (this.hmlLog) {
Logger.OrigWarnLogger(`########  HML -- gloss: ${hmlDoc.gloss()}  ########\n${Data.ppDOM(sigtree)}\n`);
} else {
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: After tree building:\n${Data.ppDOM(sigtree)}`);
}
}
// sigtrans = @XSLTProc.applyXSLT sigtree # JRWG old
sigtrans = this.XSLTProc.apply(sigtree);
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: After XSLT processing:\n${Data.ppDOM(sigtrans)}`);
}
return {
// JRWG Assume no errors for now
sigDoc: sigtrans
};
} catch (error) {
if (typeof lggr.debug === "function") {
lggr.debug("HtoG: Failed tree building or XSLT transformation");
}
return {
errCount: 1,
errText: "Failed tree building or XSLT transformation"
};
}
}
}
// Clean a node of Text and Comment children
_cleanSiGML(parent) {
var cn, ix, j, k, len, len1, nd, nds, ref;
// Problems if not handled as array: but Array.from not available in IE
nds = [];
ref = parent.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
cn = ref[j];
if (cn != null) {
nds.push(cn);
}
}
for (ix = k = 0, len1 = nds.length; k < len1; ix = ++k) {
nd = nds[ix];
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: SiGML Element ${ix}: ${nd.nodeType} ${nd.nodeName}`);
}
switch (nd.nodeType) {
case Node.COMMENT_NODE:
case Node.TEXT_NODE:
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: Removing ${ix}: ${nd.nodeType} ${nd.nodeName}`);
}
parent.removeChild(nd);
break;
default:
if (nd.childNodes != null) {
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: Recursive call ${ix}`);
}
this._cleanSiGML(nd);
}
}
}
return parent;
}
// Process a complete SiGML DOM
_parseSiGML(sigDoc) {
var errCount, errText, gloss, j, len, nd, nom, parseRes, ref, ref1, ref2, signIx, typ;
errCount = 0;
errText = "";
signIx = 0;
if (sigDoc.documentElement != null) {
if (typeof lggr.info === "function") {
lggr.info("HtoG: SiGML document starts");
}
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: ppDOM orig:\n${Data.ppDOM(sigDoc)}`);
}
this._cleanSiGML(sigDoc);
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: ppDOM clean:\n${Data.ppDOM(sigDoc)}`);
}
ref = sigDoc.documentElement.childNodes;
for (j = 0, len = ref.length; j < len; j++) {
nd = ref[j];
nom = nd != null ? nd.nodeName : void 0;
typ = nd != null ? nd.nodeType : void 0;
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: SiGML Element: ${typ} ${nom}`);
}
if (nom === "hns_sign") {
signIx++;
gloss = (ref1 = nd.attributes.getNamedItem("gloss")) != null ? ref1.value : void 0;
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Sign ${signIx}: ${nom} gloss: ${gloss}`);
}
parseRes = this._parseHSign(nd);
if (parseRes != null ? parseRes.errText : void 0) {
errCount++;
errText += `${parseRes.errText} [Sign: ${signIx} Gloss: \"${gloss}\"]`;
sigDoc.documentElement.removeChild(nd);
} else if (parseRes != null ? parseRes.sigDoc : void 0) {
sigDoc.documentElement.replaceChild(parseRes.sigDoc, nd);
}
} else if (nom === "hamgestural_sign") {
signIx++;
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Sign ${signIx}: ${nom} gloss: ${(ref2 = nd.attributes.getNamedItem("gloss")) != null ? ref2.value : void 0}`);
}
}
}
if (typeof lggr.debug === "function") {
lggr.debug("HtoG: SiGML document ends");
}
} else {
errCount++;
errText += "Invalid SiGML file";
sigDoc = null;
}
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: ppDOM After:\n${Data.ppDOM(sigDoc)}`);
}
return {
sigDoc: sigDoc,
errCount: errCount,
errText: errText
};
}
parseHtoGText(sigTxt, theCB) {
var errCount, errText, errXML, res, sigDoc;
errCount = 0;
errText = "";
res = {};
errXML = (level, msg) => {
errCount++;
return errText += `XML parse ${level}: ${msg}`;
};
sigDoc = Data.toDOM(`${sigTxt}`, errXML);
if (sigDoc != null) {
res.sigDoc = sigDoc;
}
if (errCount > 0) {
res.errCount = errCount;
res.errText = errText;
return theCB(res);
} else {
// Ensure XSLT processor is loaded before proceeding
return this.XSLTProc.load.then((stat) => {
if (stat) {
return theCB(this._parseSiGML(res.sigDoc));
} else {
return theCB({
errCount: 1,
errText: `Could not create XSLT Processor for ${this.XSLTURI}`
});
}
});
}
}
parseHtoGURI(sigURI, theCB) {
var gotSiGML, res;
res = {};
gotSiGML = (sigDoc, errCount, msg) => {
if (errCount > 0) {
res.errCount = errCount;
res.errText = `SiGML fetch: ${msg}`;
if (sigDoc != null) {
res.sigDoc = sigDoc;
}
return theCB(res);
} else if (sigDoc != null) {
return this.parseHtoGText(sigDoc, theCB);
} else {
res.errCount = 1;
res.errText = "No SiGML data found";
return theCB(res);
}
};
return Data.fetchText(sigURI, gotSiGML);
}
setHMLLog(flag) {
return this.hmlLog = flag;
}
};
// Export
cwaenv.add(HtoG, "HtoG");
// (End HtoG.coffee)
}).call(this);
//-------- js/HtoG.main.js --------
// Generated by CoffeeScript 2.5.1
(function() {
//   Driver for Node HtoG application
var Data, FS, HMLLog, HtoG, HtoGProc, Logger, Node, ag, agsOK, argv, argvLen, convertDir, cwaenv, lggr, logLev, parseSiGML, resultCall, sigURI, stem, theAg, xmlPrologue;
cwaenv = this.getCWAEnv();
HtoG = cwaenv.get("HtoG");
Data = cwaenv.get("Data");
Node = cwaenv.get("Node");
Logger = cwaenv.get("Logger");
lggr = Logger.get("SiGML", "default", "stderr");
FS = require("fs");
argv = process.argv;
argvLen = argv.length;
logLev = "warn";
HMLLog = false;
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Args (${argvLen})[${argv}]`);
}
stem = argv[1].substr(0, argv[1].lastIndexOf("/"));
if (stem.length > 0) {
stem += "/";
}
xmlPrologue = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
// Read SiGML File rather than using the parseHtoGURI method
parseSiGML = function(sigURI, theCB, extraArg = null) {
var sigFilCB;
if (typeof lggr.info === "function") {
lggr.info(`HtoG: parseSiGML called for ${sigURI}`);
}
sigFilCB = (sigText, errCount, errText) => {
var check, dom, i, ix, len, nd, newCB, ref, res;
res = {};
if (errCount > 0) {
res.errCount = errCount;
res.errText = errText;
return theCB(res, extraArg);
} else if (sigText != null) {
// Extra Check for trailing (or leading) content
dom = Data.toDOM(sigText);
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: Text: ${sigText}`);
}
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: DOM: ${Data.ppDOM(Data.toDOM(sigText))}`);
}
check = dom != null;
if (check) {
ref = dom.childNodes;
for (ix = i = 0, len = ref.length; i < len; ix = ++i) {
nd = ref[ix];
if (nd.nodeType === Node.TEXT_NODE) {
check && (check = (nd.nodeValue.trim()).length === 0);
}
}
}
if (check) {
newCB = (res) => {
return theCB(res, extraArg);
};
// HtoGProc.parseHtoGText (Data.ppXML sigText, false), newCB
return HtoGProc.parseHtoGText(sigText, newCB);
} else {
res.errCount = 1;
res.errText = "Bad or empty content in SiGML file";
return theCB(res, extraArg);
}
} else {
res.errCount = 1;
res.errText = "No SiGML data found";
return theCB(res, extraArg);
}
};
return Data.fetchText(sigURI, sigFilCB);
};
convertDir = function(dir, dirnew) {
var dirCB;
while (dir.endsWith("/")) {
dir = dir.substr(0, dir.length - 1);
}
if (dirnew == null) {
dirnew = dir + "-g";
}
while (dirnew.endsWith("/")) {
dirnew = dirnew.substr(0, dirnew.length - 1);
}
if (lggr.log != null) {
Logger.OrigWarnLogger(`Convert Directory \"${dir}\" to \"${dirnew}\"`);
}
dirCB = (err, files) => {
var newDirCB;
if (err) {
return lggr.warn(`HtoG: Cannot list files for directory ${dir}`);
} else {
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Files: ${files}`);
}
newDirCB = (err) => {
var fil, i, len, procFile, sigFiles, worker;
if (err) {
return typeof lggr.warn === "function" ? lggr.warn(`HtoG: Cannot create new directory ${dirnew}`) : void 0;
} else {
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Created new directory ${dirnew}`);
}
procFile = (fil, nextCB) => {
var infil, newFilCB, outfil;
infil = `${dir}/${fil}`;
outfil = `${dirnew}/${fil}`;
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: ${infil} to ${outfil}`);
}
// Directory processing: Do not write file if errors occur
newFilCB = (theRes, newfil) => {
var doneCB, theG, theGtxt;
if ((theRes != null ? theRes.errCount : void 0) > 0) {
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Errors so ${newfil} not written. Errors: ${theRes.errCount} Text:\n${theRes.errText}`);
}
return nextCB();
} else if (theRes != null ? theRes.sigDoc : void 0) {
theG = theRes.sigDoc;
HtoGProc.sortDocAttrs(theG);
theGtxt = xmlPrologue + Data.ppDOM(theG.documentElement);
if (!theGtxt.endsWith("\n")) {
theGtxt += "\n";
}
doneCB = (err) => {
if (err) {
lggr.warn(`HtoG: Cannot write ${newfil}`);
} else {
if (lggr.log != null) {
Logger.OrigWarnLogger(`Processed file \"${infil}\"`);
} else {
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Wrote ${newfil}`);
}
}
}
return nextCB();
};
return FS.writeFile(newfil, theGtxt, doneCB);
} else {
lggr.warn(`HtoG: Unexpected outcome for ${newfil}`);
return nextCB();
}
};
return parseSiGML(infil, newFilCB, outfil);
};
sigFiles = [];
for (i = 0, len = files.length; i < len; i++) {
fil = files[i];
if (fil.match(".sigml")) {
sigFiles.push(fil);
}
}
if (typeof lggr.debug === "function") {
lggr.debug(`HtoG: Worker: Queue has ${sigFiles.length} entries`);
}
worker = () => {
var workfil;
workfil = sigFiles.pop();
if (workfil != null) {
if (typeof lggr.trace === "function") {
lggr.trace(`HtoG: Worker: File ${workfil}`);
}
return procFile(workfil, worker);
} else {
return typeof lggr.debug === "function" ? lggr.debug("HtoG: Worker: Queue completed") : void 0;
}
};
// In fact a single worker seems fastest so there is some
// unnecessary complexity here that might be removed
return worker(); // for [1..1]
}
};
return FS.mkdir(dirnew, newDirCB);
}
};
return FS.readdir(dir, dirCB);
};
// Single file: Display any document on error output if errors
resultCall = function(theRes, fil) {
var theG, theGtxt;
if ((theRes != null ? theRes.errCount : void 0) > 0) {
lggr.debug(`HtoG: Errors: ${theRes.errCount} Text:\n${theRes.errText}`);
}
if (theRes != null ? theRes.sigDoc : void 0) {
theG = theRes.sigDoc;
HtoGProc.sortDocAttrs(theG);
theGtxt = xmlPrologue + Data.ppDOM(theG.documentElement);
if ((theRes != null ? theRes.errCount : void 0) > 0) {
return lggr.debug(`HtoG:\n${theGtxt}`);
} else {
Logger.OrigLogLogger(theGtxt);
if (lggr.log != null) {
return Logger.OrigWarnLogger(`Processed file \"${fil}\"`);
} else {
return typeof lggr.info === "function" ? lggr.info("G-SiGML file generated") : void 0;
}
}
}
};
if (argv[2] === "-d" && argvLen > 3 && argvLen < 6) {
Logger.get("SiGML", logLev, "stderr");
HtoGProc = new HtoG(stem + "h2s.xsl", false);
convertDir(argv[3], argv != null ? argv[4] : void 0);
} else {
agsOK = true;
ag = 2;
while (agsOK && ag < argvLen) {
theAg = argv[ag];
if (typeof lggr.trace === "function") {
lggr.trace(`arg ${ag} is ${theAg}`);
}
switch (theAg) {
case "-hml":
HMLLog = true;
break;
case "-log":
case "-info":
case "-debug":
case "-trace":
if (logLev === "warn" || true) { // temp JRWG
logLev = theAg.substr(1, theAg.length);
} else {
agsOK = false;
}
break;
default:
if ((theAg.startsWith("-")) || (typeof sigURI !== "undefined" && sigURI !== null)) {
agsOK = false;
} else {
sigURI = theAg;
}
}
ag++;
}
if (agsOK) {
// Default to stdin
if (sigURI == null) {
sigURI = "/dev/stdin";
}
Logger.get("SiGML", logLev, "stderr");
HtoGProc = new HtoG(stem + "h2s.xsl", HMLLog);
if (typeof lggr.debug === "function") {
lggr.debug(`Log level: ${logLev}`);
}
if (typeof lggr.info === "function") {
lggr.info(`HtoG: File mode for: ${sigURI}`);
}
parseSiGML(sigURI, resultCall, sigURI);
} else {
Logger.OrigWarnLogger("Usage: [-hml|-log|-info|-trace|-debug] SiGMLFile | -d SIGMLDir [SiGMLOutDir]");
}
}
// (End HtoG.main.coffee)
}).call(this);
//--------  END  --------
